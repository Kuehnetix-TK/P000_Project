{"instance_id": "alien_1", "selected_database": "alien", "amb_user_query": "I want to analyze how the signal quality varies across different atmospheric conditions. For each condition, give condition name, the average quality value, the median quality value, and count how many usable signals there are. Sort the result by average value.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "signal quality", "sql_snippet": "s.SnrRatio - 0.1 * ABS(s.NoiseFloorDbm) AS SNQI", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "good signals", "sql_snippet": "SUM(CASE WHEN SNQI > 0 THEN 1 ELSE 0 END) as analyzable_signals", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY avg_snqi DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Signal-to-Noise Quality Indicator (SNQI)", "sql_snippet": "s.SnrRatio - 0.1 * ABS(s.NoiseFloorDbm) AS SNQI", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "alien_2", "selected_database": "alien", "amb_user_query": "Classify signals by their score level, and for each group, show the classification, signal count, average BFR measure, and the standard deviation of the anomaly metric.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "score level", "sql_snippet": "CASE WHEN p.TechSigProb * (1 - p.NatSrcProb) * p.SigUnique * (0.5 + p.AnomScore/10) < 0.25 THEN 'Low' WHEN p.TechSigProb * (1 - p.NatSrcProb) * p.SigUnique * (0.5 + p.AnomScore/10) < 0.75 THEN 'Medium' ELSE 'High' END AS tol_category", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "BFR measure", "sql_snippet": "AVG(s.BwHz/(s.CenterFreqMhz * 1000000.0)) as \"Bandwidth-to-Frequency Ratio\"", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "anomaly metric", "sql_snippet": "SQRT(AVG(p.AnomScore*p.AnomScore) - AVG(p.AnomScore)*AVG(p.AnomScore)) AS anomaly_stddev", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "TOLS Category", "sql_snippet": "COUNT(*) AS signal_count,AVG(s.BwHz / (s.CenterFreqMhz * 1000000)) AS avg_bfr,SQRT(AVG(p.AnomScore*p.AnomScore) - AVG(p.AnomScore)*AVG(p.AnomScore)) AS anomaly_stddev", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 52}]}
{"instance_id": "alien_3", "selected_database": "alien", "amb_user_query": "Analyze how lunar interference affects observations by showing the current moon phase, average interference level and the count of problematic events for each observatory, sorted by average interference.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "interference level", "sql_snippet": "AVG((1 - o.LunarDistDeg/180) * (1 - o.AtmosTransparency)) AS avg_lif", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "problematic events", "sql_snippet": "SUM(CASE WHEN (1 - o.LunarDistDeg/180) * (1 - o.AtmosTransparency) > 0.5 THEN 1 ELSE 0 END) as High_Lunar_Interference_Events", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sorted by average interference", "sql_snippet": "ORDER BY avg_lif DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Lunar Interference Factor (LIF)", "sql_snippet": "AVG((1 - o.LunarDistDeg / 180.0) * (1 - o.AtmosTransparency)) AS avg_lif", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "alien_4", "selected_database": "alien", "amb_user_query": "Which observatory stations are discovering the most potential candidate signals? For each station, display the observatory name, how many signals meet our detection thresholds, their average origin score, average frequency ratios, and what percentage of all detected candidates they've found. I need this ranked.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "candidate signals", "sql_snippet": "WHERE p.TechSigProb > 0.7 AND p.NatSrcProb < 0.3 AND p.ArtSrcProb < 50 AND s.BwHz / ( s.CenterFreqMhz * 1000000 ) < 0.001", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "detection thresholds", "sql_snippet": "p.TechSigProb > 0.7 AND p.NatSrcProb < 0.3 AND p.ArtSrcProb < 50", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "origin score", "sql_snippet": "p.TechSigProb * ( 1 - p.NatSrcProb ) * p.SigUnique * ( 0.5 + p.AnomScore / 10 ) AS TOLS", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "rank", "sql_snippet": "ORDER BY potential_tech_signals DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Technological Origin Likelihood Score (TOLS)", "sql_snippet": "p.TechSigProb * ( 1 - p.NatSrcProb ) * p.SigUnique * ( 0.5 + p.AnomScore / 10 ) AS TOLS", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "alien_5", "selected_database": "alien", "amb_user_query": "Show me a breakdown of signal encoding methods with several occurrences. For each method, display the type, the count, the average complexity measure, and average quality ratio. Also include signal details.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "signal encoding methods", "sql_snippet": "s.ModType", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "complexity measure", "sql_snippet": "AVG(s.ModIndex * (1 + (1 - ABS(s.FreqDriftHzs)/(s.FreqMhz*1000)) * s.SigDurSec/(1 + s.DoppShiftHz/1000)) * CASE WHEN s.ModType = 'AM' THEN 2 WHEN s.ModType = 'FM' THEN 1.5 ELSE 1 END)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "quality ratio", "sql_snippet": "AVG(s.SnrRatio)", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "signal details", "sql_snippet": "JSON_GROUP_OBJECT(s.SignalRegistry, JSON_OBJECT('mcs', s.ModIndex * (1 + (1 - ABS(s.FreqDriftHzs) / (s.FreqMhz * 1000)) * s.SigDurSec / (1 + s.DoppShiftHz / 1000) * CASE WHEN s.ModType = 'AM' THEN 2 WHEN s.ModType = 'FM' THEN 1.5 ELSE 1 END, 'snr', s.SnrRatio)) AS signal_details", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "WHERE s.ModType IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Modulation Complexity Score (MCS)", "sql_snippet": "AVG(s.ModIndex * (1 + (1 - ABS(s.FreqDriftHzs)/(s.FreqMhz*1000)) * s.SigDurSec/(1 + s.DoppShiftHz/1000)) * CASE WHEN s.ModType = 'AM' THEN 2 WHEN s.ModType = 'FM' THEN 1.5 ELSE 1 END) AS avg_mcs", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 30}]}
{"instance_id": "alien_6", "selected_database": "alien", "amb_user_query": "Which observatories have the most promising signals worth investigating? I need a summary by observatory showing the observatory name, their total signal count, average priority score and approximate Confirmation Confidence Score (CCS) values, number of important signals, number of high-confidence signals, and especially the number of signals that meet both criteria. Organize the results by observatories with the most promising signals first.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "promising", "sql_snippet": "SUM(CASE WHEN RPI > 3 AND CCS_approx > 0.8 THEN 1 ELSE 0 END) AS high_priority_high_confidence\nFROM priority_calc", "is_mask": true, "type": "intent_ambiguity"}, {"term": "priority score", "sql_snippet": "(p.TechSigProb * 4 + p.BioSigProb / 100 + p.SigUnique * 2 + p.AnomScore / 2) * (1 - p.FalsePosProb) AS RPI", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "important", "sql_snippet": "SUM(CASE WHEN RPI > 3 THEN 1 ELSE 0 END) AS high_priority_signals, SUM(CASE WHEN CCS_approx > 0.8 THEN 1 ELSE 0 END) AS high_confidence_signals, SUM(CASE WHEN RPI > 3 AND CCS_approx > 0.8 THEN 1 ELSE 0 END) AS high_priority_high_confidence", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "organize", "sql_snippet": "ORDER BY high_priority_high_confidence DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Research Priority Index (RPI)", "sql_snippet": "(p.TechSigProb * 4 + p.BioSigProb / 100 + p.SigUnique * 2 + p.AnomScore / 2) * (1 - p.FalsePosProb) AS RPI", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 8}]}
{"instance_id": "alien_7", "selected_database": "alien", "amb_user_query": "Create a report evaluating observatory conditions using the Observability Index and identifying stations meeting good observation conditions. The output should group stations by whether meets good observation conditions (bool:True or False). For each group, you should provide its boolean value, the count of stations, average AOI and a detailed JSON array of environmental factors containing station name, AOI value, an object called 'lunar factors' with lunar stage and lunar distance inside, and solar condition.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Observability Index", "sql_snippet": "o.AtmosTransparency * (1 - o.HumidityRate/100.0) * (1 - 0.02 * o.WindSpeedMs) AS aoi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "good observation conditions", "sql_snippet": "o.AtmosTransparency * (1 - o.HumidityRate/100) * (1 - 0.02 * o.WindSpeedMs) > 0.85 AND (o.LunarStage = 'New' OR o.LunarStage = 'First Quarter') AND o.LunarDistDeg > 45 AND (o.SolarStatus = 'Low' OR o.SolarStatus = 'Moderate')", "is_mask": false, "type": "intent_ambiguity"}, {"term": "solar condition", "sql_snippet": "o.SolarStatus", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "json array", "sql_snippet": "JSON_GROUP_ARRAY(JSON_OBJECT(\n        'station', ObservStation,\n        'aoi', ROUND(aoi, 3),\n        'lunar_factors', JSON_OBJECT(\n            'stage', LunarStage,\n            'distance', LunarDistDeg\n        ),\n        'solar_status', SolarStatus\n    )) AS observatory_details", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "average AOI", "sql_snippet": "ROUND(AVG(aoi), 3)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Optimal Observing Window (OOW)", "sql_snippet": "CASE WHEN o.AtmosTransparency * (1 - o.HumidityRate/100) * (1 - 0.02 * o.WindSpeedMs) > 0.85 THEN 1 ELSE 0 END AS OOW", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "alien_8", "selected_database": "alien", "amb_user_query": "Could you scan our database for potential signals matching narrowband profiles? I need the signal identifiers, central frequency, drift rate, bandwidth ratio and the classification of NTM categories based on signal stability.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "narrowband profiles", "sql_snippet": "WHERE (s.bwhz/(s.centerfreqmhz * 1000000.0)) < 0.001 AND s.freqdrifthzs < 1.0", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "signal stability", "sql_snippet": "s.freqdrifthzs", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Narrowband Technological Marker (NTM)", "sql_snippet": "CASE WHEN (s.bwhz/(s.centerfreqmhz * 1000000.0)) < 0.0001 AND s.freqdrifthzs < 0.1 THEN 'Strong NTM' WHEN (s.bwhz/(s.centerfreqmhz * 1000000.0)) < 0.0005 AND s.freqdrifthzs < 0.5 THEN 'Moderate NTM' ELSE 'Not NTM' END AS ntm_classification", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 15}]}
{"instance_id": "alien_9", "selected_database": "alien", "amb_user_query": "Give me a ranked list of all our observation sites by their quality score. For each site, I need the name, telescope ID, calculated score, any equipment problems listed together, how many issues there are, and the confidence level. Please oder them.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "observation sites", "sql_snippet": "FROM Observatories o INNER JOIN Telescopes t ON o.ObservStation = t.ObservStation", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "quality score", "sql_snippet": "(qa.AOI * (1 - qa.LIF) * (CASE WHEN qa.PointAccArc < 2 THEN 1 ELSE 2.0/qa.PointAccArc END)) AS OQF", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "listed together", "sql_snippet": "TRIM(REPLACE(REPLACE(REPLACE(qa.equipment_issues_cleaned, ',,', ','), ',,', ','), ',', ', '), ', ')", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY OQF DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Observational Confidence Level (OCL)", "sql_snippet": "CASE WHEN qa.AOI > 0.8 AND quality_assessment.EquipStatus = 'Operational' AND quality_assessment.CalibrStatus = 'Current' THEN 'High' WHEN qa.AOI BETWEEN 0.5 AND 0.8 THEN 'Medium' ELSE 'Low' END AS ocl_classification", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 16}]}
{"instance_id": "alien_10", "selected_database": "alien", "amb_user_query": "I want to find signals that might contain structured data by analyzing their stability. For each candidate, show the ID, signal type, one field that contains a combined stability textual report to integrate (frequency stability, phase stability, and signal integrity), and the pattern Label.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "pattern label", "sql_snippet": "CASE WHEN sa.SSM > 0.8 AND sa.EntropyVal BETWEEN 0.4 AND 0.8 AND sa.ModIndex > 0.5 THEN 'Coherent Information Pattern Detected' WHEN sa.SSM > 0.6 AND sa.EntropyVal BETWEEN 0.3 AND 0.9 THEN 'Potential Information Pattern' ELSE 'No Clear Pattern' END", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "integrate", "sql_snippet": "GROUP_CONCAT(CASE WHEN attribute = 'FreqStab' THEN 'Frequency: ' || value WHEN attribute = 'PhaseStab' THEN 'Phase: ' || value WHEN attribute = 'SigIntegrity' THEN 'Integrity: ' || value END, ', ' ORDER BY attribute) AS stability_factors,", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "CIP Classification Label", "sql_snippet": "SELECT sa.signalregistry,sa.signalclass,ROUND(sa.ssm, 3) AS ssm,GROUP_CONCAT(CASE WHEN attribute = 'FreqStab' THEN 'Frequency: ' || value WHEN attribute = 'PhaseStab' THEN 'Phase: ' || value WHEN attribute = 'SigIntegrity' THEN 'Integrity: ' || value END,', ') AS stability_factors,CASE WHEN sa.ssm > 0.8 AND sa.entropyval BETWEEN 0.4 AND 0.8 AND sa.modindex > 0.5 THEN 'Coherent Information Pattern Detected'WHEN sa.ssm > 0.6 AND sa.entropyval BETWEEN 0.3 AND 0.9 THEN 'Potential Information Pattern' ELSE 'No Clear Pattern' END AS pattern_assessment", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 24}]}
{"instance_id": "archeology_1", "selected_database": "archeology", "amb_user_query": "I'd like to see a quality assessment of scans across our archaeological sites. Show site code, site name, scan quality for each site and rank them.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "scan quality", "sql_snippet": "ROUND(AVG(POWER(10.0 / (LOG10(spc.scanresolmm * 1000.0) / LOG10(spc.pointdense)) * 5.0, 1.5) *(spc.coverpct / 100.0) *POWER(1.0 - spc.noisedb / 30.0, 2)), 2) AS avg_sqs", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(POWER(10.0 / (LOG(10, spc.scanresolmm * 1000.0) / LOG(10, spc.pointdense)) * 5.0, 1.5) *(spc.coverpct / 100.0) *POWER(1.0 - spc.noisedb / 30.0, 2)), 2) AS avg_sqs", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY avg_sqs DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Scan Quality Score (SQS)", "sql_snippet": "ROUND(AVG(POWER(10.0 / (LOG(10, spc.scanresolmm * 1000.0) / LOG(10, spc.pointdense)) * 5.0, 1.5) *(spc.coverpct / 100.0) *POWER(1.0 - spc.noisedb / 30.0, 2)), 2) AS avg_sqs", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "archeology_2", "selected_database": "archeology", "amb_user_query": "Could you help me find archaeological sites that might need urgent conservation attention? I'm particularly interested in identifying sites in Risk Zones. For each site, I'd like to see their code, name, structural condition, and status, along with their risk category.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Risk Zones", "sql_snippet": "CASE WHEN si.presstat IN ('Poor', 'Critical') AND sc.structstate <> 'Stable' THEN 'Degradation Risk Zone' ELSE 'Not in Risk Zone' END AS risk_zone", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "structural condition", "sql_snippet": "sc.structstate AS structural_state", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "risk category", "sql_snippet": "CASE WHEN si.presstat IN ('Poor', 'Critical') AND sc.structstate <> 'Stable' THEN 'Degradation Risk Zone' ELSE 'Not in Risk Zone' END AS risk_zone", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "status", "sql_snippet": "LEFT JOIN scanconservation AS sc ON si.zoneregistry = sc.zoneref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Degradation Risk Zone", "sql_snippet": "CASE WHEN si.presstat IN ('Poor', 'Critical') AND sc.structstate <> 'Stable' THEN 'Degradation Risk Zone'", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 14}]}
{"instance_id": "archeology_3", "selected_database": "archeology", "amb_user_query": "I'm planning our upcoming archaeological scanning sessions and want to understand which sites have the most suitable environments. Could you show me a report with each location's ID, name, and its average scanning suitability? This would help us prioritize places for scanning.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "suitable environments", "sql_snippet": "ROUND(AVG(100.0 - 2.5 * ABS(se.ambictemp - 20.0) - POWER(ABS((se.humepct - 50.0) / 2.0), 1.5) - 600.0 / (se.illumelux + 100.0)), 2) AS avg_esi", "is_mask": true, "type": "intent_ambiguity"}, {"term": "location", "sql_snippet": "FROM scanenvironment AS se JOIN sites AS si ON se.zoneref = si.zoneregistry", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "scanning suitability", "sql_snippet": "ROUND(AVG(100.0 - 2.5 * ABS(se.ambictemp - 20.0) - POWER(ABS((se.humepct - 50.0) / 2.0), 1.5) - 600.0 / (se.illumelux + 100.0)), 2) AS avg_esi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "ID", "sql_snippet": "se.zoneref AS site_code", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(100.0 - 2.5 * ABS(se.ambictemp - 20.0) - POWER(ABS((se.humepct - 50.0) / 2.0), 1.5) - 600.0 / (se.illumelux + 100.0)), 2) AS avg_esi", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Environmental Suitability Index (ESI)", "sql_snippet": "ROUND(AVG(100.0 - 2.5 * ABS(se.ambictemp - 20.0) - POWER(ABS((se.humepct - 50.0) / 2.0), 1.5) - 600.0 / (se.illumelux + 100.0)), 2) AS avg_esi", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "archeology_4", "selected_database": "archeology", "amb_user_query": "I'm evaluating the quality of our registrations and would like to understand which ones are most reliable. Could you show me the accuracy ratio and confidence levels for each registration? I'd need to see the registration ID, project ID, accuracy measurements, error values, calculated ratio, and what confidence level that translates to.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "registrations", "sql_snippet": "SELECT sr.logregistry AS registration_id", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "reliable", "sql_snippet": "CASE WHEN ( spc.scanresolmm / ( sr.logaccumm * SQRT(1.0 + sr.errvalmm / sr.logaccumm) ) ) > 1.5 AND sr.refmark LIKE '%Target%' THEN 'High Confidence'", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "accuracy ratio", "sql_snippet": "ROUND( ( spc.scanresolmm / ( sr.logaccumm * SQRT(1.0 + sr.errvalmm / sr.logaccumm) ) ), 2 ) AS rar", "is_mask": false, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND((spc.scanresolmm / (sr.logaccumm * SQRT(1.0 + sr.errvalmm / sr.logaccumm))), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Registration Accuracy Ratio (RAR)", "sql_snippet": "ROUND((spc.scanresolmm / (sr.logaccumm * SQRT(1.0 + sr.errvalmm / sr.logaccumm))),2) AS rar", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 33}]}
{"instance_id": "archeology_5", "selected_database": "archeology", "amb_user_query": "For our archaeological site evaluation, I need to quantify the preservation metrics across our collection. Please compute a quality index for each location. Present the results in descending order of quality values, displaying only the site code, site designation, and calculated value to facilitate prioritization of our digital preservation resources.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "preservation metrics", "sql_snippet": "ROUND(CAST((0.3 * COALESCE(adc.adc, 0)) + (0.3 * COALESCE(mfs.mfs, 0)) + (0.2 * COALESCE(rar.rar, 0)) + (0.2 * COALESCE(sce.sce, 0)) - (2 * SQRT(COALESCE(err.error_ratio, 0))) AS REAL), 2) AS dpq", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "quality index", "sql_snippet": "ROUND(CAST((0.3 * COALESCE(adc.adc, 0)) + (0.3 * COALESCE(mfs.mfs, 0)) + (0.2 * COALESCE(rar.rar, 0)) + (0.2 * COALESCE(sce.sce, 0)) - (2 * SQRT(COALESCE(err.error_ratio, 0))) AS REAL), 2) AS dpq", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "location", "sql_snippet": "si.zoneregistry AS site_code, si.zonelabel AS site_name", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST((0.3 * COALESCE(adc.adc, 0)) + (0.3 * COALESCE(mfs.mfs, 0)) + (0.2 * COALESCE(rar.rar, 0)) + (0.2 * COALESCE(sce.sce, 0)) - (2 * SQRT(COALESCE(err.error_ratio, 0))) AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(adc.adc, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Digital Preservation Quality (DPQ)", "sql_snippet": "ROUND(CAST((0.3 * COALESCE(adc.adc, 0)) + (0.3 * COALESCE(mfs.mfs, 0)) + (0.2 * COALESCE(rar.rar, 0)) + (0.2 * COALESCE(sce.sce, 0)) - (2 * SQRT(COALESCE(err.error_ratio, 0))) AS REAL), 2) AS dpq", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 38}]}
{"instance_id": "archeology_6", "selected_database": "archeology", "amb_user_query": "Would you generate a comprehensive report categorizing sites based on high-quality mesh standards? For each site, please include the site code, side name, total mesh count, high-fidelity mesh count and proportion (as a percentage), the average complexity ratio, average resolution parameters (in mm), average geometric accuracy measurements, and Mesh Quality. The data should be presented in descending order.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high-quality mesh", "sql_snippet": "CASE WHEN (sm.facetfaces / (sm.facetverts * POWER(sm.facetresmm, 2))) * 1000 > 5.0 AND sm.facetresmm < 1.0 AND sm.geomdeltamm < 0.5 THEN TRUE ELSE FALSE END", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "complexity ratio", "sql_snippet": "(sm.facetfaces / (sm.facetverts * POWER(sm.facetresmm, 2))) * 1000 AS mcr", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND( ( CAST(SUM(CASE WHEN ma.is_high_fidelity THEN 1 ELSE 0 END) AS REAL) / NULLIF(COUNT(ma.mesh_id), 0) * 100 ), 2 )", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN mesh_analysis AS ma ON s.zoneregistry = ma.site_code", "is_mask": false, "type": "join_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY high_fidelity_percentage DESC NULLS FIRST, high_fidelity_count DESC NULLS FIRST", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "High Fidelity Mesh", "sql_snippet": "CASE WHEN (sm.facetfaces / (sm.facetverts * POWER(sm.facetresmm, 2))) * 1000 > 5.0 AND sm.facetresmm < 1.0 AND sm.geomdeltamm < 0.5 THEN 1 ELSE 0 END AS is_high_fidelity", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "archeology_7", "selected_database": "archeology", "amb_user_query": "Show me each site's basci information, along with the average temperature, humidity, and illumination levels. I'd also like to see the average suitability for each site, classified into quartiles, to understand the range of conditions. Finally, classify each site into environmental condition categories.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "basic information", "sql_snippet": "SELECT s.zoneregistry AS site_code, s.zonelabel AS site_name,", "is_mask": false, "type": "intent_ambiguity"}, {"term": "average suitability", "sql_snippet": "ROUND(CAST(AVG(ea.esi) AS REAL), 1) AS avg_esi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "environmental condition categories", "sql_snippet": "CASE WHEN AVG(ea.esi) > 85 THEN 'Optimal Scanning Conditions' WHEN AVG(ea.esi) > 70 THEN 'Good Scanning Conditions' WHEN AVG(ea.esi) > 50 THEN 'Acceptable Scanning Conditions' ELSE 'Challenging Scanning Conditions' END AS scanning_condition_class, CASE WHEN MAX(ea.ambictemp) - MIN(ea.ambictemp) > 10 THEN 'High Temperature Variation' ELSE 'Stable Temperature' END AS temperature_stability", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(AVG(ea.ambictemp) AS REAL), 1)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY avg_esi DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Environmental Suitability Index (ESI)", "sql_snippet": "100 - 2.5 * ABS(se.ambictemp - 20) - POWER(ABS((se.humepct - 50) / 2), 1.5) - 600 / (se.illumelux + 100) AS esi", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "archeology_8", "selected_database": "archeology", "amb_user_query": "I want to evaluate each scan processing workflow's efficiency and identify whether it qualifies as a bottleneck. Please include the processing software, processing stage, their average processing hours, average CPU and GPU usage percentages, average data size in GB, the average efficiency value, and the efficiency status. Additionally, provide the total count of workflows for each combination of software and stage.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "workflow", "sql_snippet": "GROUP BY sp.flowsoft, sp.flowstage", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "efficiency", "sql_snippet": "ROUND(CAST(AVG(s.gbsize * LOG(10, COALESCE(spc.totalpts, 1000000)) / (sp.flowhrs * (sp.proccpu + sp.procgpu) / 200)) AS REAL), 1) AS avg_per", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "efficiency status", "sql_snippet": "CASE WHEN AVG(s.gbsize * LOG10(COALESCE(spc.totalpts, 1000000)) / (sp.flowhrs * (sp.proccpu + sp.procgpu) / 200)) < 0.5 THEN 'Bottleneck Detected' ELSE 'Efficient' END AS efficiency_status", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(AVG(sp.flowhrs) AS REAL), 1)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "cpu precision", "sql_snippet": "ROUND(CAST(AVG(sp.proccpu) AS REAL), 0) AS avg_cpu_usage_pct,", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "gpu precision", "sql_snippet": "ROUND(CAST(AVG(sp.procgpu) AS REAL), 0) AS avg_gpu_usage_pct,", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "data size precision", "sql_snippet": "ROUND(CAST(AVG(sp.procgpu) AS REAL), 0) AS avg_gpu_usage_pct,", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "efficiency ratio precision", "sql_snippet": "ROUND(CAST(AVG(s.gbsize * LOG(10, COALESCE(spc.totalpts, 1000000)) / (sp.flowhrs * (sp.proccpu + sp.procgpu) / 200)) AS REAL), 1) AS avg_per,", "is_mask": true, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN scanpointcloud AS spc ON s.arcref = spc.arcref", "is_mask": false, "type": "join_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY CASE WHEN AVG(s.gbsize * LOG(10, COALESCE(spc.totalpts, 1000000)) / (sp.flowhrs * (sp.proccpu + sp.procgpu) / 200)) < 0.5 THEN 1 ELSE 2 END NULLS LAST, avg_per NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(spc.totalpts, 1000000)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Processing Efficiency Ratio (PER)", "sql_snippet": "ROUND(CAST(AVG(s.gbsize * LOG(10, COALESCE(spc.totalpts, 1000000)) / (sp.flowhrs * (sp.proccpu + sp.procgpu) / 200)) AS REAL), 1) AS avg_per", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 8}]}
{"instance_id": "archeology_9", "selected_database": "archeology", "amb_user_query": "For each archaeological site, I need its density ratio and extraction efficiency to identify sites with high potential for feature extraction. Please include the site code, average density value, and average extraction value.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "density ratio", "sql_snippet": "CASE WHEN spc.clouddense > 0 AND ss.aream2 > 0 THEN spc.totalpts / (spc.clouddense * ss.aream2) ELSE 0 END AS pcdr", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "extraction efficiency", "sql_snippet": "CASE WHEN fp.pcdr > 0 THEN (sf.traitcount + sf.articount) / (fp.pcdr * SQRT(fp.clouddense)) * 1000 ELSE 0 END AS fee", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(AVG(pcdr) AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN scans AS s ON si.zoneregistry = s.zoneref", "is_mask": false, "type": "join_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY avg_fee DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Point Cloud Density Ratio (PCDR)", "sql_snippet": "CASE WHEN spc.clouddense > 0 AND ss.aream2 > 0 THEN spc.totalpts / ( spc.clouddense * ss.aream2 ) ELSE 0 END", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}, {"term": "Feature Extraction Efficiency (FEE)", "sql_snippet": "CASE WHEN fp.pcdr > 0 THEN (sf.traitcount + sf.articount) / (fp.pcdr * SQRT(fp.clouddense)) * 1000 ELSE 0 END", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 32}]}
{"instance_id": "archeology_10", "selected_database": "archeology", "amb_user_query": "My purpose is to analyze the Resource Utilization of our archaeological scanning equipment and categorize workflows according to the Efficiency Classification system. For each piece of equipment, please provide its ID, utilization value, average processing time in hours, efficiency ranking, workflow status, and resource details.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Resource Utilization", "sql_snippet": "sp.flowhrs * (sp.proccpu + sp.procgpu) / 2.0 / (sp.remaingb * 10 * LN(sm.facetverts + 10000)) as pru", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "resource details", "sql_snippet": "JSON_OBJECT(\n            'cpu_usage', rm.proccpu,\n            'gpu_usage', rm.procgpu,\n            'processing_hours', rm.flowhrs\n        ) as resource_details", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "Efficiency Classification", "sql_snippet": "CASE WHEN pru < 5.0 THEN 'Optimized' WHEN pru < 10.0 THEN 'Acceptable' ELSE 'Needs Optimization' END as workflow_status", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(pru, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY pru ASC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN scanmesh sm ON sp.zoneref = sm.zoneref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Processing Resource Utilization (PRU)", "sql_snippet": "sp.flowhrs * (sp.proccpu + sp.procgpu) / 2.0 / (sp.remaingb * 10 * LOG(sm.facetverts + 10000)) as pru", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 37}]}
{"instance_id": "cross_db_1", "selected_database": "cross_db", "amb_user_query": "List the top 5 high-risk data flows, showing each flows ID, risk score, and data sensitivity. Sort by data sensitivity.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "risk score", "sql_snippet": "COALESCE(rm.RiskAssess / NULLIF(rm.CtrlEff, 0), 0) AS res", "is_mask": true, "type": "schema_linking_ambiguity"}, {"term": "data sensitivity", "sql_snippet": "COALESCE(dp.VolGB, 0) * CASE WHEN dp.DataSense = 'High' THEN 3 WHEN dp.DataSense = 'Medium' THEN 2 ELSE 1 END AS dsi", "is_mask": true, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "Sort", "sql_snippet": "RANK() OVER (ORDER BY dsi DESC NULLS FIRST) AS volume_rank", "is_mask": true, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN RiskManagement AS rm ON df.RecordRegistry = rm.FlowLink LEFT JOIN DataProfile AS dp ON df.RecordRegistry = dp.FlowSign", "is_mask": false, "type": "join_ambiguity"}, {"term": "precision", "sql_snippet": "ROUND(CAST(res AS REAL), 2) AS risk_exposure_score, ROUND(CAST(dsi AS REAL), 2) AS data_sensitivity_index", "is_mask": true, "type": "decimal_ambiguity"}, {"term": "division by zero", "sql_snippet": "NULLIF(rm.CtrlEff, 0), 0)", "is_mask": false, "type": "divide_zero_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Data Sensitivity Index (DSI)", "sql_snippet": "COALESCE(dp.VolGB, 0) * CASE WHEN dp.DataSense = 'High' THEN 3 WHEN dp.DataSense = 'Medium' THEN 2 ELSE 1 END AS dsi", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "cross_db_2", "selected_database": "cross_db", "amb_user_query": "Group all vendors by their vendor risk level, where for each level, show the level name, the number of entities in that level, and the proportion. Sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "vendor risk level", "sql_snippet": "CASE WHEN vri < 2 THEN 'High Risk' WHEN vri < 3 THEN 'Medium Risk' ELSE 'Low Risk' END AS risk_tier", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "proportion", "sql_snippet": "ROUND(CAST(COUNT(*) AS REAL) * 100.0 / (SELECT COUNT(*) FROM TieredVendors), 2) AS percentage", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal places", "sql_snippet": "ROUND(CAST(COUNT(*) AS REAL) * 100.0 / (SELECT COUNT(*) FROM TieredVendors), 2) AS percentage", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort order", "sql_snippet": "ORDER BY CASE WHEN vendor_count IS NULL THEN 0 ELSE 1 END, vendor_count DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Vendor Reliability Index (VRI)", "sql_snippet": "SELECT vm.VendorTrace, CASE WHEN vm.VendSecRate = 'A' THEN 4 WHEN vm.VendSecRate = 'B' THEN 3 WHEN vm.VendSecRate = 'C' THEN 2 ELSE 1 END * CASE WHEN vm.ContrState = 'Active' THEN 1 ELSE 0.5 END AS vri", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 6}]}
{"instance_id": "cross_db_3", "selected_database": "cross_db", "amb_user_query": "Find several top high-pressure flows, and list each flow ID, its Bandwidth Saturation Index, and its Data Transfer Efficiency. Also sort them.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high-pressure flows", "sql_snippet": "WHERE df.BwidthPct * df.DataSizeMB / df.DurMin > 50 AND COALESCE(df.SuccessPct / NULLIF(df.ErrTally + 1, 0), 0) < 1.0", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "top", "sql_snippet": "ORDER BY bsi DESC NULLS FIRST LIMIT 10", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal places", "sql_snippet": "ROUND(CAST(bsi AS REAL), 2) AS bandwidth_saturation_index, ROUND(CAST(dte AS REAL), 2) AS data_transfer_efficiency", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "division by zero", "sql_snippet": "NULLIF(df.ErrTally + 1, 0), 0)", "is_mask": false, "type": "divide_zero_ambiguity"}, {"term": "sort by BSI", "sql_snippet": "ORDER BY bsi DESC NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Data Transfer Efficiency (DTE)", "sql_snippet": "COALESCE(df.SuccessPct / NULLIF(df.ErrTally + 1, 0), 0) AS dte", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "cross_db_4", "selected_database": "cross_db", "amb_user_query": "Find the top 5 data profiles with potential sensitive data issues. Output each profiles's ID, sensitivity metric, and Security Robustness Score as a JSON object.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "sensitive data issues", "sql_snippet": "WHERE dp.VolGB * CASE WHEN dp.DataSense = 'High' THEN 3 WHEN dp.DataSense = 'Medium' THEN 2 ELSE 1 END > 100 AND CASE WHEN sp.EncState = 'Full' AND sp.AclState = 'Strong' THEN 3 WHEN sp.EncState = 'Full' OR sp.AclState = 'Strong' THEN 2 ELSE 1 END < 2", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "JSON object", "sql_snippet": "JSON_OBJECT(\n        'ProfileTrace', dp.ProfileTrace, \n        'DataSensitivityIndex', ROUND((dp.VolGB * \n            CASE \n                WHEN dp.DataSense = 'High' THEN 3 \n                WHEN dp.DataSense = 'Medium' THEN 2 \n                ELSE 1 \n            END), 2), \n        'SecurityRobustnessScore', \n            CASE \n                WHEN sp.EncState = 'Full' AND sp.AclState = 'Strong' THEN 3 \n                WHEN sp.EncState = 'Full' OR sp.AclState = 'Strong' THEN 2 \n                ELSE 1 \n            END\n    ) AS exposure_details", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal places", "sql_snippet": "ROUND((dp.VolGB * CASE WHEN dp.DataSense = 'High' THEN 3 WHEN dp.DataSense = 'Medium' THEN 2 ELSE 1 END), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY dp.VolGB * CASE WHEN dp.DataSense = 'High' THEN 3 WHEN dp.DataSense = 'Medium' THEN 2 ELSE 1 END DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Security Robustness Score (SRS)", "sql_snippet": "'SecurityRobustnessScore', CASE WHEN sp.EncState = 'Full' AND sp.AclState = 'Strong' THEN 3 WHEN sp.EncState = 'Full' OR sp.AclState = 'Strong' THEN 2 ELSE 1 END", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "cross_db_5", "selected_database": "cross_db", "amb_user_query": "Find some compliance records with compliance issues. List each records ID, GDPR compliance status, local law compliance status, and the transfer path. Sort results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "compliance issues", "sql_snippet": "com.GdprComp = 'Non-compliant' OR (com.LocLawComp = 'Non-compliant' AND EXISTS ( SELECT 1 FROM DataFlow AS df2 WHERE df2.RecordRegistry = df.RecordRegistry AND df2.OrigNation <> df2.DestNation ))", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "some", "sql_snippet": "ORDER BY CASE WHEN ComplianceTrace IS NULL THEN 1 ELSE 0 END, ComplianceTrace LIMIT 10", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "ID", "sql_snippet": "ComplianceTrace", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY ComplianceTrace", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Transfer Path", "sql_snippet": "OrigNation || ' -> ' || DestNation AS transfer_path", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 70}]}
{"instance_id": "cross_db_6", "selected_database": "cross_db", "amb_user_query": "Find the top months with high severity for severe audits. List each month, the average severity, and its severity rank.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "top months", "sql_snippet": "WHERE severity_rank <= 3", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "severe audits", "sql_snippet": "WHERE afs > 0.5", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "severity", "sql_snippet": "COALESCE(CAST(ac.CritFindNum AS REAL) / NULLIF(ac.FindTally + 1, 0), 0) AS afs", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "month", "sql_snippet": "STRFTIME('%Y-%m', RemedDue) AS audit_month", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "rounded", "sql_snippet": "ROUND(CAST(avg_severity AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY audit_month", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null handling", "sql_snippet": "COALESCE(CAST(ac.CritFindNum AS REAL) / NULLIF(ac.FindTally + 1, 0), 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Audit Finding Severity (AFS)", "sql_snippet": "COALESCE(CAST(ac.CritFindNum AS REAL) / NULLIF(ac.FindTally + 1, 0), 0) AS afs", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "cross_db_7", "selected_database": "cross_db", "amb_user_query": "Find audits with a request load greater than 50. List each audit identifier, the request load, and a breakdown of request types (access, deletion, rectification, portability), and show up to 100 records.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "request load", "sql_snippet": "(ac.AccReqNum + ac.DelReqNum + ac.RectReqNum + ac.PortReqNum) * ac.RespTimeDay AS dsrp", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "audit identifier", "sql_snippet": "AuditTrace", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "rounded", "sql_snippet": "ROUND(dsrp, 2) AS request_pressure,", "is_mask": true, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY dsrp DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Data Subject Request Load (DSRL)", "sql_snippet": "(ac.AccReqNum + ac.DelReqNum + ac.RectReqNum + ac.PortReqNum) AS dsrl", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 8}]}
{"instance_id": "cross_db_8", "selected_database": "cross_db", "amb_user_query": "For international data transfers, calculate the data risk and list the flow ID, Cross-Border Risk Factor, data risk, and rank. Show only flows where CDVR is greater than 1000, and limit results to the top 5.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "international data transfers", "sql_snippet": "WHERE df.OrigNation <> df.DestNation", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "data risk", "sql_snippet": "((rm.RiskAssess / rm.CtrlEff) * CASE WHEN df.OrigNation <> df.DestNation THEN 2 ELSE 1 END) * dp.VolGB AS cdvr", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "rank", "sql_snippet": "ROW_NUMBER() OVER (ORDER BY cdvr DESC) AS risk_rank", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "top", "sql_snippet": "ORDER BY cdvr DESC LIMIT 5", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(cbrf AS REAL), 2) AS cross_border_risk_factor, ROUND(CAST(cdvr AS REAL), 2) AS cross_border_data_volume_risk", "is_mask": true, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY cdvr DESC NULLS FIRST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "rank number", "sql_snippet": "ROW_NUMBER() OVER (ORDER BY cdvr DESC) AS risk_rank", "is_mask": false, "type": "rank_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Cross-Border Data Volume Risk (CDVR)", "sql_snippet": "rm.RiskAssess / rm.CtrlEff) * CASE WHEN df.OrigNation <> df.DestNation THEN 2 ELSE 1 END) * dp.VolGB AS cdvr", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 33}]}
{"instance_id": "cross_db_9", "selected_database": "cross_db", "amb_user_query": "Find data profiles with failed checks, and calculate their Integrity Failure Count. List each profiles ID, its failure count, and the types of failures (like 'Integrity Check' or 'Checksum Verification') in a single string, separated by commas. Show only the top 10 profiles.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "failed checks", "sql_snippet": "WHERE intcheck = 'Failed' OR csumverify = 'Failed'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "failure count", "sql_snippet": "(CASE WHEN dp.IntCheck = 'Failed' THEN 1 ELSE 0 END) + (CASE WHEN dp.CsumVerify = 'Failed' THEN 1 ELSE 0 END) AS ifc", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "top", "sql_snippet": "ORDER BY ifc DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Failure Types List", "sql_snippet": "RTRIM(RTRIM(CASE WHEN IntCheck = 'Failed' THEN 'Integrity Check, ' ELSE '' END || CASE WHEN CsumVerify = 'Failed' THEN 'Checksum Verification' ELSE '' END), ', ') AS failure_types", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 73}]}
{"instance_id": "cross_db_10", "selected_database": "cross_db", "amb_user_query": "I want to find international data flows with significant compliance issues. Focus on flows with slow remediation timelines and nearing remediation deadlines. Show the flow ID, the Audit Compliance Pressure, and the days overdue. Sort and limit to the top 10 flows.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "international", "sql_snippet": "df.OrigNation != df.DestNation", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "significant compliance issues", "sql_snippet": "ap.acp > 5", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal places", "sql_snippet": "ROUND(ap.acp, 2) AS audit_compliance_pressure", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort order", "sql_snippet": "ORDER BY ap.days_overdue DESC, ap.acp DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Audit Compliance Pressure (ACP)", "sql_snippet": "((CAST(ac.CritFindNum AS REAL) / (ac.FindTally + 1)) * (ac.AccReqNum + ac.DelReqNum + ac.RectReqNum + ac.PortReqNum) * (CAST(ac.CritFindNum AS REAL) / (ac.FindTally + 1))) AS acp", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 57}]}
{"instance_id": "polar_1", "selected_database": "polar", "amb_user_query": "Show me the equipment type, equipment code, overall efficiency, safety index, their ranks, and how much those ranks differ across equipment. Sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "overall efficiency", "sql_snippet": "ROUND(CAST((performanceindex + reliabilityindex) / 2 * (1 - environmentalimpactindex / 10) AS REAL), 2) AS eer", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "how much those ranks differ", "sql_snippet": "ABS(RANK() OVER (PARTITION BY equipmenttype ORDER BY eer DESC NULLS FIRST) - RANK() OVER (PARTITION BY equipmenttype ORDER BY safetyindex DESC NULLS FIRST)) AS rank_difference", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "ranks", "sql_snippet": "RANK() OVER (PARTITION BY equipmenttype ORDER BY eer DESC NULLS FIRST) AS efficiency_rank, RANK() OVER (PARTITION BY equipmenttype ORDER BY safetyindex DESC NULLS FIRST) AS safety_rank", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY equipmenttype, eer DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Equipment Efficiency Rating (EER)", "sql_snippet": "ROUND(CAST(((performanceindex + reliabilityindex) / 2 * (1 - environmentalimpactindex / 10)) AS REAL), 2) AS eer", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "polar_2", "selected_database": "polar", "amb_user_query": "Could you identify all equipment that are fit for harsh weather in our polar database? Show me the equipment, heater status, insulation status, emergency light status, the structure margin, and their readiness label.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "fit for harsh weather", "sql_snippet": "WHEN ss.ssf > 0.7 AND ce.heaterstatus <> 'Off' AND tswg.insulationstatus <> 'Poor' AND (ls.emergencylightstatus = 'On' OR ls.emergencylightstatus = 'Testing') THEN 'Extreme Weather Ready'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "structure margin", "sql_snippet": "ROUND( CAST(( ( 100 - ws.structuralloadpercent ) / 100 * CASE WHEN ws.snowloadkgm2 > 100 OR ws.windspeedms > 20 THEN 0.5 WHEN ws.snowloadkgm2 > 50 OR ws.windspeedms > 10 THEN 0.8 ELSE 1.0 END ) AS REAL), 2 ) AS ssf", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "equipment", "sql_snippet": "e.equipmentcode, e.equipmenttype,", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "readiness label", "sql_snippet": "CASE WHEN ss.ssf > 0.7 AND ce.heaterstatus <> 'Off' AND tswg.insulationstatus <> 'Poor' AND (ls.emergencylightstatus = 'On' OR ls.emergencylightstatus = 'Testing') THEN 'Extreme Weather Ready' ELSE 'Not Ready' END AS ewr_status", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "WHERE ss.ssf IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN cabinenvironment AS ce ON e.equipmentcode = ce.cabineqref\nLEFT JOIN lightingandsafety AS ls ON e.equipmentcode = ls.lighteqref\nLEFT JOIN thermalsolarwindandgrid AS tswg ON e.equipmentcode = tswg.thermaleqref", "is_mask": false, "type": "join_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND( CAST(( ( 100 - ws.structuralloadpercent ) / 100 * CASE WHEN ws.snowloadkgm2 > 100 OR ws.windspeedms > 20 THEN 0.5 WHEN ws.snowloadkgm2 > 50 OR ws.windspeedms > 10 THEN 0.8 ELSE 1.0 END ) AS REAL), 2 )", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Extreme Weather Readiness (EWR)", "sql_snippet": "WHEN ss.ssf > 0.7 AND ce.heaterstatus <> 'Off' AND tswg.insulationstatus <> 'Poor' AND (ls.emergencylightstatus = 'On' OR ls.emergencylightstatus = 'Testing') THEN 'Extreme Weather Ready'", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 10}]}
{"instance_id": "polar_3", "selected_database": "polar", "amb_user_query": "For our polar safety assessment, I need to evaluate the safety equipment's reliability. Please provide a report showing the equipment code, equipment type, life support status, reliability score, reliability classification. Also include a JSON summary of oxygen status , medical status, and safety system status as support systems status. Focus only on safety equipment and sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "reliability score", "sql_snippet": "0.7 * oc.ors + 0.3 * COALESCE(tc.tie, 0) AS lssr", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "JSON", "sql_snippet": "json_object(\n        'oxygen_status', ls.oxygensupplystatus,\n        'medical_status', ls.medicalequipmentstatus,\n        'safety_system_status', ls.safetysystemstatus\n    ) AS support_systems_status", "is_mask": false, "type": "intent_ambiguity"}, {"term": "reliability classification", "sql_snippet": "CASE  WHEN lc.lssr >= 0.8 THEN 'High Reliability' WHEN lc.lssr >= 0.6 THEN 'Moderate Reliability' ELSE 'Low Reliability'  END AS reliability_classification", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY lssr DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(lc.lssr, 2) AS lssr", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN tie_calc tc ON oc.opmainteqref = tc.thermaleqref", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(tc.tie, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Life Support System Reliability (LSSR)", "sql_snippet": "0.7 * oc.ors + 0.3 * COALESCE(tc.tie, 0) AS lssr", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 33}]}
{"instance_id": "polar_4", "selected_database": "polar", "amb_user_query": "Provide the location type, station name, number of equipment at each station, how much they rely on renewables, total renewable power, and their classification. Only include equipment that has measurable solar or wind output data, and sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "how much they rely on renewables", "sql_snippet": "(CAST(json_extract(tswg.renewablemetrics, '$.solar.output_w') AS REAL) + CAST(json_extract(tswg.renewablemetrics, '$.wind.output_w') AS REAL)) / NULLIF((tswg.fuelcelloutputw + CAST(json_extract(tswg.renewablemetrics, '$.solar.output_w') AS REAL) + CAST(json_extract(tswg.renewablemetrics, '$.wind.output_w') AS REAL)), 0) * 100 AS rec", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "classification", "sql_snippet": "CASE \n  WHEN rec > 70 THEN 'Energy-Sustainable'\n  WHEN rec > 50 THEN 'Moderately Sustainable'\n  ELSE 'Low Sustainability'\nEND AS sustainability_classification", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "renewable power", "sql_snippet": "CAST(json_extract(tswg.renewablemetrics, '$.solar.output_w') AS REAL) + CAST(json_extract(tswg.renewablemetrics, '$.wind.output_w') AS REAL) AS renewable_output", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(rec AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY rec DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE NOT (tswg.renewablemetrics -> '$.solar' ->> '$.output_w') IS NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Renewable Energy Contribution (REC)", "sql_snippet": "(CAST(json_extract(tswg.renewablemetrics, '$.solar.output_w') AS REAL) + CAST(json_extract(tswg.renewablemetrics, '$.wind.output_w') AS REAL)) / NULLIF((tswg.fuelcelloutputw + CAST(json_extract(tswg.renewablemetrics, '$.solar.output_w') AS REAL) + CAST(json_extract(tswg.renewablemetrics, '$.wind.output_w') AS REAL)), 0) * 100 AS rec", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "polar_5", "selected_database": "polar", "amb_user_query": "For each combination of station name and zone type, I need to see station names, zone type, average water quality indices, average WRMI scores, count of systems that need water-saving, classification, and management situation. Group and sort results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "water-saving", "sql_snippet": "SUM(CASE WHEN wc.wrmi < 0.5 THEN 1 ELSE 0 END) AS systems_needing_conservation", "is_mask": false, "type": "intent_ambiguity"}, {"term": "classification", "sql_snippet": "CASE WHEN AVG(waw.waterqualityindex) >= 91 THEN 'High-Quality' WHEN AVG(waw.waterqualityindex) >= 71 THEN 'Good' WHEN AVG(waw.waterqualityindex) >= 51 THEN 'Moderate' WHEN AVG(waw.waterqualityindex) >= 26 THEN 'Poor' ELSE 'Unsafe' END AS quality_classification", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "management situation", "sql_snippet": "CASE WHEN AVG(wc.wrmi) < 0.5 THEN 'Conservation Needed' WHEN AVG(wc.wrmi) < 0.7 THEN 'Monitoring Advised' ELSE 'Sustainable Management' END AS management_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "zone type", "sql_snippet": "SELECT l.locationtype", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(AVG(waw.waterqualityindex) AS REAL), 2), ROUND(CAST(AVG(wc.wrmi) AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY avg_wrmi IS NULL, avg_wrmi DESC, avg_water_quality_index IS NULL, avg_water_quality_index DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Water Resource Management Index (WRMI)", "sql_snippet": "waw.waterlevelpercent * (waw.waterqualityindex / 100.0) * (1 - waw.wastetanklevelpercent / 100.0) AS wrmi", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "polar_6", "selected_database": "polar", "amb_user_query": "Could you calculate the readiness metric for all our equipment maintenance records? I'd like to see the registry ID, usage hours, service interval, operational status, and the calculated readiness metric for each record.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "readiness metric", "sql_snippet": "CASE WHEN operationalstatus = 'Active' THEN 10 * (1 - CAST(operationhours AS REAL)/maintenancecyclehours) WHEN operationalstatus = 'Standby' THEN 5 * (1 - CAST(operationhours AS REAL)/maintenancecyclehours) ELSE 0 END AS ORS", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "usage hours", "sql_snippet": "SELECT operationhours", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "service interval", "sql_snippet": "SELECT maintenancecyclehours", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Operational Readiness Score (ORS)", "sql_snippet": "CASE WHEN operationalstatus = 'Active' THEN 10 * (1 - CAST(operationhours AS REAL)/maintenancecyclehours) WHEN operationalstatus = 'Standby' THEN 5 * (1 - CAST(operationhours AS REAL)/maintenancecyclehours) ELSE 0 END AS ORS", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "polar_7", "selected_database": "polar", "amb_user_query": "I want to calculate the sustainability rating for each power device in our database. Please retrieve the equipment reference code, efficiency level, power source, and then calculate the corresponding sustainability rating for each device.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "sustainability rating", "sql_snippet": "CASE WHEN powersource IN ('Solar', 'Wind') THEN energyefficiencypercent * 1.5 WHEN powersource = 'Hybrid' THEN energyefficiencypercent * 1.2 WHEN powersource = 'Battery' THEN energyefficiencypercent * 1.0 WHEN powersource = 'Diesel' THEN energyefficiencypercent * 0.7 ELSE 0 END AS ESI", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "efficiency level", "sql_snippet": "SELECT energyefficiencypercent", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Energy Sustainability Index (ESI)", "sql_snippet": "CASE WHEN powersource IN ('Solar', 'Wind') THEN energyefficiencypercent * 1.5 WHEN powersource = 'Hybrid' THEN energyefficiencypercent * 1.2 WHEN powersource = 'Battery' THEN energyefficiencypercent * 1.0 WHEN powersource = 'Diesel' THEN energyefficiencypercent * 0.7 ELSE 0 END AS ESI", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "polar_8", "selected_database": "polar", "amb_user_query": "I would like to assess our polar base communication systems by calculating the Base Station Communication Stability Index for each communication unit. Please extract the registry ID, antenna status, signal quality, and delay time from our communication records, then calculate both the reliability rating and BSCSI for each unit.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "reliability rating", "sql_snippet": "CASE \n  WHEN antennastatus = 'Error' THEN 0 \n  WHEN antennastatus = 'Warning' THEN 5 \n  WHEN antennastatus = 'Normal' THEN 10 \n  ELSE 0 \nEND * (1 - (JSON_EXTRACT(signalmetrics, '$.latency_ms')/1000)) AS CRI", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "signal quality", "sql_snippet": "ROUND(JSON_EXTRACT(signalmetrics, '$.radio_strength_dbm'), 2) AS radio_strength", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "delay time", "sql_snippet": "ROUND(JSON_EXTRACT(signalmetrics, '$.latency_ms'), 2) AS latency_ms", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CASE WHEN antennastatus = 'Error' THEN 0 WHEN antennastatus = 'Warning' THEN 5 WHEN antennastatus = 'Normal' THEN 10 ELSE 0 END * (1 - (JSON_EXTRACT(signalmetrics, '$.latency_ms')/1000)), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Communication Reliability Index (CRI)", "sql_snippet": "ROUND(CASE WHEN antennastatus = 'Error' THEN 0 WHEN antennastatus = 'Warning' THEN 5 WHEN antennastatus = 'Normal' THEN 10 ELSE 0 END * (1 - (JSON_EXTRACT(signalmetrics, '$.latency_ms')/1000)), 2) AS CRI", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "polar_9", "selected_database": "polar", "amb_user_query": "Could you list all equipment with high Overall Safety Performance Index scores? Please display the equipment code, calculate the energy-efficiency metric, and show the OSPI value for each item.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high", "sql_snippet": "WHERE safetyindex * (((performanceindex + reliabilityindex)/2) * (1 - environmentalimpactindex/10)) * 0.8 > 0.75", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "energy-efficiency metric", "sql_snippet": "((performanceindex + reliabilityindex)/2.0) * (1.0 - environmentalimpactindex/10.0) AS EER", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Overall Safety Performance Index (OSPI)", "sql_snippet": "safetyindex * (((performanceindex + reliabilityindex)/2.0) * (1.0 - environmentalimpactindex/10.0)) * 0.8 AS OSPI", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 30}]}
{"instance_id": "polar_10", "selected_database": "polar", "amb_user_query": "For each chassis in our database, calculate the vehicle performance score. I need a report showing the chassis registry ID first, followed by the calculated score. Please include all chassis records in your analysis.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "vehicle performance score", "sql_snippet": "(1 - ((cv.brakepadwearpercent + cv.trackwearpercent)/200.0)) * (cv.vehiclespeedkmh/50.0) * (ef.engineloadpercent/100.0) AS VPC", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "calculated score", "sql_snippet": "(1 - ((cv.brakepadwearpercent + cv.trackwearpercent)/200.0)) * (cv.vehiclespeedkmh/50.0) * (ef.engineloadpercent/100.0) AS VPC", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "join", "sql_snippet": "LEFT JOIN engineandfluids ef ON cv.chassisengref = ef.engineregistry", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Vehicle Performance Coefficient (VPC)", "sql_snippet": "(1 - ((cv.brakepadwearpercent + cv.trackwearpercent)/200.0)) * (cv.vehiclespeedkmh/50.0) * (ef.engineloadpercent/100.0) AS VPC", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "gaming_1", "selected_database": "gaming", "amb_user_query": "Can you find gaming controllers that meet high standards? Please show me manufacturer, model, IRS score, joystick precision, drift resistance, trigger resistance, haptic strength, and whether each device meets professional standards.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "whether each device meets professional standards", "sql_snippet": "CASE WHEN irs.irs > 8.0 AND c.joyprec > 9.0 AND c.driftres > 9.5 AND c.trigres >= 5 AND c.hapstr > 8 THEN 'Yes' ELSE 'No' END AS meets_pro_standard", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(irs.irs, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY meets_pro_standard DESC NULLS FIRST, input_responsiveness_score DESC NULLS FIRST", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Processing Resource Utilization (PRU)", "sql_snippet": "sp.flowhrs * (sp.proccpu + sp.procgpu) / 2.0 / (sp.remaingb * 10 * LOG10(sm.facetverts + 10000)) as pru", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 37}]}
{"instance_id": "gaming_2", "selected_database": "gaming", "amb_user_query": "Analyze wireless devices' Battery Efficiency Ratio and classify them according to the efficiency categories. Please display maker name, model, battery life, battery capacity, power draw, Battery Efficiency Ratio, and the classification. Also, calculate the percentile ranking within each manufacturer.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "efficiency categories", "sql_snippet": "CASE WHEN ber > 7.5 THEN 'Excellent Efficiency' WHEN ber BETWEEN 5.0 AND 7.5 THEN 'Good Efficiency' WHEN ber BETWEEN 2.5 AND 4.9 THEN 'Average Efficiency' ELSE 'Poor Efficiency' END AS efficiency_category", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "wireless devices", "sql_snippet": "FROM deviceidentity AS d JOIN testsessions AS t ON d.devsessionref = t.sessionregistry WHERE d.conntype LIKE '%Wireless%' OR d.conntype LIKE '%Bluetooth%'", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "maker", "sql_snippet": "SELECT makername AS manufacturer", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(ber, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY ber DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Battery Efficiency Ratio (BER)", "sql_snippet": "(t.battlifeh * t.battcapmah) / (d.pwractmw * 10.0) AS ber", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "gaming_3", "selected_database": "gaming", "amb_user_query": "I want to analyze the RGB quality of various gaming peripherals and classify them according to the RGB Quality system. Please provide each device's manufacturer, model, device type, RGB brightness, color accuracy, number of RGB zones, RGB modes, supported colors, and their RGB implementation quality score and classification. Sort them by RGB quality score from highest to lowest.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "RGB quality", "sql_snippet": "(r.rgbbright / 100.0) * (r.rgbcoloracc / 10.0) * (0.5 + r.rgbzones / 20.0) AS riq", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "RGB Quality system", "sql_snippet": "CASE WHEN riq > 8.0 THEN 'Premium RGB Implementation' WHEN riq BETWEEN 6.0 AND 8.0 THEN 'High-Quality RGB' WHEN riq BETWEEN 3.0 AND 5.9 THEN 'Standard RGB' ELSE 'Basic RGB' END AS rgb_quality_category", "is_mask": false, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(rgbcoloracc, 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "RGB Implementation Quality (RIQ)", "sql_snippet": "(r.rgbbright / 100.0) * (r.rgbcoloracc / 10.0) * (0.5 + r.rgbzones / 20.0) AS riq", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 6}]}
{"instance_id": "gaming_4", "selected_database": "gaming", "amb_user_query": "Show me all devices with a Battery Efficiency exceeding 7.5. Display their IDs, manufacturers, models, and the calculated BER values", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Battery Efficiency", "sql_snippet": "ROUND((battlifeh * battcapmah) / (pwractmw * 10.0), 2) AS ber", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND((battlifeh * battcapmah) / (pwractmw * 10.0), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY ber DESC NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Battery Efficiency Ratio (BER)", "sql_snippet": "ROUND((battlifeh * battcapmah) / (pwractmw * 10.0), 2) AS ber", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "gaming_5", "selected_database": "gaming", "amb_user_query": "List all audio devices with an Audio Quality above 8.0. Include the audio ID, manufacturer name, model number, total harmonic distortion, speaker sensitivity, audio latency, and the calculated AQI value. Sort the results from highest to lowest AQI.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Audio Quality", "sql_snippet": "ROUND((1 - a.thdpct / 2.0) * (a.spksensedb / 100.0) * (1 - a.audlatms / 100.0) * 10, 2) AS aqi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "audio devices", "sql_snippet": "FROM audioandmedia AS a JOIN deviceidentity AS d ON a.auddevref = d.devregistry WHERE ( 1 - a.thdpct / 2.0 ) * ( a.spksensedb / 100.0 ) * ( 1 - a.audlatms / 100.0 ) * 10 > 8.0", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND((1 - a.thdpct / 2.0) * (a.spksensedb / 100.0) * (1 - a.audlatms / 100.0) * 10, 2) AS aqi", "is_mask": true, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Battery Efficiency Ratio (BER)", "sql_snippet": "ROUND((battlifeh * battcapmah) / (pwractmw * 10.0), 2) AS ber", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "gaming_6", "selected_database": "gaming", "amb_user_query": "Could you identify all devices with exceptional Wireless Performance above 8.5? I'd like to see the device registry ID and the calculated value for each device.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Wireless Performance", "sql_snippet": "WITH wpr_cte AS (SELECT d.devregistry, (d.wlrangem / 10.0) * (1 - d.wllatvar / 5.0) * (1 + (CASE WHEN d.wlchanhop THEN 1 ELSE 0 END) / 2.0) * ((t.wlsignal + 100) / 100.0) AS wpr", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "devices", "sql_snippet": "FROM deviceidentity AS d JOIN testsessions AS t ON d.devsessionref = t.sessionregistry WHERE d.pwractmw > 0", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(wpr.wpr * SQRT(ber.ber / 5.0) * (1 - wpr.wllatvar / 3.0) * 2, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY wpe DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Battery Efficiency Ratio (BER)", "sql_snippet": "(t.battlifeh * t.battcapmah) / (d.pwractmw * 10.0) AS ber", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "gaming_7", "selected_database": "gaming", "amb_user_query": "Show me all gaming devices with high endurance. I need their registry IDs, Durability Score, dust resistance length, water resistance length, bend force, and calculated PER value, sorted from highest to lowest PER.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high endurance", "sql_snippet": "FROM ds_cte AS ds WHERE ds.ds * ( 1 + ( LENGTH(COALESCE(ds.dustres, '')) + LENGTH(COALESCE(ds.waterres, '')) ) / 30.0 ) * ( 1 - ( 100 - ds.bendforce ) / 200.0 ) > 9.0", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(ds.ds, 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Durability Score (DS)", "sql_snippet": "SELECT physregistry, ((drophtm / 2.0) + (bendforce / 100.0) + (twistdeg / 90.0)) * (usbconndur / 10000.0) * 10 AS ds, dustres, waterres, bendforce FROM physicaldurability", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "gaming_8", "selected_database": "gaming", "amb_user_query": "I need a report of gaming devices with high adoption rate. Show me the device registry ID, Competitive Gaming Performance, profile count, Sensor Performance, Input Responsiveness Score, and calculated adoption rate value for all devices.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high adoption rate", "sql_snippet": "WHERE (c.cgpi / 10.0) * (1 + c.profcount / 5.0) * ((spi.spi + irs.irs) / 15.0) > 8.5", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "Gaming Performance", "sql_snippet": "SELECT d.devregistry, (irs.irs * 0.4) + (spi.spi * 0.3) + (spr.spr * 0.2) + (rai.rai * 0.1) AS cgpi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "Sensor Performance", "sql_snippet": "SELECT devregistry, (dpires / 1000.0) * (1 - mcresptime / 10.0) * 10 AS spi FROM deviceidentity", "is_mask": false, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(c.cgpi, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY par DESC NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Sensor Performance Index (SPI)", "sql_snippet": "SELECT devregistry, (dpires / 1000.0) * (1 - mcresptime / 10.0) * 10 AS spi FROM deviceidentity", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "gaming_9", "selected_database": "gaming", "amb_user_query": "Which gaming devices have good responsiveness ratings? Please show me the device ID, manufacturer, model number, polling rate, input lag, response time, and calculated IRS for my favorite gaming device categories. Sort the results from highest to lowest IRS.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "favorite gaming device categories", "sql_snippet": "t.devscope IN ('Keyboard', 'Mouse')", "is_mask": false, "type": "intent_ambiguity"}, {"term": "good responsiveness ratings", "sql_snippet": "FROM deviceidentity AS d JOIN testsessions AS t ON d.devsessionref = t.sessionregistry WHERE (t.pollratehz / 100.0) * (1 - (t.inplagms + t.resptimems) / 30.0) * 10 > 8.0", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND( ( t.pollratehz / 100.0 ) * ( 1 - ( t.inplagms + t.resptimems ) / 30.0 ) * 10, 2 )", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY irs IS NULL DESC, irs DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Input Responsiveness Score (IRS)", "sql_snippet": "ROUND((t.pollratehz / 100.0) * (1 - (t.inplagms + t.resptimems) / 30.0) * 10, 2) AS irs", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "gaming_10", "selected_database": "gaming", "amb_user_query": "I'm looking for high-end gaming mice that meet pro-level standards. Could you show me manufacturer names, model numbers, DPI resolution, polling rate, and calculate both the Sensor Quality Score and Comfort Index scores for each mouse? And mark which ones qualify as premium devices with a Yes/No column. Sort the results, so I can see the best performers.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high-end gaming mice", "sql_snippet": "CASE WHEN spi.sensor_performance > 7.5 AND d.dpires >= 16000 AND t.pollratehz >= 1000 AND ci.comfort_index > 8.0 THEN 'Yes' ELSE 'No' END AS is_premium_gaming_mouse", "is_mask": true, "type": "schema_linking_ambiguity"}, {"term": "Sensor Quality Score", "sql_snippet": "(dpires / 1000.0) * (1 - mcresptime / 10.0) * 10 AS sensor_performance", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "pro-level standards", "sql_snippet": "spi.sensor_performance > 7.5 AND d.dpires >= 16000 AND t.pollratehz >= 1000 AND ci.comfort_index > 8.0", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(spi.sensor_performance, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY spi_score IS NULL DESC, spi_score DESC, ci_score IS NULL DESC, ci_score DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Sensor Performance Index (SPI)", "sql_snippet": "ROUND(spi.sensor_performance, 2) AS spi_score", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "credit_1", "selected_database": "credit", "amb_user_query": "Can you show me the top wealthy customers with their financial value? Including their IDs, total assets, total liabilities, the computed net worth value, and their ranking.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "wealthy customers", "sql_snippet": "FROM expenses_and_assets", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "financial value", "sql_snippet": "totassets - totliabs AS computed_networth", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "the top", "sql_snippet": "LIMIT 10", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "ranking", "sql_snippet": "RANK() OVER (ORDER BY (totassets - totliabs) DESC) AS networth_rank", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY computed_networth DESC NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Net Worth", "sql_snippet": "totassets - totliabs AS computed_networth", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "credit_2", "selected_database": "credit", "amb_user_query": "Please find all the customer IDs who are highly digital.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "highly digital", "sql_snippet": "WHERE (json_extract(chaninvdatablock, '$.onlineuse') = 'High' OR json_extract(chaninvdatablock, '$.mobileuse') = 'High') AND json_extract(chaninvdatablock, '$.autopay') = 'Yes'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "customer IDs", "sql_snippet": "SELECT bankexpref", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Digital First Customer", "sql_snippet": "WHERE (chaninvdatablock ->> '$.onlineuse' = 'High' OR chaninvdatablock ->> '$.mobileuse' = 'High') AND chaninvdatablock ->> '$.autopay' = 'Yes'", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 14}]}
{"instance_id": "credit_3", "selected_database": "credit", "amb_user_query": "Can you identify all customers focused on investments in our database? I need to see their IDs, investment amounts and total assets.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "customers focused on investments", "sql_snippet": "WHERE (investport = 'Moderate' OR investport = 'Aggressive')\n  AND investexp = 'Extensive'\n  AND investamt > 0.3 * totassets", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Investment Focused", "sql_snippet": "WHERE (investport = 'Moderate' OR investport = 'Aggressive')\n  AND investexp = 'Extensive'\n  AND investamt > 0.3 * totassets", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 15}]}
{"instance_id": "credit_4", "selected_database": "credit", "amb_user_query": "Analyze customer credit scores by credit classification. Show the credit category, and the customers' details for each category.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "credit classification", "sql_snippet": "CASE WHEN credscore BETWEEN 300 AND 579 THEN 'Poor'\n    WHEN credscore BETWEEN 580 AND 669 THEN 'Fair'\n    WHEN credscore BETWEEN 670 AND 739 THEN 'Good'\n    WHEN credscore BETWEEN 740 AND 799 THEN 'Very Good'\n    WHEN credscore BETWEEN 800 AND 850 THEN 'Excellent'\n    ELSE 'Unknown'\n  END AS credit_category", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "details", "sql_snippet": "COUNT(*) AS customer_count, ROUND(AVG(credscore), 2) AS average_credscore", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(credscore), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Credit Score Categories", "sql_snippet": "CASE WHEN credscore BETWEEN 300 AND 579 THEN 'Poor'\n    WHEN credscore BETWEEN 580 AND 669 THEN 'Fair'\n    WHEN credscore BETWEEN 670 AND 739 THEN 'Good'\n    WHEN credscore BETWEEN 740 AND 799 THEN 'Very Good'\n    WHEN credscore BETWEEN 800 AND 850 THEN 'Excellent'\n    ELSE 'Unknown'\n  END AS credit_category", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 20}]}
{"instance_id": "credit_5", "selected_database": "credit", "amb_user_query": "To analyze customer property leverage, please show the customer ID, property value, mortgage balance, and the calculated ratio.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "property leverage", "sql_snippet": "CASE WHEN CAST(json_extract(propfinancialdata, '$.propvalue') AS REAL) > 0 THEN (CAST(json_extract(propfinancialdata, '$.mortgagebits.mortbalance') AS REAL) / CAST(json_extract(propfinancialdata, '$.propvalue') AS REAL)) ELSE NULL END AS ltv_ratio", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(ltv_ratio, 3)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY ltv_ratio DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE NOT propfinancialdata IS NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Loan-to-Value Ratio (LTV)", "sql_snippet": "CASE WHEN CAST(json_extract(propfinancialdata, '$.propvalue') AS REAL) > 0 THEN (CAST(json_extract(propfinancialdata, '$.mortgagebits.mortbalance') AS REAL) / CAST(json_extract(propfinancialdata, '$.propvalue') AS REAL)) ELSE NULL END AS ltv_ratio", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "credit_6", "selected_database": "credit", "amb_user_query": "I want to analyze customer financial standing. Please show the customer identifier, each customer's financial metrics.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "financial standing", "sql_snippet": "CASE WHEN (0.3 * (1 - ei.debincratio) + 0.3 * (ea.liqassets / (ei.mthincome * 6)) + 0.2 * (ea.bankaccbal / (ei.mthincome * 3)) + 0.2 * (ea.savamount / (ei.mthincome * 12))) < 1 THEN (0.3 * (1 - ei.debincratio) + 0.3 * (ea.liqassets / (ei.mthincome * 6)) + 0.2 * (ea.bankaccbal / (ei.mthincome * 3)) + 0.2 * (ea.savamount / (ei.mthincome * 12))) ELSE 1 END AS FSI", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "customer identifier", "sql_snippet": "SELECT cr.clientref", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "financial metrics", "sql_snippet": "ea.totassets - ea.totliabs AS net_worth, CASE WHEN (0.3 * (1 - ei.debincratio) + 0.3 * (ea.liqassets / (ei.mthincome * 6)) + 0.2 * (ea.bankaccbal / (ei.mthincome * 3)) + 0.2 * (ea.savamount / (ei.mthincome * 12))) < 1 THEN (0.3 * (1 - ei.debincratio) + 0.3 * (ea.liqassets / (ei.mthincome * 6)) + 0.2 * (ea.bankaccbal / (ei.mthincome * 3)) + 0.2 * (ea.savamount / (ei.mthincome * 12))) ELSE 1 END AS FSI", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Financial Stability Index (FSI)", "sql_snippet": "1 AS FSI", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 6}]}
{"instance_id": "credit_7", "selected_database": "credit", "amb_user_query": "To analyze digital engagement trends, please group customers into quarterly cohorts based on their tenure and identify digital natives. For each combination of cohort with whether they are digital natives, show the cohort quarter, bool value, the cohort size, engagement score, the percentage of the cohort with high engagement, and high-engagement percentage broken down by digital native status.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "digital natives", "sql_snippet": "(json_extract(bt.chaninvdatablock, '$.onlineuse') = 'High' OR json_extract(bt.chaninvdatablock, '$.mobileuse') = 'High') AND json_extract(bt.chaninvdatablock, '$.autopay') = 'Yes' AS is_digital_first", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "high-engagement percentage", "sql_snippet": "CAST(SUM(CASE WHEN ces > 0.7 THEN 1 ELSE 0 END) AS REAL) / COUNT(*) AS pct_high_engagement", "is_mask": false, "type": "intent_ambiguity"}, {"term": "by digital native status", "sql_snippet": "CASE WHEN SUM(CASE WHEN is_digital_first THEN 1 ELSE 0 END) = 0 THEN NULL ELSE SUM(CASE WHEN is_digital_first THEN 1 ELSE 0 END) END AS digital_first_high_engagement_rate", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY cohort_quarter, is_digital_first DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE bt.chaninvdatablock IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Digital First Customer", "sql_snippet": "(json_extract(bt.chaninvdatablock, '$.onlineuse') = 'High' OR json_extract(bt.chaninvdatablock, '$.mobileuse') = 'High') AND json_extract(bt.chaninvdatablock, '$.autopay') = 'Yes' AS is_digital_first", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 14}]}
{"instance_id": "credit_8", "selected_database": "credit", "amb_user_query": "I need to analyze debt burden across different customer segments. Can you provide a summary for each segment with relevant debt metrics? Also adda grant total row. Exclude any customer segment with few customers and order the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "debt situation", "sql_snippet": "AVG(ea.debincratio + CASE WHEN json_extract(ex.propfinancialdata, '$.propown') = 'Own' THEN (COALESCE(CAST(json_extract(ex.propfinancialdata, '$.mortgagebits.mortbalance') AS REAL), 0)/12) / ea.mthincome WHEN json_extract(ex.propfinancialdata, '$.propown') = 'Rent' THEN (COALESCE(CAST(json_extract(ex.propfinancialdata, '$.rentpayment') AS REAL), 0)) / ea.mthincome ELSE 0 END) AS avg_tdsr", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "relevant debt metrics", "sql_snippet": "COUNT(*) AS customer_count, AVG(ea.debincratio) AS avg_dti, AVG(ea.debincratio + CASE WHEN json_extract(ex.propfinancialdata, '$.propown') = 'Own' THEN (COALESCE(CAST(json_extract(ex.propfinancialdata, '$.mortgagebits.mortbalance') AS REAL), 0)/12) / ea.mthincome WHEN json_extract(ex.propfinancialdata, '$.propown') = 'Rent' THEN (COALESCE(CAST(json_extract(ex.propfinancialdata, '$.rentpayment') AS REAL), 0)) / ea.mthincome ELSE 0 END) AS avg_tdsr", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY avg_tdsr DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(CAST(json_extract(ex.propfinancialdata, '$.mortgagebits.mortbalance') AS REAL), 0)\n...\nCOALESCE(CAST(json_extract(ex.propfinancialdata, '$.rentpayment') AS REAL), 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN expenses_and_assets ex ON ea.emplcoreref = ex.expemplref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Total Debt Service Ratio (TDSR)", "sql_snippet": "AVG(ea.debincratio) AS avg_dti, AVG(ea.debincratio + CASE WHEN json_extract(ex.propfinancialdata, '$.propown') = 'Own' THEN (COALESCE(CAST(json_extract(ex.propfinancialdata, '$.mortgagebits.mortbalance') AS REAL), 0)/12) / ea.mthincome WHEN json_extract(ex.propfinancialdata, '$.propown') = 'Rent' THEN (COALESCE(CAST(json_extract(ex.propfinancialdata, '$.rentpayment') AS REAL), 0)) / ea.mthincome ELSE 0 END) AS avg_tdsr", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 30}]}
{"instance_id": "credit_9", "selected_database": "credit", "amb_user_query": "For each customer, show their ID, liquid and total assets, liquidity measure, monthly income, investment amount and label of their investment potential.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "liquidity measure", "sql_snippet": "(ea.liqassets / NULLIF(ea.totassets, 0)) AS ALR", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "investment potential", "sql_snippet": "CASE WHEN (ea.liqassets / NULLIF(ea.totassets, 0)) > 0.3 AND ei.mthincome > 5000 THEN 'Target' ELSE 'Standard' END AS target_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "customers", "sql_snippet": "INNER JOIN expenses_and_assets AS ea ON ei.emplcoreref = ea.expemplref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Asset Liquidity Ratio (ALR)", "sql_snippet": "(ea.liqassets / NULLIF(ea.totassets, 0)) AS ALR", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 35}]}
{"instance_id": "credit_10", "selected_database": "credit", "amb_user_query": "To pinpoint customers who might be facing financial hardship, I'd like to see their customer ID, the calculated vulnerability score, their net worth, delinquency count, and late payment count. Only output the customers with signs of financial hardship.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "signs of hardship", "sql_snippet": "WHERE FVS > 0.7 AND ( delinqcount > 0 OR latepaycount > 0 ) AND net_worth < 0", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "vulnerability score", "sql_snippet": "0.5 * ei.debincratio + 0.5 * (1 - (ea.liqassets / NULLIF(ei.mthincome * 6, 0))) AS FVS", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "join", "sql_snippet": "INNER JOIN employment_and_income AS ei ON cr.coreregistry = ei.emplcoreref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Financial Vulnerability Score (FVS)", "sql_snippet": "0.5 * ei.debincratio + 0.5 * (1 - (ea.liqassets / NULLIF(ei.mthincome * 6, 0))) AS FVS", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 33}]}
{"instance_id": "cybermarket_1", "selected_database": "cybermarket", "amb_user_query": "I want to track potential suspicious chains in our transactions. Please include their risk registry ID, chain risk value, transaction registry, and payment amount. Sort the results and show the top risky ones.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "suspicious chains", "sql_snippet": "(r.txchainlen * 10) + (r.linkedtxcount * 5) + (r.fraudprob * 100) - (r.profilecomplete * 0.5) - (r.idverifyscore * 0.5) AS transaction_chain_risk", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "chain risk value", "sql_snippet": "(r.txchainlen * 10) + (r.linkedtxcount * 5) + (r.fraudprob * 100) - (r.profilecomplete * 0.5) - (r.idverifyscore * 0.5) AS transaction_chain_risk", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "top risky ones", "sql_snippet": "ORDER BY rc.transaction_chain_risk DESC", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY rc.transaction_chain_risk DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Transaction Chain Risk (TCR)", "sql_snippet": "(r.txchainlen * 10) + (r.linkedtxcount * 5) + (r.fraudprob * 100) - (r.profilecomplete * 0.5) - (r.idverifyscore * 0.5) AS transaction_chain_risk", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 16}]}
{"instance_id": "cybermarket_2", "selected_database": "cybermarket", "amb_user_query": "Can you identify all trustworthy vendors in our cybermarket database? Show me their details, and Vendor Trust Index. Sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "trustworthy vendors", "sql_snippet": "WHERE vendchecklvl IN ('Advanced', 'Premium') AND ((CAST(v.vendsucccount AS REAL)/v.vendtxcount * 100) - (CAST(v.venddisputecount AS REAL)/v.vendtxcount * 50) + (v.vendrate * 5)) > 80", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "details", "sql_snippet": "SELECT v.vendregistry, v.vendrate, m.mktdenom AS market", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY vti IS NULL DESC, vti DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Trusted Vendor", "sql_snippet": "WHERE vendchecklvl IN ('Advanced', 'Premium') AND ( CAST(v.venddisputecount AS REAL) / v.vendtxcount ) < 0.05 AND v.vendspan > 90", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 21}]}
{"instance_id": "cybermarket_3", "selected_database": "cybermarket", "amb_user_query": "I need a risk assessment report of our cybermarket platforms' overall market risk rating. Please list the details and risk rating of each market. Present results in descending order.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "market risk rating", "sql_snippet": "ROUND((CAST(dlyflow AS REAL) / 1000) + (esccomprate * 0.2) + (interscore * 0.3) + (vendcount * 0.1) - (CAST(mktspan AS REAL) / 100), 2) AS market_risk_score", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "details", "sql_snippet": "SELECT mktregistry, mktdenom", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY market_risk_score DESC NULLS FIRST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND((CAST(dlyflow AS REAL) / 1000) + (esccomprate * 0.2) + (interscore * 0.3) + (vendcount * 0.1) - (CAST(mktspan AS REAL) / 100), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Market Risk Score (MRS)", "sql_snippet": "ROUND( ( CAST(dlyflow AS REAL) / 1000 ) + ( esccomprate * 0.2 ) + ( interscore * 0.3 ) + ( vendcount * 0.1 ) - ( CAST(mktspan AS REAL) / 100 ), 2 ) AS market_risk_score", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 10}]}
{"instance_id": "cybermarket_4", "selected_database": "cybermarket", "amb_user_query": "Could you analyze our communication records and calculate the privacy protection level for each communication that are high-level protected? I'd like to see the communication registry IDs along with their corresponding calculated privacy scores.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "privacy protection level", "sql_snippet": "(CASE c.vpnflag WHEN 'Yes' THEN 1 WHEN 'Suspected' THEN 0.5 ELSE 0 END * 30) + (c.tornodecount * 2) + (CASE c.encryptmethod WHEN 'Standard' THEN 1 WHEN 'Enhanced' THEN 2 WHEN 'Custom' THEN 3 ELSE 0 END * 15) + (c.connpatscore * 0.2) + (c.brwsrunique * 1.0 / 20) AS apl", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "high-level protected", "sql_snippet": "WHERE c.tornodecount > 20", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY apl IS NULL, apl DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Anonymity Protection Level (APL)", "sql_snippet": "(CASE c.vpnflag WHEN 'Yes' THEN 1 WHEN 'Suspected' THEN 0.5 ELSE 0 END * 30) + (c.tornodecount * 2) + (CASE c.encryptmethod WHEN 'Standard' THEN 1 WHEN 'Enhanced' THEN 2 WHEN 'Custom' THEN 3 ELSE 0 END * 15) + (c.connpatscore * 0.2) + (c.brwsrunique * 1.0 / 20) AS apl", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 19}]}
{"instance_id": "cybermarket_5", "selected_database": "cybermarket", "amb_user_query": "Calculate and rank all cybermarket markets by their operational stability. Show each platform's details, stability score, and current state. Include all markets in the results, treating them as having zero disputes. Present the results in descending order.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "platform", "sql_snippet": "FROM markets AS m LEFT JOIN vendors AS v ON m.mktregistry = v.mktref GROUP BY m.mktregistry\n)", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "operational stability", "sql_snippet": "(m.mktspan / 365.0) * (m.esccomprate / 100.0) * (1 - COALESCE(CAST(vd.total_disputes AS REAL) / NULLIF(vd.total_transactions, 0), 0)) * 100 AS msi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "current state", "sql_snippet": "json_extract(m.market_status_reputation, '$.status') AS status", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY msi IS NULL DESC, msi DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(SUM(v.vendtxcount), 1)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN vendors AS v ON m.mktregistry = v.mktref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Market Stability Index (MSI)", "sql_snippet": "(m.mktspan / 365.0) * (m.esccomprate / 100.0) * (1 - COALESCE(CAST(vd.total_disputes AS REAL) / NULLIF(vd.total_transactions, 0), 0)) * 100", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 15}]}
{"instance_id": "cybermarket_6", "selected_database": "cybermarket", "amb_user_query": "Identify all high-risk transaction patterns in our cybermarket database and list their details. Calculate their anomaly score and rank them.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high-risk transaction patterns", "sql_snippet": "(t.payamtusd/1000 * t.txfinishhrs/24 * (1 + CAST(t.escrowhrs AS REAL)/100) * (1 - mer.esccomprate/100)) AS transaction_anomaly_score", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "details", "sql_snippet": "SELECT t.txregistry, t.paymethod, t.payamtusd, t.escrowused, t.escrowhrs, t.routecomplexity", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "anomaly score", "sql_snippet": "(t.payamtusd/1000 * t.txfinishhrs/24 * (1 + CAST(t.escrowhrs AS REAL)/100) * (1 - mer.esccomprate/100)) AS transaction_anomaly_score", "is_mask": false, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY transaction_anomaly_score DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Suspicious Transaction Pattern", "sql_snippet": "WHERE (t.payamtusd/1000 * t.txfinishhrs/24 * (1 + CAST(t.escrowhrs AS REAL)/100) * (1 - mer.esccomprate/100)) > 75 AND t.paymethod = 'Crypto_B' AND (t.escrowused = 'No' OR t.escrowhrs < 24) AND t.routecomplexity = 'Complex'", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 22}]}
{"instance_id": "cybermarket_7", "selected_database": "cybermarket", "amb_user_query": "Help me identify high-priority investigations that require immediate attention. Show the investigation information. List the most urgent cases first.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high-priority investigations", "sql_snippet": "WHERE i.investigation_priority_score > 200 AND i.lawinterest = 'High'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "priority score", "sql_snippet": "(CASE i.lawinterest WHEN 'Low' THEN 1 WHEN 'Medium' THEN 2 WHEN 'High' THEN 3 WHEN 'Unknown' THEN 2 END * 30 + CASE i.regrisklvl WHEN 'Low' THEN 1 WHEN 'Medium' THEN 2 WHEN 'High' THEN 3 WHEN 'Unknown' THEN 2 END * 20 + r.fraudprob * 100 - i.compliancescore * 0.5 + i.notescount * 2) AS investigation_priority_score", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "investigation information", "sql_snippet": "SELECT i.investregistry, i.investigation_priority_score, i.lawinterest, t.txregistry", "is_mask": true, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY i.investigation_priority_score IS NULL, i.investigation_priority_score DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Priority Investigation Target", "sql_snippet": "WHERE i.investigation_priority_score > 200 AND i.lawinterest = 'High'", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 25}, {"term": "Investigation Priority Score (IPS)", "sql_snippet": "(CASE i.lawinterest WHEN 'Low' THEN 1 WHEN 'Medium' THEN 2 WHEN 'High' THEN 3 WHEN 'Unknown' THEN 2 END * 30 + CASE i.regrisklvl WHEN 'Low' THEN 1 WHEN 'Medium' THEN 2 WHEN 'High' THEN 3 WHEN 'Unknown' THEN 2 END * 20 + r.fraudprob * 100 - i.compliancescore * 0.5 + i.notescount * 2) AS investigation_priority_score", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 18}, {"term": "Suspicious Transaction Pattern", "sql_snippet": "JOIN transactions AS t ON r.txref = t.txregistry", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 22}]}
{"instance_id": "cybermarket_8", "selected_database": "cybermarket", "amb_user_query": "I need to identify suspicious communications in our system. Show me a report with the communication registry, VPN usage, language pattern, message count, communication risk, and mark any communications as Deceptive Pattern or Normal Pattern based on deceptive patterns. Sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "suspicious communication", "sql_snippet": "CASE WHEN ((CASE c.langpattern WHEN 'Consistent' THEN 1 WHEN 'Variable' THEN 2 WHEN 'Suspicious' THEN 3 ELSE 0 END * 15) + (csr.csr * 0.2) + (c.msgtally * 0.5) - (CASE WHEN c.vpnflag = 'Yes' THEN 0 WHEN c.vpnflag = 'Suspected' THEN 0.5 ELSE 1 END * 20)) > 70 AND c.langpattern = 'Suspicious' AND csr.csr > 80 THEN 'Deceptive Pattern' ELSE 'Normal Pattern' END", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "communication risk", "sql_snippet": "(iptally * 5) + (tornodecount * 2) + (CASE vpnflag WHEN 'Yes' THEN 1 WHEN 'Suspected' THEN 0.5 ELSE 0 END * 30) + (brwsrunique / 10.0) + (susppatscore * 3) + (riskindiccount * 4) AS csr", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "deceptive patterns", "sql_snippet": "((CASE c.langpattern WHEN 'Consistent' THEN 1 WHEN 'Variable' THEN 2 WHEN 'Suspicious' THEN 3 ELSE 0 END * 15) + (csr.csr * 0.2) + (c.msgtally * 0.5) - (CASE WHEN c.vpnflag = 'Yes' THEN 0 WHEN c.vpnflag = 'Suspected' THEN 0.5 ELSE 1 END * 20)) > 70 AND c.langpattern = 'Suspicious' AND csr.csr > 80", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(csr.csr, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY communication_pattern_risk DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Deceptive Communication Pattern", "sql_snippet": "CASE WHEN ((CASE c.langpattern WHEN 'Consistent' THEN 1 WHEN 'Variable' THEN 2 WHEN 'Suspicious' THEN 3 ELSE 0 END * 15) + (csr.csr * 0.2) + (c.msgtally * 0.5) - (CASE WHEN c.vpnflag = 'Yes' THEN 0 WHEN c.vpnflag = 'Suspected' THEN 0.5 ELSE 1 END * 20)) > 70 AND c.langpattern = 'Suspicious' AND csr.csr > 80 THEN 'Deceptive Pattern' ELSE 'Normal Pattern' END", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 43}, {"term": "Communication Security Risk (CSR)", "sql_snippet": "(iptally * 5) + (tornodecount * 2) + (CASE vpnflag WHEN 'Yes' THEN 1 WHEN 'Suspected' THEN 0.5 ELSE 0 END * 30) + (brwsrunique / 10.0) + (susppatscore * 3) + (riskindiccount * 4) AS csr", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "cybermarket_9", "selected_database": "cybermarket", "amb_user_query": "Show me all highly connected vendors, including their vendor registry ID, market size cluster, Vendor Trust Index, and VNC score. Please include all the vendors in the analysis. Sort the results in descending order.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "highly connected vendors", "sql_snippet": "WHERE (vmi.distinct_market_count * 5) + (CAST(vmi.vendtxcount AS REAL) / 50) + (vmi.vti * 0.1) - (1 - CASE vmi.sizecluster WHEN 'Small' THEN 1 WHEN 'Medium' THEN 2 WHEN 'Large' THEN 3 WHEN 'Mega' THEN 4 ELSE 0 END) * 10 > 50", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY vnc DESC NULLS FIRST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN markets AS m ON v.mktref = m.mktregistry", "is_mask": false, "type": "sort_ambiguity"}, {"term": "different", "sql_snippet": "COUNT(DISTINCT mktref)", "is_mask": false, "type": "distinct_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Vendor Network Centrality (VNC)", "sql_snippet": "(vmi.distinct_market_count * 5) + (CAST(vmi.vendtxcount AS REAL) / 50) + (vmi.vti * 0.1) - (1 - CASE vmi.sizecluster WHEN 'Small' THEN 1 WHEN 'Medium' THEN 2 WHEN 'Large' THEN 3 WHEN 'Mega' THEN 4 ELSE 0 END) * 10 AS vnc", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 31}]}
{"instance_id": "cybermarket_10", "selected_database": "cybermarket", "amb_user_query": "I'd like to calculate the Vendor Relationship Strength for all vendors who have completed at least one transaction. Please show me each vendor's registry ID along with their relationship score, and sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "relationship score", "sql_snippet": "(vendrate * 10) + (CAST(vendsucccount AS REAL) / vendtxcount * 50) + (vendchecklvl_numeric * 15) - (CAST(venddisputecount AS REAL) / vendtxcount * 100) AS vrs", "is_mask": false, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY vrs IS NULL DESC, vrs DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(CASE vendchecklvl WHEN 'Basic' THEN 1 WHEN 'Advanced' THEN 2 WHEN 'Premium' THEN 3 ELSE 0 END * 15 + (vendrate * 10) + (CAST(vendsucccount AS REAL) / vendtxcount * 50) - (CAST(venddisputecount AS REAL) / vendtxcount * 100), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Vendor Relationship Strength (VRS)", "sql_snippet": "(vendrate * 10) + (CAST(vendsucccount AS REAL) / vendtxcount * 50) + (vendchecklvl_numeric * 15) - (CAST(venddisputecount AS REAL) / vendtxcount * 100)", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 37}]}
{"instance_id": "museum_1", "selected_database": "museum", "amb_user_query": "Identify all valuable artifacts currently in a state of emergency. Show me their ID, name, insured value, conservation status, and the category of value. Only include valuable artifacts with serious conservation status.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "valuable artifacts", "sql_snippet": "InsValueUSD > 1000000 OR (hist_percentile = 1 AND cult_percentile = 1)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "state of emergency", "sql_snippet": "FROM artifact_rankings WHERE ConserveStatus = 'Critical'", "is_mask": false, "type": "intent_ambiguity"}, {"term": "category of value", "sql_snippet": "CASE WHEN InsValueUSD > 1000000 THEN 'Monetary High-Value' WHEN hist_percentile = 1 AND cult_percentile = 1 THEN 'Cultural/Historical High-Value' ELSE 'Other' END AS value_category", "is_mask": true, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "High-Value Artifact", "sql_snippet": "NTILE(10) OVER (ORDER BY r.HistSignRating DESC) AS hist_percentile, NTILE(10) OVER (ORDER BY r.CultScore DESC) AS cult_percentile", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 11}]}
{"instance_id": "museum_2", "selected_database": "museum", "amb_user_query": "I want to identify artifacts with very high environmental risks by calculating their risk factor. Could you show me each artifact's ID, name, calculated risk score, and a JSON summary of all its sensitivity ratings? Only include artifacts where the risk factor exceeds the critical threshold of 7, sorted from highest to lowest.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "very high", "sql_snippet": "WHERE (SELECT AVG(CASE WHEN lower(trim(s.EnvSensitivity))='high' THEN 10 WHEN lower(trim(s.EnvSensitivity))='medium' THEN 5 WHEN lower(trim(s.EnvSensitivity))='low' THEN 1 END) FROM SensitivityData s WHERE s.ArtRef = a.ArtRegistry) > 7", "is_mask": false, "type": "intent_ambiguity"}, {"term": "risk factor", "sql_snippet": "FROM sensitivitydata s WHERE s.artref = a.artregistry", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "risk score", "sql_snippet": "(SELECT AVG(CASE WHEN lower(trim(s.EnvSensitivity))='high' THEN 10 WHEN lower(trim(s.EnvSensitivity))='medium' THEN 5 WHEN lower(trim(s.EnvSensitivity))='low' THEN 1 END) FROM SensitivityData s WHERE s.ArtRef = a.ArtRegistry) AS ERF", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "important threshold", "sql_snippet": "WHERE (SELECT AVG(CASE WHEN lower(trim(s.EnvSensitivity))='high' THEN 10 WHEN lower(trim(s.EnvSensitivity))='medium' THEN 5 WHEN lower(trim(s.EnvSensitivity))='low' THEN 1 END) FROM SensitivityData s WHERE s.ArtRef = a.ArtRegistry) > 7", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY ERF DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Sensitivity Weight Values", "sql_snippet": "(SELECT AVG(CASE WHEN lower(trim(s.EnvSensitivity))='high' THEN 10 WHEN lower(trim(s.EnvSensitivity))='medium' THEN 5 WHEN lower(trim(s.EnvSensitivity))='low' THEN 1 END) FROM SensitivityData s WHERE s.ArtRef = a.ArtRegistry) AS ERF", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "museum_3", "selected_database": "museum", "amb_user_query": "Calculate and rank all artifacts to identify which need urgent care. The report must include Artifact ID, name, its historical era, and the score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "rank all artifacts", "sql_snippet": "ORDER BY CPI DESC", "is_mask": false, "type": "intent_ambiguity"}, {"term": "urgent care", "sql_snippet": "CASE ConserveStatus WHEN 'Excellent' THEN 1 WHEN 'Good' THEN 3 WHEN 'Fair' THEN 5 WHEN 'Poor' THEN 7 WHEN 'Critical' THEN 10 END AS status_score", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY CPI DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Conservation Priority Index (CPI)", "sql_snippet": "((r.HistSignRating + r.ResearchValRating + r.CultScore) * (10 - s.status_score)) / 30.0 AS CPI", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "museum_4", "selected_database": "museum", "amb_user_query": "I want to see which historical periods have adequate conservation resources and which might be facing a Budget Crisis. For each dynasty, show the dynasty name, their total priority score, the count of artifacts with adequate funding, the count with insufficient funding, the budget efficiency value, and a budget status that indicates 'Budget Crisis' if the dynasty meets the defined issue criteria, and 'Within Budget' otherwise. Besides, please include a summary row for all dynasties combined labeled as 'ALL DYNASTIES'.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Budget Crisis", "sql_snippet": "CASE WHEN SUM(c.CPI * (CAST(b.adequate_budget AS REAL) / IIF(b.total_records = 0, 1, b.total_records))) / IIF(COUNT(a.ArtRegistry) = 0, 1, COUNT(a.ArtRegistry)) < 0.5 AND SUM(CASE WHEN a.ConserveStatus = 'Critical' AND b.insufficient_budget > 0 THEN 1 ELSE 0 END) > 0 THEN 'Budget Crisis' ELSE 'Within Budget' END AS budget_status", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "priority score", "sql_snippet": "((r.HistSignRating + r.ResearchValRating + r.CultScore) * CASE a.ConserveStatus WHEN 'Excellent' THEN 9 WHEN 'Good' THEN 7 WHEN 'Fair' THEN 5 WHEN 'Poor' THEN 3 WHEN 'Critical' THEN 0 END) / 30.0 AS CPI", "is_mask": true, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "join", "sql_snippet": "FROM artifact_cpi c JOIN artifactscore a ON c.ArtRegistry = a.ArtRegistry LEFT JOIN budget_allocation b ON c.ArtRegistry = b.ArtRegistry", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Showcase Failure Risk", "sql_snippet": "CASE WHEN SUM(c.CPI * (CAST(b.adequate_budget AS REAL) / IIF(b.total_records = 0, 1, b.total_records))) / IIF(COUNT(a.ArtRegistry) = 0, 1, COUNT(a.ArtRegistry)) < 0.5 AND SUM(CASE WHEN a.ConserveStatus = 'Critical' AND b.insufficient_budget > 0 THEN 1 ELSE 0 END) > 0 THEN 'Budget Crisis' ELSE 'Within Budget' END AS budget_status", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 16}, {"term": "Conservation Priority Index (CPI)", "sql_snippet": "((r.HistSignRating + r.ResearchValRating + r.CultScore) * CASE a.ConserveStatus WHEN 'Excellent' THEN 9 WHEN 'Good' THEN 7 WHEN 'Fair' THEN 5 WHEN 'Poor' THEN 3 WHEN 'Critical' THEN 0 END) / 30.0 AS CPI", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "museum_5", "selected_database": "museum", "amb_user_query": "Show me whether items are in rapid deterioration, along with artifact's ID and name, the current conditions in their display case, how many sensitive factors they have, and whether they meet the accelerated deterioration criteria ('Yes' or 'No').", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "rapid deterioration", "sql_snippet": "(art.ArtAgeYears * CASE WHEN md.EnvSensitivity = 'Low' THEN 1 WHEN md.EnvSensitivity = 'Medium' THEN 5 WHEN md.EnvSensitivity = 'High' THEN 10 END * POWER((lr.RelHumidity - 50), 2) * lr.TempC) / 100000.0 AS mdr", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "current conditions", "sql_snippet": "mdr.TempC AS current_temp, mdr.RelHumidity AS current_humidity", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "join", "sql_snippet": "LEFT JOIN LatestReadings lr ON ur.ShowcaseRefUsed = lr.ShowcaseRef", "is_mask": false, "type": "join_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY env.ShowcaseRef, env.ReadTimestamp DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "museum_6", "selected_database": "museum", "amb_user_query": "Could you find all the different IDs of cases experiencing unstable conditions?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "cases", "sql_snippet": "SELECT DISTINCT ShowcaseRef", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "unstable conditions", "sql_snippet": "FROM EnvironmentalReadingsCore WHERE TempVar24h > 1 OR HumVar24h > 3", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "different", "sql_snippet": "SELECT DISTINCT ShowcaseRef", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY ShowcaseRef, ReadTimestamp DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "museum_7", "selected_database": "museum", "amb_user_query": "Help me find all the different IDs of showcases at risk of environmental issues by checking for failure conditions.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "environmental issues", "sql_snippet": "SELECT DISTINCT s.showcasereg FROM showcases s LEFT JOIN environmentalreadingscore er ON s.showcasereg = er.showcaseref WHERE (10 - ((er.tempvar24h + er.humvar24h / 5.0 + s.leakrate) / 3.0)) < 4 OR s.sealcondition = 'Poor' OR s.maintstatus = 'Overdue' OR s.filterstatus = 'Replace Now' OR s.silicagelstatus = 'Replace Now'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "failure conditions", "sql_snippet": "((CASE WHEN s.sealcondition = 'Poor' THEN 1 ELSE 0 END) + (CASE WHEN s.maintstatus = 'Overdue' THEN 1 ELSE 0 END) + (CASE WHEN s.filterstatus = 'Replace Now' THEN 1 ELSE 0 END) + (CASE WHEN s.silicagelstatus = 'Replace Now' THEN 1 ELSE 0 END)) AS failure_flags", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "different", "sql_snippet": "SELECT DISTINCT s.showcasereg", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN sesr_calc sc ON s.showcasereg = sc.showcaseref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "museum_8", "selected_database": "museum", "amb_user_query": "Identify all sensitive artifacts. For each artifact, provide its registry number, name, material type, light sensitivity, and current status ('Over Exposure' if maximum sensitivity in lux is above safe light levels, and 'Within Limits' otherwise).", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "sensitive artifacts", "sql_snippet": "WHERE sd.LightSensitivity IN ('High', 'Medium')", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "current status", "sql_snippet": "CASE WHEN (SELECT MAX(l.LightLux) FROM LightAndRadiationReadings l JOIN EnvironmentalReadingsCore e ON l.EnvReadRef = e.EnvReadRegistry JOIN UsageRecords u ON e.ShowcaseRef = u.ShowcaseRefUsed WHERE u.ArtRefUsed = a.ArtRegistry AND e.ReadTimestamp >= date('now', '-1 month') ) > CASE sd.LightSensitivity WHEN 'High' THEN 50 WHEN 'Medium' THEN 200 ELSE 300 END THEN 'Over Exposure' ELSE 'Within Limits' END", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "safe light levels", "sql_snippet": "CASE WHEN ( SELECT MAX(l.LightLux) FROM LightAndRadiationReadings AS l JOIN EnvironmentalReadingsCore AS e ON l.EnvReadRef = e.EnvReadRegistry JOIN UsageRecords AS u ON e.ShowcaseRef = u.ShowcaseRefUsed WHERE u.ArtRefUsed = a.ArtRegistry ) > CASE sd.LightSensitivity WHEN 'High' THEN 50 WHEN 'Medium' THEN 200 ELSE 300 END THEN 'Over Exposure' ELSE 'Within Limits' END AS light_exposure_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": []}
{"instance_id": "museum_9", "selected_database": "museum", "amb_user_query": "Flag the top 10 collection pieces in highest risk using the museum's threat score. Just give me their IDs and TETL scores - I need to see which need urgent protection first.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "highest risk", "sql_snippet": "WITH erf_calc AS (SELECT sd.artref, (CASE envsensitivity WHEN 'Low' THEN 1 WHEN 'Medium' THEN 5 WHEN 'High' THEN 10 ELSE 5 END + CASE lightsensitivity WHEN 'Low' THEN 1 WHEN 'Medium' THEN 5 WHEN 'High' THEN 10 ELSE 5 END + CASE tempsensitivity WHEN 'Low' THEN 1 WHEN 'Medium' THEN 5 WHEN 'High' THEN 10 ELSE 5 END + CASE humiditysensitivity WHEN 'Low' THEN 1 WHEN 'Medium' THEN 5 WHEN 'High' THEN 10 ELSE 5 END) / 4.0 AS erf", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "threat score", "sql_snippet": "ROUND(CAST(( e.erf + COALESCE(l.ler, 0) + COALESCE(m.mdr, 0) * 2 ) AS REAL), 2) AS tetl", "is_mask": false, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY tetl DESC NULLS FIRST LIMIT 10", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(CAST(( e.erf + COALESCE(l.ler, 0) + COALESCE(m.mdr, 0) * 2 ) AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN ler_calc AS l ON e.artref = l.artref LEFT JOIN mdr_calc AS m ON e.artref = m.artref", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(l.ler, 0) + COALESCE(m.mdr, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "museum_10", "selected_database": "museum", "amb_user_query": "Generate a rotation schedule using the standard formula. Show me each artifact's ID, name, material type, current display duration, their display limit, the calculated score and a clear recommendation ('Immediate Rotation' or 'Monitor') based on the threshold. Only include artifacts currently marked as 'Active' in the rotation schedule.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "standard formula", "sql_snippet": "ROUND(AVG(CASE WHEN LOWER(TRIM(s.EnvSensitivity))='high' THEN 10 WHEN LOWER(TRIM(s.EnvSensitivity))='medium' THEN 5 WHEN LOWER(TRIM(s.EnvSensitivity))='low' THEN 1 END), 2) AS ERF", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "display limit", "sql_snippet": "CASE WHEN (d.dsd - u.displaydurmonths) * COALESCE(l.light_factor, 1) * c.cpi_plus_1 / 100.0 < 0 THEN 'Immediate Rotation' ELSE 'Monitor' END AS rotation_recommendation", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND((d.dsd - u.displaydurmonths) * COALESCE(l.light_factor, 1) * c.cpi_plus_1 / 100.0, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN light_exp_avg l ON u.showcaserefused = l.showcaseref", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(l.light_factor, 1)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "AirQualityReadings.PM25Conc", "sql_snippet": "JOIN environmentalreadingscore ec ON ec.showcaseref = (SELECT ur.showcaserefused FROM usagerecords ur WHERE ur.artrefused = ac.artregistry LIMIT 1)", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 30}]}
{"instance_id": "solar_1", "selected_database": "solar", "amb_user_query": "Show me how panel efficiency changes with time by calculating the performance metric for different age ranges. I want to see the panel age, the average metric, and the number of panels of each age group.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "panel efficiency", "sql_snippet": "AVG(pe.measpoww / CAST(p.powratew AS REAL) * 100) AS avg_ppr", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "time", "sql_snippet": "CAST((julianday('now') - julianday(pl.initdate)) / 365.25 AS INTEGER) AS panel_age_years", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "performance metric", "sql_snippet": "CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', pl.initdate) AS INTEGER) AS panel_age_years", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "age ranges", "sql_snippet": "GROUP BY panel_age_years", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY panel_age_years", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Energy Production Efficiency (EPE)", "sql_snippet": "AVG(pe.measpoww / CAST(p.powratew AS REAL) * 100) AS avg_ppr", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "solar_2", "selected_database": "solar", "amb_user_query": "Generate a maintenance list for plants by calculating Maintenance Return on Investment (MROI) and applying priority rules. The output must include: plant name, capacity in MW, total maintenance costs, revenue losses, maintenance cost efficiency score, revenue loss rate, MROI value and final priority level (URGENT/HIGH/MEDIUM/LOW).", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "maintenance list", "sql_snippet": "FROM maintenance AS m JOIN plant AS p ON m.powerref = p.growregistry", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "priority rules", "sql_snippet": "CASE WHEN EXISTS(SELECT 1 FROM maintenance m2 WHERE m2.powerref = p.growregistry AND m2.alertcritical = 1) AND AVG((m.revlossusd - m.maintcostusd) / p.gencapmw) > 100 THEN 'URGENT' WHEN EXISTS(SELECT 1 FROM maintenance m2 WHERE m2.powerref = p.growregistry AND m2.alertcritical = 1) THEN 'HIGH' WHEN AVG((m.revlossusd - m.maintcostusd) / p.gencapmw) > 50 THEN 'MEDIUM' ELSE 'LOW' END AS priority_level", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY CASE WHEN pa.has_critical_alert = 1 AND mr.mroi > 2.0 THEN 1 WHEN pa.has_critical_alert = 1 THEN 2 WHEN mr.mroi > 2.0 THEN 3 ELSE 4 END, CASE WHEN mr.mroi IS NULL THEN 1 ELSE 0 END, mr.mroi DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "distinct", "sql_snippet": "GROUP_CONCAT(DISTINCT a.alertstat, ', ') AS alert_statuses", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "null", "sql_snippet": "CASE WHEN p.gencapmw > 0 THEN SUM(m.maintcostusd + m.cleancostusd + m.replacecostusd) / p.gencapmw ELSE NULL END AS mce", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN panel_alerts AS pa ON mr.powerref = pa.compreg", "is_mask": false, "type": "join_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(mr.gencapmw, 2) AS capacity_mw", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Revenue Loss Rate (RLR)", "sql_snippet": "CASE WHEN mc.gencapmw > 0 THEN mc.total_revenue_loss * 1.0 / mc.gencapmw ELSE NULL END AS rlr", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 8}]}
{"instance_id": "solar_3", "selected_database": "solar", "amb_user_query": "Calculate and compare the temperature impact across different panels. Show me each panel type alongside its average impact value.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "temperature impact", "sql_snippet": "AVG(p.powratew * p.tempcoef * (env.celltempc - 25)) AS avg_tpci", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "different panels", "sql_snippet": "GROUP BY p.panetype", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "average impact value", "sql_snippet": "AVG(p.powratew * p.tempcoef * (env.celltempc - 25)) AS avg_tpci", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "join", "sql_snippet": "GROUP BY p.panetype", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Temperature Performance Coefficient Impact (TPCI)", "sql_snippet": "AVG(p.powratew * p.tempcoef * (env.celltempc - 25)) AS avg_tpci", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "solar_4", "selected_database": "solar", "amb_user_query": "Analyze our solar plant performance by calculating the return score. Could you show me for each plant: its name, cost efficiency, downtime loss rate, and the resulting return score - so we can see which maintenance investments give the best returns?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "performance", "sql_snippet": "WITH plant_maintenance_costs AS (SELECT p.growalias, p.gencapmw, SUM(m.maintcostusd + m.cleancostusd + m.replacecostusd) AS total_maintenance_cost, AVG(m.revlossusd) AS avg_rev_loss FROM plant AS p JOIN maintenance AS m ON m.powerref = p.growregistry GROUP BY p.growalias, p.gencapmw)", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "return score", "sql_snippet": "SELECT CAST(rlr AS REAL) / mce AS mroi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "cost efficiency", "sql_snippet": "SELECT CAST(total_maintenance_cost AS REAL) / gencapmw AS mce", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "downtime loss rate", "sql_snippet": "SELECT avg_rev_loss / gencapmw AS rlr", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "join", "sql_snippet": "GROUP BY p.growalias, p.gencapmw", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Maintenance Cost Efficiency (MCE)", "sql_snippet": "SELECT CAST(total_maintenance_cost AS REAL) / gencapmw AS mce", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "solar_5", "selected_database": "solar", "amb_user_query": "Please identify the areas that need maintenance based on cleaning conditions by displaying the area ID, environmental readings measurement time, soiling loss, dust level, and soiling factor.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "maintenance", "sql_snippet": "SELECT cs.avg_sif FROM cleaning_schedule cs WHERE cs.soillosspct > 5 OR cs.dustdengm2 > 0.15 OR (cs.avg_sif * cs.dustdengm2) > 0.15 OR JULIANDAY(cs.envmoment) - JULIANDAY(cs.prev_moment) > 30", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "cleaning conditions", "sql_snippet": "WHERE cs.soillosspct > 5 OR cs.dustdengm2 > 0.15 OR JULIANDAY(cs.envmoment) - JULIANDAY(cs.prev_moment) > 30", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "soiling factor", "sql_snippet": "AVG(e.soillosspct / e.dustdengm2) OVER (PARTITION BY e.arearegistry) as avg_sif", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY sd.envmoment", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Soiling Impact Factor (SIF)", "sql_snippet": "AVG(e.soillosspct / e.dustdengm2) OVER (PARTITION BY e.arearegistry) as avg_sif", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 6}]}
{"instance_id": "solar_6", "selected_database": "solar", "amb_user_query": "I want to compute Total System Loss (TSL) per panel using Inverter Efficiency Loss (IEL). Can you provide each panel with its power ratings, current power, degradation, soiling loss, inverter losses and total system loss.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "panel", "sql_snippet": "p.solmodref AS panel_id", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "power ratings", "sql_snippet": "pa.powratew AS rated_power", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "degradation", "sql_snippet": "CAST(json_extract(p.efficiency_profile, '$.degradation.cumdegpct') AS REAL) / 100", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND((pa.powratew * (CAST((p.efficiency_profile -> '$.degradation' ->> '$.cumdegpct') AS REAL) / 100)) + (p.measpoww * (env.soillosspct / 100.0)) + inv.IEL, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN panel AS pa ON p.solmodref = pa.panemark", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Inverter Efficiency Loss (IEL)", "sql_snippet": "ROUND(p.measpoww * (1 - CAST((i.power_metrics ->> '$.inverteffpct') AS REAL) / 100), 2) AS IEL", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "solar_7", "selected_database": "solar", "amb_user_query": "Calculate the degradation rate for solar panels. Output should include panel ID, fill factor, years since setup, and the rate.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "degradation rate", "sql_snippet": "ROUND(((elec.ffactorinit - elec.ffactorcurr) / NULLIF(CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', plant.initdate) AS INTEGER), 0) * 100), 2) AS FFDR", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "initial and current values", "sql_snippet": "elec.ffactorinit AS fill_factor_initial, elec.ffactorcurr AS fill_factor_current", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "years since setup", "sql_snippet": "CAST((julianday('now') - julianday(plant.initdate)) / 365.25 AS INTEGER) AS years_since_installation", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(((elec.ffactorinit - elec.ffactorcurr) / NULLIF(CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', plant.initdate) AS INTEGER), 0) * 100), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN panel pa ON elec.engyunitref = pa.panemark INNER JOIN plant ON pa.hubregistry = plant.growregistry", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Fill Factor Degradation Rate (FFDR)", "sql_snippet": "ROUND(((elec.ffactorinit - elec.ffactorcurr) / NULLIF(CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', plant.initdate) AS INTEGER), 0) * 100), 2) AS FFDR", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "solar_8", "selected_database": "solar", "amb_user_query": "Determine the adjusted efficiency for solar panels, including panel ID, coefficient, temperature, efficiency metric, plane-of-array irradiance, and the efficiency result.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "adjusted efficiency", "sql_snippet": "ROUND((CAST((p.efficiency_profile -> '$.current_efficiency' ->> '$.curreffpct') AS REAL) * (1 + pa.tempcoef * (25 - env.celltempc) / 100) * (1000 / (CAST((env.irradiance_conditions -> '$.irradiance_types' ->> '$[3]') AS REAL)))), 2) AS WCE", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "coefficient", "sql_snippet": "pa.tempcoef AS temperature_coefficient, env.celltempc AS cell_temperature", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "efficiency metric", "sql_snippet": "CAST(json_extract(p.efficiency_profile, '$.current_efficiency.curreffpct') AS REAL) AS current_efficiency", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND((CAST((p.efficiency_profile -> '$.current_efficiency' ->> '$.curreffpct') AS REAL) * (1 + pa.tempcoef * (25 - env.celltempc) / 100) * (1000 / (CAST((env.irradiance_conditions -> '$.irradiance_types' ->> '$[3]') AS REAL)))), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN panel AS pa ON p.solmodref = pa.panemark INNER JOIN environment AS env ON env.arearegistry = pa.hubregistry", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "solar_9", "selected_database": "solar", "amb_user_query": "To assess degradation trends, please extract the site name, panel ID, start date, service years, efficiency values, annual degradation rate, efficiency loss metric, the calculated NDI, and then categorize panels.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "site name", "sql_snippet": "plant.growalias AS plant_name", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "start date", "sql_snippet": "plant.initdate AS installation_date", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "efficiency values", "sql_snippet": "p.paneeffpct AS initial_efficiency, CAST(REPLACE(REPLACE(JSON_EXTRACT(perf.efficiency_profile, '$.current_efficiency.curreffpct'), '[', ''), ']', '') AS REAL) AS current_efficiency", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "efficiency loss metric", "sql_snippet": "CASE WHEN ed.measurement_age_years > 0 THEN (ed.initial_efficiency - ed.current_efficiency) / ed.measurement_age_years ELSE NULL END AS pelr", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(nd.initial_efficiency, 2), ROUND(nd.current_efficiency, 2), ROUND(nd.annual_deg_rate, 2), ROUND(nd.pelr * 100, 2), ROUND(nd.ndi, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "null", "sql_snippet": "FROM panel p JOIN plant ON p.hubregistry = plant.growregistry WHERE plant.initdate IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "date_format", "sql_snippet": "strftime('%Y-%m-%d', nd.installation_date) AS installation_date", "is_mask": false, "type": "date_format_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Panel Efficiency Loss Rate (PELR)", "sql_snippet": "CASE WHEN ed.measurement_age_years > 0 THEN (ed.initial_efficiency - ed.current_efficiency) / ed.measurement_age_years ELSE NULL END AS pelr", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "solar_10", "selected_database": "solar", "amb_user_query": "For each inverter record, please build a query that outputs the inverter's unique identifier, the quality score, the Harmonic Distortion Percentage, power factor from key performance metrics, and calculate the grid quality.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "key performance metrics", "sql_snippet": "CAST(json_extract(power_metrics, '$.invertpowfac') AS REAL) AS inverter_power_factor", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "grid quality", "sql_snippet": "pwrqualidx * (1 - (CAST((power_metrics ->> '$.harmdistpct') AS REAL) / 100)) * (CAST((power_metrics ->> '$.invertpowfac') AS REAL)) AS GIQ", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "quality score", "sql_snippet": "SELECT pwrqualidx", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Grid Integration Quality (GIQ)", "sql_snippet": "pwrqualidx * ( 1 - ( CAST(( power_metrics ->> '$.harmdistpct' ) AS REAL) / 100 ) ) * ( CAST(( power_metrics ->> '$.invertpowfac' ) AS REAL) ) AS GIQ", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 37}]}
{"instance_id": "mental_1", "selected_database": "mental", "amb_user_query": "I want to identify urgent-risk Patients from facilities experiencing high stress, who also have weak engagement in therapy. For each patient, include their patient ID, assessment ID, date of their most recent assessment, their average rounded TES score, and the site's stress indicator they are associated with. Focus only on the most recent assessments and prioritize patients meeting all these criteria. Sort the results and just return the top results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "urgent-risk", "sql_snippet": "WHERE asr.suicrisk IN ('High', 'Severe') OR CAST(json_extract(asr.mental_health_scores, '$.depression.phq9_score') AS INTEGER) > 15 OR CAST(json_extract(asr.mental_health_scores, '$.anxiety.gad7_score') AS INTEGER) > 15", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "high stress", "sql_snippet": "WHERE envstress = 'Severe' OR lifeimpact = 'Severe'", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "weak engagement", "sql_snippet": "WHERE ra.rn = 1 AND ape.avg_engagement_score < 2", "is_mask": false, "type": "intent_ambiguity"}, {"term": "the top results", "sql_snippet": "ORDER BY ra.timemark DESC LIMIT 50", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(engagement_score))", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY ra.timemark DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "fs.fackey IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN FacilityStress AS fs ON ra.facid = fs.fackey", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Therapy Engagement Score (TES)", "sql_snippet": "ROUND(AVG(engagement_score)) AS avg_engagement_score", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "mental_2", "selected_database": "mental", "amb_user_query": "For all facilities, I want to explore the connection between each site's support level and its compliance rate. Include the overall support index as a reference and the correlation coefficient between each facility's resource adequacy score and treatment adherence rate.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "support level", "sql_snippet": "CASE json_extract(support_and_resources, '$.community_resources') WHEN 'Comprehensive' THEN 3 WHEN 'Adequate' THEN 2 WHEN 'Limited' THEN 1 ELSE 0 END", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "compliance rate", "sql_snippet": "SUM(CASE WHEN tro.txadh IN ('High', 'Medium') THEN 1 ELSE 0 END) AS adherent_outcomes", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "connection", "sql_snippet": "( SELECT SUM((resource_score - (SELECT AVG(resource_score) FROM CorrelationData)) * (tar - (SELECT AVG(tar) FROM CorrelationData))) / (SQRT(SUM((resource_score - (SELECT AVG(resource_score) FROM CorrelationData)) * (resource_score - (SELECT AVG(resource_score) FROM CorrelationData)))) * SQRT(SUM((tar - (SELECT AVG(tar) FROM CorrelationData)) * (tar - (SELECT AVG(tar) FROM CorrelationData))))) FROM CorrelationData ) AS correlation_frai_tar", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "WHERE json_extract(support_and_resources, '$.community_resources') IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN FacilityResources fr ON fr.fackey = fa.facid", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Facility Resource Adequacy Index (FRAI)", "sql_snippet": "AVG(resource_score) AS frai", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "mental_3", "selected_database": "mental", "amb_user_query": "Identify facilities classified as having a Facility with Potential Engagement-Outcome Disconnect. Display the facility ID and relevant scores. Sort them and send the first batch.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "relevant scores", "sql_snippet": "ROUND(AVG(engagement_score), 2) AS avg_tes, AVG(funcimpv_score) AS avg_funcimpv_score", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "the first batch", "sql_snippet": "ORDER BY ft.facid NULLS LAST LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(engagement_score), 2) AS avg_tes", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "null", "sql_snippet": "NOT tb.therapy_details IS NULL AND NOT e.facid IS NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY ft.facid IS NULL, ft.facid", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Recovery Trajectory Index (RTI)", "sql_snippet": "ROUND((AVG(funcimpv_score) * CASE WHEN COUNT(*) > 0 THEN CAST(SUM(is_adherent) AS REAL) / COUNT(*) ELSE 0 END), 2) AS rti", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 53}]}
{"instance_id": "mental_4", "selected_database": "mental", "amb_user_query": "I want to identify the best clinicians working at well-resourced sites based on their Patient Stability Metric. For each clinician, provide their ID, the facility ID, their stability score, and their ranking. Sort the results by facility ID and then by rank within each facility.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "best", "sql_snippet": "RANK() OVER (PARTITION BY facid ORDER BY psm DESC, clinid) AS rank_within_facility", "is_mask": false, "type": "intent_ambiguity"}, {"term": "well-resourced", "sql_snippet": "WHERE resource_score >= 2", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "stability score", "sql_snippet": "ROUND(1.0 / (1.0 + avg_cif + avg_mar), 2) AS psm", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "ranking", "sql_snippet": "ORDER BY facid, rank_within_facility", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(1.0 / (1.0 + avg_cif + avg_mar), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY facid, rank_within_facility", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(tb.crisisint, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN treatmentbasics AS tb ON e.enckey = tb.encref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Patient Stability Metric (PSM)", "sql_snippet": "ROUND(1.0 / (1.0 + avg_cif + avg_mar), 2) AS psm", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 33}, {"term": "Facility Resource Adequacy Index (FRAI)", "sql_snippet": "CASE json_extract(support_and_resources, '$.community_resources') WHEN 'Comprehensive' THEN 3 WHEN 'Adequate' THEN 2 WHEN 'Limited' THEN 1 ELSE 0 END AS resource_score", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "mental_5", "selected_database": "mental", "amb_user_query": "I want to find patients who seem to have shaky recovery. List each patient's ID, their average missed appointments, and their latest SSE score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "shaky recovery", "sql_snippet": "WHERE pama.avg_missappt > 2.0 OR lsse.sse_score < 3", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "latest", "sql_snippet": "SELECT sp.patkey, pss.sse_score \nFROM StablePatients sp \nJOIN PatientSocialSupport pss ON sp.patkey = pss.patkey \nJOIN encounters e ON pss.asdkey = e.abref AND e.patref = sp.patkey \nWHERE (sp.patkey, e.timemark) IN (\n    SELECT sp2.patkey, MAX(e2.timemark) \n    FROM StablePatients sp2 \n    JOIN PatientSocialSupport pss2 ON sp2.patkey = pss2.patkey \n    JOIN encounters e2 ON pss2.asdkey = e2.abref AND e2.patref = sp2.patkey \n    GROUP BY sp2.patkey\n)", "is_mask": false, "type": "syntactic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(missappt)) AS avg_missappt", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY sp.patkey, e.timemark DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "different", "sql_snippet": "SELECT sp.asdkey, sp.patkey FROM StablePatients sp JOIN encounters e ON sp.asdkey = e.abref AND e.patref = sp.patkey GROUP BY sp.patkey HAVING e.encdate = MAX(e.encdate)", "is_mask": false, "type": "distinct_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Patient Exhibiting Fragile Stability", "sql_snippet": "WHERE pama.avg_missappt > 2.0 OR lsse.sse_score < 3", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 56}]}
{"instance_id": "mental_6", "selected_database": "mental", "amb_user_query": "I want to identify which main conditions are associated with the most emergency episodes across all patients. For each diagnosis, list the diagnosis name, the number of patients with that diagnosis, and the crisis rate. Put the worst ones first and limit to the top 100 diagnoses.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "main conditions", "sql_snippet": "SELECT ab.patownerref, asd.primdx FROM (SELECT ab.patownerref, asd.primdx, ROW_NUMBER() OVER (PARTITION BY ab.patownerref ORDER BY e.timemark DESC) as rn FROM assessmentbasics ab JOIN assessmentsocialanddiagnosis asd ON ab.abkey = asd.asdkey JOIN encounters e ON ab.abkey = e.abref WHERE asd.primdx IS NOT NULL) ranked WHERE rn = 1", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "emergency episodes", "sql_snippet": "SUM(COALESCE(tb.crisisint, 0))", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "crisis rate", "sql_snippet": "ROUND(CAST(SUM(pci.total_crisisint) AS REAL) / pc.total_patients, 2) AS cif_per_diagnosis", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "worst ones", "sql_snippet": "ORDER BY cif_per_diagnosis DESC", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "COALESCE(tb.crisisint, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "CROSS JOIN PatientCount pc", "is_mask": false, "type": "join_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(CAST(SUM(pci.total_crisisint) AS REAL) / pc.total_patients, 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Crisis Intervention Frequency (CIF)", "sql_snippet": "ROUND(CAST(SUM(pci.total_crisisint) AS REAL) / pc.total_patients, 2) AS cif_per_diagnosis", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "mental_7", "selected_database": "mental", "amb_user_query": "I want to categorize facilities into performance quadrants. For each facility, list the facility ID, Treatment Adherence Rate, stability score, and the performance quadrant. Sort and send the top results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "stability score", "sql_snippet": "ROUND(fm.psm, 2) AS psm", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "the top results", "sql_snippet": "ORDER BY performance_quadrant, fm.facid\nLIMIT 100", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(fm.tar, 2), ROUND(fm.psm, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY performance_quadrant, fm.facid", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(tb.crisisint, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN treatmentbasics tb ON e.enckey = tb.encref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Facility Performance Quadrant (FPQ)", "sql_snippet": "CASE WHEN fm.tar >= t.median_tar AND fm.psm >= t.median_psm THEN 'High Adherence, High Stability' WHEN fm.tar >= t.median_tar AND fm.psm < t.median_psm THEN 'High Adherence, Low Stability' WHEN fm.tar < t.median_tar AND fm.psm >= t.median_psm THEN 'Low Adherence, High Stability' ELSE 'Low Adherence, Low Stability' END AS performance_quadrant", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 61}, {"term": "Patient Stability Metric (PSM)", "sql_snippet": "ROUND(fm.psm, 2) AS psm", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 33}]}
{"instance_id": "mental_8", "selected_database": "mental", "amb_user_query": "Analyze the impact of therapy adjustments on the Therapy Engagement Score and calculate the engagement variation for each change type. Show the change type, total occurrences, and average engagement score variation.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "therapy adjustments", "sql_snippet": "json_extract(tb.therapy_details, '$.changes') AS therapy_change", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "average engagement score variation", "sql_snippet": "ROUND(CAST(AVG(prev_engagement_score) AS REAL), 2) AS avg_previous_score, ROUND(CAST(AVG(engagement_score) AS REAL), 2) AS avg_current_score, ROUND(CAST(AVG(CASE WHEN NOT prev_engagement_score IS NULL THEN engagement_score - prev_engagement_score END) AS REAL), 2) AS avg_engagement_score_change", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(AVG(prev_engagement_score) AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY total_records DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE NOT tb.therapy_details IS NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Therapy Engagement Score (TES)", "sql_snippet": "CASE json_extract(tb.therapy_details, '$.engagement') WHEN 'High' THEN 3 WHEN 'Medium' THEN 2 WHEN 'Low' THEN 1 WHEN 'Non-compliant' THEN 0 ELSE NULL END", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "mental_9", "selected_database": "mental", "amb_user_query": "For facilities with lots of high-risk cases wiht prevalence over 20%, calculate the Resource-Demand Differential. List the facility ID, PFIS, FRAI, and RDD scores, showing the top facilities.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high-risk cases", "sql_snippet": "SUM(CASE WHEN asr.suicrisk IN ('High', 'Severe') THEN 1 ELSE 0 END) AS high_risk_assessments,\n        CASE\n            WHEN COUNT(*) > 0 THEN (CAST(SUM(CASE WHEN asr.suicrisk IN ('High', 'Severe') THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*))\n            ELSE 0\n        END AS srp", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "the top", "sql_snippet": "ORDER BY rdd DESC LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY rdd DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE e.facid IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Resource-Demand Differential (RDD)", "sql_snippet": "(fpf.pfis - ffr.frai) AS rdd", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 34}]}
{"instance_id": "mental_10", "selected_database": "mental", "amb_user_query": "Identify facilities exhibiting characteristics of serious system strain.For each facility, return its ID and the gap score. Return the top ones.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "system strain", "sql_snippet": "WHERE frdd.rdd > 1.0 AND frdd.facid IN (SELECT facid FROM AttritionRiskFacilities)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "gap score", "sql_snippet": "ROUND((pfis.pfis - ff.frai), 2) AS rdd", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "top ones", "sql_snippet": "ORDER BY frdd.rdd DESC\nLIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "WHERE NOT tb.therapy_details IS NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY frdd.rdd IS NULL DESC, frdd.rdd DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND((pfis.pfis - ff.frai), 2) AS rdd", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Treatment Adherence Rate (TAR)", "sql_snippet": "CASE WHEN COUNT(tro.txoutkey) > 0 THEN CAST(SUM(CASE WHEN tro.txadh IN ('High', 'Medium') THEN 1 ELSE 0 END) AS REAL) / COUNT(tro.txoutkey) ELSE 0 END AS tar", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}, {"term": "Therapy Engagement Score (TES)", "sql_snippet": "AVG(CASE (tb.therapy_details ->> '$.engagement') WHEN 'High' THEN 3 WHEN 'Medium' THEN 2 WHEN 'Low' THEN 1 WHEN 'Non-compliant' THEN 0 ELSE 0 END) AS avg_tes", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}, {"term": "Systemically Stressed Facility Environment", "sql_snippet": "WHERE frdd.rdd > 1.0 AND frdd.facid IN (SELECT facid FROM AttritionRiskFacilities)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 59}]}
{"instance_id": "news_1", "selected_database": "news", "amb_user_query": "Show me daily User Engagement Rate (UER) trends, displaying only sessions that performed better than usual. Include the session date, calculated UER, and the daily average UER. Sort results to see how engagement changes.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "performed better than usual", "sql_snippet": "WHERE user_engagement_rate > ( SELECT CAST(AVG(( seshviews * CAST(engscore AS REAL) ) / seshdur) AS REAL) FROM sessions )", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "engagement changes", "sql_snippet": "AVG(user_engagement_rate) OVER (PARTITION BY sess_date) AS avg_daily_uer", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY sess_date NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "news_2", "selected_database": "news", "amb_user_query": "Generate a report showing article engagement metrics grouped by topic. For each article, include how engaging each piece is and how easy it is to read, then output the article topic name with a JSON array containing each article's details and respective scores.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "how engaging each piece is", "sql_snippet": "(qualscore + freshscore + sentscore - contrscore) / 3.0 AS aqi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "how easy it is to read", "sql_snippet": "(readsec * LOG10(wordlen)) / diff_w   AS ars", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "topic", "sql_snippet": "GROUP BY catlabel", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "respective scores", "sql_snippet": "(qualscore + freshscore + sentscore - contrscore) / 3.0 AS aqi, (qualscore + freshscore + sentscore - contrscore) / 3.0 AS aqi", "is_mask": false, "type": "intent_ambiguity"}, {"term": "details", "sql_snippet": "SELECT artkey, catlabel", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": []}
{"instance_id": "news_3", "selected_database": "news", "amb_user_query": "For every session, I want to evaluate its Real-Time Session Efficiency (RTSE) by relating interaction flow to adjusted bounce impact. Please show me session ID, start time, the bounce impact, average sequence value from interactions, and the resulting efficiency score. Make sure the results avoid divide-by-zero errors.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "interaction flow", "sql_snippet": "AVG(i.seqval) OVER(PARTITION BY s.seshkey) AS avg_seqval", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "adjusted bounce impact", "sql_snippet": "s.bncrate * ( 1 - s.ctrval / 100.0 ) AS sbra", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "efficiency score", "sql_snippet": "avg_seqval / NULLIF(sbra, 0) AS rtse", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "WHERE sbra IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Content Interaction Efficiency (CIE)", "sql_snippet": "AVG(i.seqval) OVER(PARTITION BY s.seshkey) AS avg_seqval", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "news_4", "selected_database": "news", "amb_user_query": "For each combination of subscription status and demographic traits, I want to examine how users differ in terms of their User Subscription Value (USV) and User Demographic Score (UDS). Only include segments with enough users, and show me the group's subscription type, demographic traits, average scores, and the shared interests as a comma-separated list. Return the top groups, and break ties using average UDS.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "demographic traits", "sql_snippet": "SELECT userkey, typelabel, substatus, subdays, ageval, gendlbl, occulbl", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "average scores", "sql_snippet": "ROUND(AVG(ds.usv_score), 2) AS avg_subscription_value, ROUND(AVG(ds.uds_score), 2) AS avg_demographic_score, ROUND(AVG(ui.satisfaction_score), 2) AS avg_satisfaction", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "enough users", "sql_snippet": "HAVING COUNT(*) > 10", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY avg_subscription_value DESC, avg_demographic_score DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE e IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "news_5", "selected_database": "news", "amb_user_query": "I want to monitor system responsiveness and detect potential slowdowns. For every system performance record with relatively high response times, show me the trace ID, actual response time, load score, performance score, a computed performance delta, the rank of that response time among all alerts, and category.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "category", "sql_snippet": "CASE WHEN resptime > 200 THEN 'Critical' WHEN resptime > 150 THEN 'Warning' ELSE 'Normal' END AS performance_status", "is_mask": true, "type": "intent_ambiguity"}, {"term": "relatively high response times", "sql_snippet": "WHERE sp.resptime > 100", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "system responsiveness", "sql_snippet": "(sp.perfscore - sp.loadscore) AS performance_delta", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY sp.resptime DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "System Performance Index (SPI)", "sql_snippet": "(sp.perfscore - sp.loadscore) AS performance_delta", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "news_6", "selected_database": "news", "amb_user_query": "I need to analyze session using the Session Bounce Rate Adjustment (SBRA) concept to understand relationships between bounce rates and click-through rates. For each combination of user type and segment and performance category, show them with their related information. Only include segments with sufficient sessions.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "sufficient sessions", "sql_snippet": "HAVING COUNT(*) > 10", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "related information.", "sql_snippet": "ROUND(CAST(AVG(bncrate) AS REAL), 2) AS avg_bounce_rate, ROUND(CAST(AVG(adjusted_bounce_rate) AS REAL), 2) AS avg_adjusted_bounce_rate, ROUND(CAST(AVG(ctrval) AS REAL), 2) AS avg_ctr, ROUND(CAST(AVG(engscore) AS REAL), 2) AS avg_engagement_score, ROUND(CAST(AVG(seshdur) AS REAL), 2) AS avg_session_duration, ROUND(CAST(AVG(seshviews) AS REAL), 2) AS avg_page_views", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY CASE WHEN avg_adjusted_bounce_rate IS NULL THEN 1 ELSE 0 END, avg_adjusted_bounce_rate, CASE WHEN avg_ctr IS NULL THEN 0 ELSE 1 END, avg_ctr DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Performance Segment", "sql_snippet": "CASE WHEN bounce_percentile < 0.25 AND ctr_percentile < 0.25 THEN 'High Bounce, Low CTR' WHEN bounce_percentile < 0.25 AND ctr_percentile >= 0.75 THEN 'High Bounce, High CTR' WHEN bounce_percentile >= 0.75 AND ctr_percentile < 0.25 THEN 'Low Bounce, Low CTR' WHEN bounce_percentile >= 0.75 AND ctr_percentile >= 0.75 THEN 'Low Bounce, High CTR' ELSE 'Average Performance' END AS performance_segment", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 54}]}
{"instance_id": "news_7", "selected_database": "news", "amb_user_query": "To analyze user registrations by month and experimental groups, please output the registration month, A/B test group, total registrations per group and the percentage each group represents within its time bucket. Sort results to track cohort distribution over time.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "experimental groups", "sql_snippet": "GROUP BY strftime('%Y-%m', regmoment), testgrp", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "time bucket", "sql_snippet": "strftime('%Y-%m-01', regmoment) AS registration_month", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY registration_month, testgrp", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "news_8", "selected_database": "news", "amb_user_query": "I want to see how article complexity impacts Engagement Rate across categories. Show the article category, average readability score, average engagement rate, a measure of how strongly the two are related and count the number of articles based on complexity level.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "article complexity", "sql_snippet": "CASE difflevel WHEN 'Basic' THEN 1 WHEN 'Intermediate' THEN 1.5 WHEN 'Advanced' THEN 2 ELSE 1.2 END AS ars", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "measure of how strongly the two are related", "sql_snippet": "(cd.n * cd.sum_ars_engagement - cd.sum_ars * cd.sum_engagement) / SQRT((cd.n * cd.sum_ars_squared - cd.sum_ars * cd.sum_ars) * (cd.n * cd.sum_engagement_squared - cd.sum_engagement * cd.sum_engagement)) AS readability_engagement_corr", "is_mask": false, "type": "intent_ambiguity"}, {"term": "complexity level", "sql_snippet": "SUM(CASE WHEN ars < 50 THEN 1 ELSE 0 END) AS low_readability, SUM(CASE WHEN ars BETWEEN 50 AND 100 THEN 1 ELSE 0 END) AS medium_readability, SUM(CASE WHEN ars > 100 THEN 1 ELSE 0 END) AS high_readability", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Readability Segmentation", "sql_snippet": "SUM(CASE WHEN ars < 50 THEN 1 ELSE 0 END) AS low_readability, SUM(CASE WHEN ars BETWEEN 50 AND 100 THEN 1 ELSE 0 END) AS medium_readability, SUM(CASE WHEN ars > 100 THEN 1 ELSE 0 END) AS high_readability", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 57}]}
{"instance_id": "news_9", "selected_database": "news", "amb_user_query": "I want to understand how the recommendation position influences user clicks. Could you return the position, total num, total clicks, and recommendation click-through rate for each position? Sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "total num", "sql_snippet": "COUNT(*) AS recommendations", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY posval IS NULL, posval", "is_mask": false, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN interactions AS i ON r.reckey = i.reclink", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Recommendation Click-Through Rate (RCTR)", "sql_snippet": "CAST(COUNT(*) FILTER(WHERE i.evttype = 'click') AS REAL) / NULLIF(COUNT(*), 0)", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 58}]}
{"instance_id": "news_10", "selected_database": "news", "amb_user_query": "Help me rank users based on their a custom interaction score, which considers session clicks, views, and engagement score to highlight the most active users. Display the top users, their clicks, views, engagement score, and custom interaction score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "custom interaction score", "sql_snippet": "(seshclicks + seshviews) * (engscore / 100.0) AS euim", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "most active users", "sql_snippet": "ORDER BY euim DESC NULLS FIRST\nLIMIT 10", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "descending order", "sql_snippet": "ORDER BY euim DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "crypto_1", "selected_database": "crypto", "amb_user_query": "Could you calculate the price gap percentage for a most recent market snapshot. Show me the exchange code of the most recent market snapshot with the timestamp of the snapshot, and the calculated percentage?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "price gap percentage", "sql_snippet": "((askquote - bidquote) / midquote * 100) AS spread_percentage", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY marketdatanode DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "crypto_2", "selected_database": "crypto", "amb_user_query": "For each order, calculate the completion rate for orders based on their some recent executions. Display the order ID, total order quantity, remaining quantity, and the calculated order fill rate.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "completion rate", "sql_snippet": "((o.dealcount - le.remaincount) * 100.0 / o.dealcount) AS order_fill_rate", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "some recent executions", "sql_snippet": "WITH latest_exec AS (SELECT ordersmark, remaincount, ROW_NUMBER() OVER (PARTITION BY ordersmark ORDER BY orderexecmark DESC) AS rn FROM orderexecutions)", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY orderexecmark DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "crypto_3", "selected_database": "crypto", "amb_user_query": "Calculate the Position Value at Risk (PVaR) for the top few positions, using their value and margin data and the current market volatility. Show me the risk and margin pivot, the position's notional value, the volatility measure used, and the calculated PVaR.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "top few positions", "sql_snippet": "ORDER BY riskandmarginpivot DESC LIMIT 5", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "value", "sql_snippet": "json_extract(risk_margin_profile, '$.position.possum') AS possum", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "current market volatility", "sql_snippet": "FROM marketstats ORDER BY marketstatsmark DESC LIMIT 1", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY riskandmarginpivot DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "FROM position p CROSS JOIN vol", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Position Value at Risk (PVaR)", "sql_snippet": "(p.possum * vol.volmeter * 0.01) AS PVaR", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "crypto_4", "selected_database": "crypto", "amb_user_query": "Please display the risk profile ID, the related order, the account balance ID, the margin requirement, the margin balance, and the margin usage.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "risk profile ID", "sql_snippet": "SELECT r.riskandmarginpivot", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "related order", "sql_snippet": "SELECT o.recordvault", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "margin requirement", "sql_snippet": "CAST(json_extract(r.risk_margin_profile, '$.margin_thresholds.inithold') AS REAL) AS inithold", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "margin usage", "sql_snippet": "(CAST(json_extract(r.risk_margin_profile, '$.margin_thresholds.inithold') AS REAL) / CAST(ab.margsum AS REAL) * 100) AS margin_utilization", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": []}
{"instance_id": "crypto_5", "selected_database": "crypto", "amb_user_query": "Can you calculate the profit ratio based on the realized PnL across all account balances? Display relevant indicators for this ratio, and the profit ratio.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "relevant indicators", "sql_snippet": "SELECT sum_positive, sum_negative", "is_mask": true, "type": "intent_ambiguity"}, {"term": "profit ratio", "sql_snippet": "CASE WHEN sum_negative = 0 THEN NULL ELSE sum_positive / ABS(sum_negative) END AS profit_factor", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "CASE WHEN sum_negative = 0 THEN NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Profit Factor", "sql_snippet": "CASE WHEN sum_negative = 0 THEN NULL ELSE sum_positive / ABS(sum_negative) END AS profit_factor", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 34}]}
{"instance_id": "crypto_6", "selected_database": "crypto", "amb_user_query": "Analyze the spread across different markets and correlate it with market mood indicators. For each market pair, display the market pair name, the calculated spread percentage, the overall market mood, the buy force, the average spread percentage for that mood, and the percentile ranking of the spread.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "spread", "sql_snippet": "(CAST((quote_depth_snapshot -> '$.quotes' ->> '$.askquote') AS REAL) - CAST((quote_depth_snapshot -> '$.quotes' ->> '$.bidquote') AS REAL)) / CAST((quote_depth_snapshot -> '$.quotes' ->> '$.midquote') AS REAL) * 100 AS spread_pct", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "mood", "sql_snippet": "json_extract(market_sentiment_indicators, '$.momentum.mktfeel') AS sentiment", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY s.spread_pct DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "crypto_7", "selected_database": "crypto", "amb_user_query": "I want to understand the impact of smart trading on price shifts across different market pairs. Can you provide the flow category, the level of 'Whale-Driven Market' activity, the average price change over 1 hour, 4 hours, and 24 hours for different market pairs and calculate the smart trading success rate. Please group the results by flow category, big trader activity, and market pair, and sort them by success rate.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "smart trading", "sql_snippet": "CAST(json_extract(json_extract(a.market_sentiment_indicators, '$.flow'), '$.smartforce') AS REAL) AS smart_force", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "price shifts", "sql_snippet": "AVG(next_price_1h - mid_price) AS avg_1h_change", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "flow category", "sql_snippet": "CASE WHEN smart_force > retail_flow * 1.2 AND smart_force > inst_flow * 1.2 THEN 'Smart Money Dominant' WHEN retail_flow > smart_force * 1.2 AND retail_flow > inst_flow * 1.2 THEN 'Retail Dominant' WHEN inst_flow > smart_force * 1.2 AND inst_flow > retail_flow * 1.2 THEN 'Institutional Dominant' ELSE 'Mixed' END AS flow_dominance", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "success rate", "sql_snippet": "CAST(SUM(CASE WHEN (smart_force > retail_flow AND smart_force > inst_flow AND next_price_4h > mid_price) OR ... THEN 1 ELSE 0 END) AS REAL) / COUNT(*) AS smart_money_accuracy", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY smart_money_accuracy DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE next_price_24h IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Flow Dominance", "sql_snippet": "CASE WHEN smart_force > retail_flow * 1.2 AND smart_force > inst_flow * 1.2 THEN 'Smart Money Dominant' WHEN retail_flow > smart_force * 1.2 AND retail_flow > inst_flow * 1.2 THEN 'Retail Dominant' WHEN inst_flow > smart_force * 1.2 AND inst_flow > retail_flow * 1.2 THEN 'Institutional Dominant' ELSE 'Mixed' END AS flow_dominance", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 50}]}
{"instance_id": "crypto_8", "selected_database": "crypto", "amb_user_query": "To analyze the leverage for positions, please provide the risk/margin record ID, position value, position leverage multiplier, the account balance, and the resulting leverage ratio for each relevant position.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "leverage", "sql_snippet": "posmagn * ( possum / CAST(ab.walletsum AS REAL) ) AS effective_leverage", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "position value", "sql_snippet": "CAST(json_extract(r.risk_margin_profile, '$.position.possum') AS REAL) AS possum", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "account balance", "sql_snippet": "CAST(ab.walletsum AS REAL)", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": []}
{"instance_id": "crypto_9", "selected_database": "crypto", "amb_user_query": "I want to determine the Signal Strength in the market. Please provide the relevant technical value, Bollinger Band width, the technical meter direction, and the calculated technical signal strength.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Signal Strength", "sql_snippet": "((ABS(rsi14spot - 50) + ABS(macdtrail) + (bbandspan * 0.01)) / 3) * CASE WHEN techmeter = 'Buy' THEN 1 WHEN techmeter = 'Sell' THEN -1 ELSE 0 END AS technical_signal_strength", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "relevant technical value", "sql_snippet": "SELECT rsi14spot,\n  macdtrail,\n  bbandspan,\n  techmeter", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": []}
{"instance_id": "crypto_10", "selected_database": "crypto", "amb_user_query": "Based on the latest market-depth snapshot data, i.e. the one with maximum market stats id, help me identify significant trades, incleding the order reference, the trade side, the order quantity, and market depth details for these orders.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "significant trades", "sql_snippet": "WHERE (\n  (o.dealedge = 'Sell' AND o.dealcount > 0.1 * CAST(json_extract(md.quote_depth_snapshot, '$.depth.bidunits') AS REAL)) OR\n  (o.dealedge = 'Buy' AND o.dealcount > 0.1 * CAST(json_extract(md.quote_depth_snapshot, '$.depth.askunits') AS REAL))\n)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "order reference", "sql_snippet": "SELECT o.orderspivot", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Whale Order", "sql_snippet": "WHERE ((o.dealedge = 'Sell' AND o.dealcount > 0.1 * CAST(json_extract(md.quote_depth_snapshot, '$.depth.bidunits') AS REAL)) OR (o.dealedge = 'Buy' AND o.dealcount > 0.1 * CAST(json_extract(md.quote_depth_snapshot, '$.depth.askunits') AS REAL)))", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 10}]}
{"instance_id": "insider_1", "selected_database": "insider", "amb_user_query": "Can you generate a list of trader IDs who are in the high-risk trading group? From that group, please only include those who have also faced a Significant Enforcement Action where the related compliance case was last reviewed recently. Just provide the traders' information.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high-risk trading group", "sql_snippet": "WHERE (tle > 5.0 AND risk_level_text = 'Aggressive') OR dtr > 0.5", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "recently", "sql_snippet": "cc.lastrevdt >= date('now', '-1 year')", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "traders' information", "sql_snippet": "SELECT hrp.tradereg", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "different", "sql_snippet": "SELECT DISTINCT tr.trdref AS tradereg", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY hrp.tradereg", "is_mask": false, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN RecentSignificantEnforcements rse ON hrp.tradereg = rse.tradereg", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "insider_2", "selected_database": "insider", "amb_user_query": "Please identify transaction records of any likely insider trades. For these specific flagged transactions, calculate their Sentiment-Driven Leakage Risk score, and for those with a pretty high score, please show their IDs, transaction timestamp, the original information leakage score, and the calculated SDLR score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "likely insider trades", "sql_snippet": "infoleaksc > 50.0 AND corpeventprx IS NOT NULL AND eventannotm IN ('Pre-market', 'Intraday')", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "pretty high", "sql_snippet": "WHERE sdlr > 1000", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "IDs", "sql_snippet": "SELECT transreg, trdref", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(cr.swov * cr.infoleaksc, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN sentimentandfundamentals AS sf ON tr.transreg = sf.transref", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "WHERE infoleaksc > 50.0 AND NOT corpeventprx IS NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Sentiment Divergence Factor (SDF)", "sql_snippet": "ABS(ift.newsscore - ift.socscore) AS sdf", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 7}, {"term": "Potential Insider Trading Flag", "sql_snippet": "SELECT transreg, trdref, transtime, infoleaksc, optvolrt, newsscore, socscore FROM TransactionSentiment WHERE infoleaksc > 50.0 AND NOT corpeventprx IS NULL AND eventannotm IN ('Pre-market', 'Intraday')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 11}, {"term": "Sentiment-Weighted Option Volume (SWOV)", "sql_snippet": "ift.optvolrt * (1 + ABS(ift.newsscore - ift.socscore)) AS swov", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 34}]}
{"instance_id": "insider_3", "selected_database": "insider", "amb_user_query": "I need an analysis comparing different types of traders. For each trader type, please calculate the average trading-intensity score and the average compliance-wellness score. Display the trader type, the calculated average ATI, and the average CHS. Finally, sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "trading-intensity score", "sql_snippet": "(tm.dtr * tm.tle * COALESCE(tam.avg_omi, 0)) AS ati", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "compliance-wellness score", "sql_snippet": "1.0 / (1.0 + COALESCE(cm.avg_crs, 0) * COALESCE(cm.avg_comprate_value, 1)) AS chs", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(ati), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN TransactionAvgMetrics tam ON tm.tradereg = tam.trdref", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(tam.avg_omi, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Order Modification Intensity (OMI)", "sql_snippet": "AVG(modfreq / NULLIF(1 - cancelpct, 0)) AS avg_omi", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}, {"term": "Aggressive Trading Intensity (ATI)", "sql_snippet": "(tm.dtr * tm.tle * COALESCE(tam.avg_omi, 0)) AS ati", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 36}]}
{"instance_id": "insider_4", "selected_database": "insider", "amb_user_query": "Please identify all compliance cases associated with traders showing network mimic risk. For each of these specific cases, calculate the Investigation Index. List the compliance cases' details. Finally, sort the results and show only the top cases.  ", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Investigation Index", "sql_snippet": "ROUND(( 0.6 * idet.behansc ) + ( 0.4 * idet.netansc ), 2) AS iii", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "details", "sql_snippet": "SELECT compreg, iii", "is_mask": false, "type": "intent_ambiguity"}, {"term": "top cases", "sql_snippet": "ORDER BY iii IS NULL DESC, iii DESC LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(( 0.6 * idet.behansc ) + ( 0.4 * idet.netansc ), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "different", "sql_snippet": "SELECT DISTINCT tr.trdref AS tradereg", "is_mask": false, "type": "distinct_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Pattern Anomaly Score (PAS)", "sql_snippet": "ABS(ab.patsim - ab.peercorr) < 0.1", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "insider_5", "selected_database": "insider", "amb_user_query": "First, identify all traders who qualify as risky manipulation candidates. Then, for this specific group of traders, calculate the average Pattern Deviation Ratio based on their transaction history. Please provide only this mean value.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "risky manipulation candidates", "sql_snippet": "SELECT hrt.tradereg FROM HighRiskTraders hrt\nINTERSECT\nSELECT mpt.tradereg FROM ManipulationPatternTraders mpt", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "mean", "sql_snippet": "AVG(abm.avg_pas / MAX(0.01, abm.avg_patsim))", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(abm.avg_pas / MAX(0.01, abm.avg_patsim)), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "different", "sql_snippet": "SELECT DISTINCT tr.trdref AS tradereg", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "IFNULL(omi_calc.omi, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Unique Pattern Deviation Ratio", "sql_snippet": "ROUND(AVG(abm.avg_pas / MAX(0.01, abm.avg_patsim)), 2) AS average_updr_for_high_risk_manipulators", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 52}, {"term": "High-Risk Manipulator Candidate", "sql_snippet": "SELECT hrt.tradereg FROM HighRiskTraders hrt\nINTERSECT\nSELECT mpt.tradereg FROM ManipulationPatternTraders mpt", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 60}, {"term": "High-Risk Trader Profile", "sql_snippet": "WHERE tle > 5.0 AND risk_level_text = 'Aggressive' OR dtr > 0.5", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 10}, {"term": "Order Modification Intensity", "sql_snippet": "tr.modfreq / IIF(1 - tr.cancelpct = 0, NULL, 1 - tr.cancelpct) AS omi", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "insider_6", "selected_database": "insider", "amb_user_query": "I want to analyze the enforcement outcomes specifically for cases flagged as most intense insider probes. Could you provide a frequency count for each type of Penalty Imposed that resulted from these investigations? Please list their information in order.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "intense insider probes", "sql_snippet": "sf.infoleaksc > 50.0 AND NOT sf.corpeventprx IS NULL AND sf.eventannotm IN ('Pre-market', 'Intraday') AND ( ( 0.6 * idet.behansc ) + ( 0.4 * idet.netansc ) ) > 70", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "information", "sql_snippet": "SELECT hiii.invdetreg, ea.penimp", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY CASE WHEN frequency IS NULL THEN 0 ELSE 1 END, frequency DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE sf.infoleaksc > 50.0 AND sf.corpeventprx IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "High-Intensity Insider Investigation", "sql_snippet": "WHERE sf.infoleaksc > 50.0 AND sf.corpeventprx IS NOT NULL AND sf.eventannotm IN ('Pre-market', 'Intraday') AND ((0.6 * idet.behansc) + (0.4 * idet.netansc)) > 70", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 67}]}
{"instance_id": "insider_7", "selected_database": "insider", "amb_user_query": "I want to compare the performance of traders suspected of peer copycatting versus other traders. Please calculate the average Risk-Adjusted Win Rate for these two groups. Display the group bool value, and the corresponding average RAWR for that group.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "peer copycatting", "sql_snippet": "ABS(ab.patsim - ab.peercorr) < 0.1 AND ab.peercorr > 0.7", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "group bool value", "sql_snippet": "COALESCE(pmf.is_mimicry_suspect, FALSE) AS is_mimicry_suspect_group", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(rc.rawr), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN PeerMimicryFlags pmf ON rc.tradereg = pmf.tradereg", "is_mask": false, "type": "join_ambiguity"}, {"term": "different", "sql_snippet": "SELECT DISTINCT tr.trdref as tradereg", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(pmf.is_mimicry_suspect, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Risk-Adjusted Win Rate (RAWR)", "sql_snippet": "winpct / tle_floor1 AS rawr", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 59}]}
{"instance_id": "insider_8", "selected_database": "insider", "amb_user_query": "I need to analyze the order change pressure of a specific trader group. Please identify all traders classified as volatile event-driven fast movers. Then, calculate the average Order Modification Intensity. Provide just the calculated average OMI.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "volatile event-driven fast movers", "sql_snippet": "JOIN VolatileSpeculators AS vs ON tr.trdref = vs.tradereg", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "order change pressure", "sql_snippet": "tr.modfreq / NULLIF(1 - tr.cancelpct, 0) AS omi", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(omi), 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "null", "sql_snippet": "CASE WHEN sf.corpeventprx IS NOT NULL THEN 1 ELSE 0 END", "is_mask": false, "type": "null_ambiguity"}, {"term": "different", "sql_snippet": "SELECT DISTINCT tr.trdref AS tradereg", "is_mask": false, "type": "distinct_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Order Modification Intensity", "sql_snippet": "tr.modfreq / NULLIF(1 - tr.cancelpct, 0) AS omi", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "insider_9", "selected_database": "insider", "amb_user_query": "I need a list detailing the specific restriction period tag applied in enforcement actions that have been identified as pricey high-frequency risk cases. Please provide the enforcement registration information and the corresponding restriction period tag for each such case.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "pricey high-frequency risk case", "sql_snippet": "WHERE is_significant_action = 1 AND efir > 0", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "restriction period tag", "sql_snippet": "SELECT ea.traderestr", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "registration information", "sql_snippet": "SELECT enforcereg", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Enforcement Financial Impact Ratio", "sql_snippet": "ea.penamt / NULLIF(hfhrt.acctbal, 0) AS efir", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "insider_10", "selected_database": "insider", "amb_user_query": "I need to compare the average Aggressive Suspicion Score between transactions where layering is 'Confirmed' and those where it is 'Suspected'. Please calculate the average ASS for each of these two groups. Display the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "aggressive risk score", "sql_snippet": "( cs.sai * cs.ati ) AS ass", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "results", "sql_snippet": "FROM ASS_Calculation GROUP BY layer_indicator", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(ass), 3)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Aggressive Suspicion Score (ASS)", "sql_snippet": "( cs.sai * cs.ati ) AS ass", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 54}, {"term": "Aggressive Trading Intensity", "sql_snippet": "( tbm.dtr * tbm.tle * tbm.omi ) AS ati", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 36}]}
{"instance_id": "vaccine_1", "selected_database": "vaccine", "amb_user_query": "Show me the health status of all vaccine storage containers, including their ID, stability score, maximum Temperature Breach Severity, and overall status for vaccine storage containers recently. Round the scores, and limit to 100 containers.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "stability score", "sql_snippet": "COALESCE(AVG((1 - COALESCE(CAST(s.TempDevCount AS REAL) / 100, 0)) * (1 - COALESCE(CAST(s.CritEvents AS REAL) / 10, 0)) * COALESCE(s.TempStabIdx, 1)), 1.0) AS avg_TSS", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "overall status", "sql_snippet": "CASE WHEN MAX(s.tempbreachscore) > 0.6 OR s.tempstabidx < 0.4 THEN 'Critical' WHEN AVG(s.tempstabidx) < 0.4 OR MAX(s.tempbreachscore) > 1.5 THEN 'Unstable' WHEN AVG(s.tempstabidx) >= 0.7 AND MAX(s.tempbreachscore) <= 1.0 THEN 'Stable' ELSE 'Moderate' END AS container_health_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "recently", "sql_snippet": "s.AlertTime >= (SELECT datetime(MAX(AlertTime), '-1 year') FROM SensorData)", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(avg_TSS, 2) AS avg_TSS,\nROUND(max_TBS, 2) AS max_TBS", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "FROM container AS c LEFT JOIN sensordata AS s ON c.containregistry = s.containlink", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(AVG(TSS), 1.0) AS avg_TSS, COALESCE(MAX(TBS), 0.0) AS max_TBS", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Temperature Stability Score (TSS)", "sql_snippet": "COALESCE(AVG((1 - COALESCE(CAST(s.TempDevCount AS REAL) / 100, 0)) * (1 - COALESCE(CAST(s.CritEvents AS REAL) / 10, 0)) * COALESCE(s.TempStabIdx, 1)), 1.0) AS avg_TSS", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 0}, {"term": "Container Health Status", "sql_snippet": "CASE WHEN MAX(CASE WHEN s.alertkind = 'CRI' THEN s.tempstabidx ELSE 0 END) > 0.6 OR MIN(CASE WHEN s.alertkind = 'TSS' THEN s.tempstabidx ELSE NULL END) < 0.4 THEN 'Critical' WHEN AVG(CASE WHEN s.alertkind = 'TSS' THEN s.tempstabidx ELSE NULL END) < 0.4 OR MAX(CASE WHEN s.alertkind = 'TBS' THEN s.tempstabidx ELSE 0 END) > 1.5 THEN 'Unstable' WHEN AVG(CASE WHEN s.alertkind = 'TSS' THEN s.tempstabidx ELSE NULL END) >= 0.7 AND MAX(CASE WHEN s.alertkind = 'TBS' THEN s.tempstabidx ELSE 0 END) <= 1.0 THEN 'Stable' ELSE 'Moderate' END AS container_health_status", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 10}]}
{"instance_id": "vaccine_2", "selected_database": "vaccine", "amb_user_query": "List the top 10 critical vaccine containers, sorted by risk level from highest to lowest. Display each container's ID, maximum Temperature Stability Score and Container Risk Index, Risk Rank, and sensor data status. Include a diagnostic JSON summary containing the maximum temperature deviation count, maximum critical events, maximum temperature stability index, current coolant percentage remaining, and maximum temperature breach severity (use field names 'TempDevCount', 'CritEvents', 'TempStabIdx', 'CoolRemainPct', 'TempBreachSeverity'). Include all containers in the evaluation.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "sorted by risk level", "sql_snippet": "ORDER BY (1 - COALESCE(MAX(sm.TSS), 1.0)) * (1 - COALESCE(c.coolremainpct, 0) / 100) DESC", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "sensor data status", "sql_snippet": "CASE WHEN s.sensortrack IS NULL THEN 'No Sensor Data' ELSE 'Sensor Data Available' END AS SensorDataStatus", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY (1 - COALESCE(MAX(sm.TSS), 1.0)) * (1 - COALESCE(c.coolremainpct, 0) / 100) DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(CAST(TSS AS REAL), 3)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(c.coolremainpct, 0) / 100)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Temperature Stability Score (TSS)", "sql_snippet": "COALESCE(MAX(sm.TSS), 1.0) AS TSS", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 0}, {"term": "Container Health Status", "sql_snippet": "FROM RiskIndex WHERE CRI > 0.6 OR TSS < 0.4", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 10}]}
{"instance_id": "vaccine_3", "selected_database": "vaccine", "amb_user_query": "For each transport route in the vaccine database, identify risky routes. For each vehicle, show the vehicle ID, shipment ID, Completion Percentage, maximum Container Risk Index, distance in kilometers, maximum temperature deviation count, maximum critical events, maximum temperature stability index, and maximum coolant remaining percentage. Sort by maximum Container Risk Index and limit to some results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "risky routes", "sql_snippet": "WHERE rp.RCP < 50 GROUP BY rp.VehicleReg, rp.ShipTransit, rp.RCP, rp.DistDoneKm, rp.DistLeftKm HAVING MAX(cr.CRI) > 0.4 OR MAX(cr.CRI) IS NULL", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "distance in kilometers", "sql_snippet": "rp.DistDoneKm AS dist_done_km, rp.DistLeftKm AS dist_left_km", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "some results", "sql_snippet": "LIMIT 10", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "join", "sql_snippet": "LEFT JOIN ContainerRisk AS cr ON rp.ShipTransit = cr.ShipOwn", "is_mask": false, "type": "join_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(CAST(rp.RCP AS REAL), 3)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "null", "sql_snippet": "FROM Container AS c LEFT JOIN SensorData AS s ON c.ContainRegistry = s.ContainLink WHERE NOT c.ShipOwn IS NULL OR NOT s.ContainLink IS NULL\nUNION\nSELECT c.ContainRegistry, c.ShipOwn, c.CoolRemainPct, ( 1 - ( ( 1 - COALESCE(CAST(s.TempDevCount AS REAL) / 100, 0) ) * ( 1 - COALESCE(CAST(s.CritEvents AS REAL) / 10, 0) ) * COALESCE(s.TempStabIdx, 1) ) ) * ( 1 - COALESCE(c.CoolRemainPct, 0) / 100 ) AS CRI, s.TempDevCount, s.CritEvents, s.TempStabIdx FROM Container AS c RIGHT JOIN SensorData AS s ON c.ContainRegistry = s.ContainLink WHERE NOT c.ShipOwn IS NULL OR NOT s.ContainLink IS NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY MAX(cr.CRI) IS NULL DESC, MAX(cr.CRI) DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Route Completion Percentage (RCP)", "sql_snippet": "(t.DistDoneKm / NULLIF(t.DistDoneKm + t.DistLeftKm, 0)) * 100 AS RCP", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "vaccine_4", "selected_database": "vaccine", "amb_user_query": "Show me all flagged shipments, listing their shipment ID, status, number of incidents, and maintenance record IDs as an array. Only include shipments that are compromised, sort them by incident count, and limit to a number of results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "flagged shipments", "sql_snippet": "s.IntegrityMark = 'Compromised' OR s.SealFlag = 'Broken' OR s.TamperSign = 'Confirmed'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "status", "sql_snippet": "CASE WHEN s.IntegrityMark = 'Compromised' OR s.SealFlag = 'Broken' OR s.TamperSign = 'Confirmed' THEN 'Compromised' ELSE 'Safe' END AS risk_status", "is_mask": true, "type": "schema_linking_ambiguity"}, {"term": "a number of results", "sql_snippet": "LIMIT 50", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "COALESCE(rm.Incidents, 0) AS incident_count", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN RegulatoryAndMaintenance rm ON sr.ShipmentRegistry = rm.ShipGov WHERE risk_status = 'Compromised'", "is_mask": false, "type": "join_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY incident_count DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "vaccine_5", "selected_database": "vaccine", "amb_user_query": "For each transport, I want to identify reliable transports. Please list the vehicle ID, shipment ID, Handling Quality Index and Temperature Stability Score rounded to decimal places, based on the recent sensor reading. Sort by TSS.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "reliable transports", "sql_snippet": "WHERE HQI > 0.9 AND TSS > 0.8", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "the recent sensor reading", "sql_snippet": "ORDER BY s.AlertTime DESC LIMIT 1", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "COALESCE(CAST(s.CritEvents AS REAL) / 10, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN SensorData s ON t.vehiclereg = s.VehSenseRef WHERE s.sensortrack IN (SELECT sensortrack FROM SensorData WHERE VehSenseRef = t.vehiclereg ORDER BY AlertTime DESC LIMIT 1)", "is_mask": false, "type": "join_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY TSS DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(HQI, 3)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Handling Quality Index (HQI)", "sql_snippet": "(1 - COALESCE(CAST(s.HandleEvents AS REAL) / 100, 0)) * (1 - COALESCE(CAST(s.CritEvents AS REAL) / 10, 0)) AS HQI", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 8}]}
{"instance_id": "vaccine_6", "selected_database": "vaccine", "amb_user_query": "For each container, I want to identify those with a critical temperature condition. Please list the container ID, Temperature Breach Severity, number of temperature deviations, and an array of alert types for each sensor reading. Show the top 5.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "critical temperature condition", "sql_snippet": "WHERE CAST(ABS(s.TempNowC - s.StoreTempC) AS REAL) / NULLIF(s.TempTolC, 0) * s.TempDevCount > 2.0 AND s.TempDevCount > 5", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "the top 5", "sql_snippet": "ORDER BY TBS DESC LIMIT 5", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "WHERE s.AlertKind IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN SensorData s", "is_mask": false, "type": "join_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY TBS DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Temperature Breach Severity (TBS)", "sql_snippet": "CAST(ABS(s.TempNowC - s.StoreTempC) AS REAL) / NULLIF(s.TempTolC, 0) * s.TempDevCount AS TBS", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "vaccine_7", "selected_database": "vaccine", "amb_user_query": "For each container, I want to identify those with a critical coolant condition. Please list the container ID, coolant remaining percentage, Coolant Depletion Rate, and Depletion Rank based on CDR. List the top 5.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "critical coolant condition", "sql_snippet": "WHERE CDR > 1.0 AND CoolRemainPct < 30", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "List the top 5", "sql_snippet": "ORDER BY DepletionRank LIMIT 5", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "null", "sql_snippet": "WHERE c.RefillLatest IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY DepletionRank", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(CDR, 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Coolant Depletion Rate (CDR)", "sql_snippet": "(100.0 - c.CoolRemainPct) / NULLIF(julianday('now') - julianday(c.RefillLatest), 0) AS CDR", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "vaccine_8", "selected_database": "vaccine", "amb_user_query": "For each container, I want to identify those with high efficiency. Please list the container ID, efficiency score, temperature stability, and rank. Sort by rank and limit to top 5.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high efficiency", "sql_snippet": "WHERE SER > 0.8 AND TSS > 0.9", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "efficiency score", "sql_snippet": "CAST(( v.VialTally * 10 ) AS REAL) / NULLIF(c.VolLiters, 0) AS SER", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "temperature stability", "sql_snippet": "(1 - COALESCE(CAST(s.TempDevCount AS REAL) / 100, 0)) * (1 - COALESCE(CAST(s.CritEvents AS REAL) / 10, 0)) * COALESCE(s.TempStabIdx, 1) AS TSS,", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "rank", "sql_snippet": "ROW_NUMBER() OVER (ORDER BY CAST(( v.VialTally * 10 ) AS REAL) / NULLIF(c.VolLiters, 0) DESC) AS EfficiencyRank", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(SER AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY EfficiencyRank NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(CAST(s.TempDevCount AS REAL) / 100, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN VaccineDetails AS v ON c.ContainRegistry = v.ContainVac\nUNION ALL\nSELECT v.ContainVac AS ContainRegistry, CAST(( v.VialTally * 10 ) AS REAL) / NULLIF(c.VolLiters, 0) AS SER, ( 1 - COALESCE(CAST(s.TempDevCount AS REAL) / 100, 0) ) * ( 1 - COALESCE(CAST(s.CritEvents AS REAL) / 10, 0) ) * COALESCE(s.TempStabIdx, 1) AS TSS, ROW_NUMBER() OVER (ORDER BY CAST(( v.VialTally * 10 ) AS REAL) / NULLIF(c.VolLiters, 0) DESC) AS EfficiencyRank FROM VaccineDetails AS v LEFT JOIN Container AS c ON v.ContainVac = c.ContainRegistry INNER JOIN SensorData AS s ON c.ContainRegistry = s.ContainLink WHERE c.ContainRegistry IS NULL", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Temperature Stability Score (TSS)", "sql_snippet": "COALESCE(s.TempStabIdx, 1) AS TSS", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "vaccine_9", "selected_database": "vaccine", "amb_user_query": "List 5 equipments past due for maintenance in the vaccine database. For each, show the equipment ID, compliance score, delay, and confirm its overdue. Sort by delay from longest to shortest, including only equipment with valid scores.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "past due", "sql_snippet": "WHERE MCS < 0.7 AND (date('now') > MaintDateNext OR date('now') > CalibDateNext)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "equipment", "sql_snippet": "FROM RegulatoryAndMaintenance rm", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "compliance score", "sql_snippet": "COALESCE(rm.CompScore * (1 - COALESCE(rm.Incidents, 0) / 10.0), 0) AS MCS", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "delay", "sql_snippet": "MAX((JULIANDAY(date('now')) - JULIANDAY(MaintDateNext)), (JULIANDAY(date('now')) - JULIANDAY(CalibDateNext)), 0) AS days_overdue", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(MCS, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY days_overdue DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(rm.Incidents, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Maintenance Compliance Score (MCS)", "sql_snippet": "COALESCE(rm.CompScore * (1 - COALESCE(rm.Incidents, 0) / 10.0), 0) AS MCS", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "vaccine_10", "selected_database": "vaccine", "amb_user_query": "Show me the top 10 transport types with the most reliable transport over the recent period. For each mode, list the mode name, average handling quality, vehicles involved in Stable Transport, and the count of reliable instances. Sort by handling quality.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "reliable transport", "sql_snippet": "WHERE HQI > 0.9 AND TSS > 0.8", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "recent period", "sql_snippet": "WHERE s.AlertTime >= date('now', '-3 months')", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(HQI), 3)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY avg_hqi DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(s.HandleEvents / 100.0, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Handling Quality Index (HQI)", "sql_snippet": "(1.0 - COALESCE(s.HandleEvents / 100.0, 0)) * (1.0 - COALESCE(s.CritEvents / 10.0, 0)) AS HQI", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 8}]}
{"instance_id": "robot_1", "selected_database": "robot", "amb_user_query": "Identify robots with a high safety issue and a High Fault Risk based on their latest maintenance record. List the robot ID, Safety Incident Score, and the recent fault prediction score. Show the top results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "high safety issue", "sql_snippet": "WHERE s.sis > 20", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "latest", "sql_snippet": "rf.rn = 1", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "the top results", "sql_snippet": "LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY s.sis DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(CAST((safety_metrics ->> 'overloads') AS INTEGER), 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN RecentFaults AS rf ON s.effectivenessrobot = rf.upkeeprobot", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "High Fault Risk", "sql_snippet": "rf.faultpredscore > 0.5", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 15}]}
{"instance_id": "robot_2", "selected_database": "robot", "amb_user_query": "I want to analyze the relationship between Joint Degradation Risk and Total Operating Hours for robots at risk. Please list each robot's ID, related details, and the regression slope of JDI versus TOH across all qualifying robots. Sort the results, and limit the output.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "at risk", "sql_snippet": "WHERE d.jdi > 1.5 AND d.mjt > 65", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "related details", "sql_snippet": "WHERE d.jdi > 1.5 AND d.mjt > 65", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "limit the output", "sql_snippet": "ORDER BY d.jdi DESC\nLIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY d.jdi DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN OperatingHours oh ON d.jcdetref = oh.operbotdetref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Joint Health Risk", "sql_snippet": "WHERE d.jdi > 1.5 AND d.mjt > 65", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 42}]}
{"instance_id": "robot_3", "selected_database": "robot", "amb_user_query": "I want to analyze Safety Incident Score (SIS) patterns for robots with safety issues across different categories. Please list each robot type, the average SIS, and the maximum SIS for robots with safety issues. Sort the results and show the top output.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "safety issues", "sql_snippet": "WHERE si.sis > 20", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "categories", "sql_snippet": "rd.bottypeval AS robot_type", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "categories", "sql_snippet": "rd.bottypeval AS robot_type", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "the top output", "sql_snippet": "ORDER BY avg_sis DESC NULLS FIRST LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY avg_sis IS NULL DESC, avg_sis DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(CAST(json_extract(ps.safety_metrics, '$.overloads') AS INTEGER), 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "INNER JOIN robot_details AS rd ON si.effectivenessrobot = rd.botdetreg", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Safety Incident Score (SIS)", "sql_snippet": "SUM(COALESCE(CAST(ps.safety_metrics ->> 'overloads' AS INTEGER), 0) + COALESCE(CAST(ps.safety_metrics ->> 'collisions' AS INTEGER), 0) + COALESCE(CAST(ps.safety_metrics ->> 'emergency_stops' AS INTEGER), 0) + COALESCE(CAST(ps.safety_metrics ->> 'speed_violations' AS INTEGER), 0)) AS sis", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 34}]}
{"instance_id": "robot_4", "selected_database": "robot", "amb_user_query": "For each robot, determine if they have overloaded controllers. Display the robot ID, and robot performance. Sort results and limit to top robots.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "overloaded controllers", "sql_snippet": "CASE WHEN cm.csi > 100 AND oc.operation_count > 2 THEN 'HIGH RISK' ELSE 'NORMAL' END as controller_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "robot performance", "sql_snippet": "SELECT rd.botdetreg, cm.csi, oc.operation_count", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "top", "sql_snippet": "ORDER BY cm.csi IS NULL DESC, cm.csi DESC\nLIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY cm.csi DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Number of Operations (NO)", "sql_snippet": "COUNT(*) as operation_count", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 8}]}
{"instance_id": "robot_5", "selected_database": "robot", "amb_user_query": "For robots that have been running over a while, analyze their maintenance priority level. Display each robot's ID, predicted failure risk, Minimum Remaining Useful Life value, TOH, Number of Operations, and the Maintenance Priority Level. Prioritize the list by predicted failure risk and time left.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "over a while", "sql_snippet": "WHERE os.toh > 1000", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "predicted failure risk", "sql_snippet": "SUM(faultpredscore * (1.0/(1 + upkeepduedays))) / SUM(1.0/(1 + upkeepduedays)) AS wfps", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "Prioritize the list", "sql_snippet": "ORDER BY fm.wfps DESC, fm.mrul ASC LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY fm.wfps DESC, fm.mrul ASC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Weighted Fault Prediction Score (WFPS)", "sql_snippet": "SUM(faultpredscore * (1.0/(1 + upkeepduedays))) / SUM(1.0/(1 + upkeepduedays)) AS wfps", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 30}, {"term": "Minimum Remaining Useful Life (MRUL)", "sql_snippet": "MIN(rulhours) as mrul", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 6}]}
{"instance_id": "robot_6", "selected_database": "robot", "amb_user_query": "Analyze robots' tool conditions and classify their status. For each robot, display its ID, average tool usage severity, TWR value, TPC value, average cycle time in seconds, and its tool status. Show the top robots.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "tool usage severity", "sql_snippet": "SUM(toolwearpct) * 1.0 / NULLIF(SUM(tc.progcyclecount), 0) as twr", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "status", "sql_snippet": "CASE WHEN tm.twr > 0.001 AND cm.tpc > 10000 THEN 'URGENT' WHEN tm.twr > 0.0005 OR tm.avg_wear > 75 THEN 'WARNING' ELSE 'NORMAL' END as tool_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY tm.twr IS NULL, tm.twr DESC, cm.tpc IS NULL, cm.tpc DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Total Program Cycles (TPC)", "sql_snippet": "SUM(progcyclecount) as tpc", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "robot_7", "selected_database": "robot", "amb_user_query": "Analyze robot operation efficiency type, where for each robot, show its ID, model series, OCE value, TPC value, average cycle time, number of unique programs, operation time, and efficiency category. Also, show each robot's efficiency ranking within its model series. Only include robots with large program cycles. Show the best ones.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "large program cycles", "sql_snippet": "WHERE te.tpc > 100000", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "efficiency type", "sql_snippet": "CASE WHEN te.oce < 100 AND te.tpc > 500000 THEN 'Low Efficiency' WHEN te.oce < 150 OR te.tpc > 300000 THEN 'Medium Efficiency' ELSE 'High Efficiency' END as efficiency_category", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "the best ones", "sql_snippet": "ORDER BY te.oce DESC, te.tpc DESC LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}, {"term": "operation time", "sql_snippet": "AVG(o.cycletimesecval) as avg_cycle_time", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "different", "sql_snippet": "DISTINCT o.currprogval", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY te.oce DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Average Cycle Time", "sql_snippet": "AVG(o.cycletimesecval) as avg_cycle_time", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 51}]}
{"instance_id": "robot_8", "selected_database": "robot", "amb_user_query": "I want to analyze Energy Efficiency Ratio patterns for robots with poor energy behavior across different application types. Please list each application type, the average EER, and the least efficient rank. Sort the results by efficiency level, and show the top ones.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "poor energy behavior", "sql_snippet": "SUM(ps.energyusekwhval) / MAX(op.totopshrval) > 0.01 AND MAX(op.totopshrval) > 1000", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "least efficient rank", "sql_snippet": "PERCENT_RANK() OVER (PARTITION BY application_type ORDER BY eer DESC) AS eer_rank", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "efficiency level", "sql_snippet": "SUM(ps.energyusekwhval) / MAX(op.totopshrval) AS eer", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "the top ones", "sql_snippet": "ORDER BY average_eer DESC LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Energy Inefficient Robot", "sql_snippet": "SUM(ps.energyusekwhval) / MAX(op.totopshrval) > 0.01 AND MAX(op.totopshrval) > 1000", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 41}]}
{"instance_id": "robot_9", "selected_database": "robot", "amb_user_query": "I want to analyze robots with low and medium precision and higher chance of issues by controller type. Please list each controller type, the Average Position Error, the maximum APE Rank, the average Recent Fault Prediction Score, and robot counts. Only include robots with large Robot Age. Show the several top rows.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "low and medium precision", "sql_snippet": "WHERE r.ape >= 0.1", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "robot counts", "sql_snippet": "COUNT(DISTINCT r.actdetref) AS robot_count", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "several top", "sql_snippet": "ORDER BY max_ape_rank DESC\nLIMIT 50", "is_mask": false, "type": "intent_ambiguity"}, {"term": "higher chance of issues", "sql_snippet": "COALESCE(fs.rfps, 0) > 0.5", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY max_ape_rank DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "different", "sql_snippet": "DISTINCT r.actdetref", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(fs.rfps, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN FaultScore fs ON r.actdetref = fs.upkeeprobot", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Robot Age in Years (RAY)", "sql_snippet": "(JULIANDAY(rr.rects) - JULIANDAY(rd.instdateval)) / 365.25 AS ray", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}, {"term": "Average Position Error (APE)", "sql_snippet": "AVG(ad.poserrmmval) AS ape", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "robot_10", "selected_database": "robot", "amb_user_query": "I want to analyze robot efficiency by model series, focusing on cycle activity stats. For each model series with enough robots, list the model series name, number of robots, average cycle activity stats metrics and average number of programs per robot as a JSON object containing the most efficient program and the average OCE across all programs. Also, count robots which might be underperforming. Sort by best cycle activity and show only the top.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "cycle activity stats", "sql_snippet": "SUM(o.progcyclecount)*1.0/NULLIF(SUM(o.cycletimesecval), 0) as program_oce", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "enough", "sql_snippet": "HAVING COUNT(*) >= 5", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "best cycle activity", "sql_snippet": "ORDER BY avg_oce DESC LIMIT 50", "is_mask": true, "type": "intent_ambiguity"}, {"term": "underperforming", "sql_snippet": "WHERE re.robot_oce < 100 AND re.total_program_cycles > 500000", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY avg_oce DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "different", "sql_snippet": "DISTINCT pm.operbotdetref", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(AVG(avg_program_oce), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Operation Cycle Efficiency (OCE)", "sql_snippet": "SUM(o.progcyclecount)*1.0/NULLIF(SUM(o.cycletimesecval), 0) as program_oce", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 43}, {"term": "Total Program Cycles (TPC)", "sql_snippet": "SUM(pm.total_cycles) as total_program_cycles", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "disaster_1", "selected_database": "disaster", "amb_user_query": "I need to analyze all distribution hubs based on how well their resources are used. Please show the hub registry ID, the calculated utilization value, and classify them accordingly. Sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "how well their resources are used", "sql_snippet": "(h.hubutilpct / 100.0) * (h.storecapm3 / (h.storeavailm3 + 1)) AS resource_utilization_ratio", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "utilization value", "sql_snippet": "(h.hubutilpct / 100.0) * (h.storecapm3 / (h.storeavailm3 + 1)) AS resource_utilization_ratio", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "classify them accordingly", "sql_snippet": "CASE WHEN (h.hubutilpct / 100.0) * (h.storecapm3 / (h.storeavailm3 + 1)) > 5 THEN 'High Utilization' WHEN (h.hubutilpct / 100.0) * (h.storecapm3 / (h.storeavailm3 + 1)) < 2 THEN 'Low Utilization' ELSE 'Moderate Utilization' END AS utilization_assessment", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY resource_utilization_ratio IS NULL, resource_utilization_ratio DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Resource Utilization Ratio (RUR)", "sql_snippet": "(h.hubutilpct / 100.0) * (h.storecapm3 / (h.storeavailm3 + 1)) AS resource_utilization_ratio", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 10}]}
{"instance_id": "disaster_2", "selected_database": "disaster", "amb_user_query": "Display all disaster response operations ranked by performance efficiency scores. Show operation IDs, their performance efficiency scores, and mark 'Yes' if they can meet the excellence criteria, and 'No' otherwise.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "performance efficiency scores", "sql_snippet": "(t.deliverysuccessrate / 100.0) * (1 - t.avgdeliveryh", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "excellence criteria", "sql_snippet": "CASE WHEN deliverysuccessrate > 90 AND invaccpct > 95 AND oei > 3 THEN 'Yes' ELSE 'No' END AS operational_excellence", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY oei DESC NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(CAST(oei AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Operational Efficiency Index (OEI)", "sql_snippet": "(t.deliverysuccessrate / 100.0) * (1 - t.avgdeliveryhours / 24.0) * (1 + t.distributionpoints / 10.0) AS oei", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 11}]}
{"instance_id": "disaster_3", "selected_database": "disaster", "amb_user_query": "List the Environmental Impact Factor of each disaster operation by showing the environmental registry, affected area, hazard type, calculated Environmental Footprint Factor, and its corresponding category. Sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "environmental registry", "sql_snippet": "SELECT e.envhealthregistry, d.distregistry", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "Environmental Footprint Factor", "sql_snippet": "ROUND(e.carbontons * (1 - e.renewenergypct / 100.0) + (100 - e.recyclepct) * 0.5, 2) AS environmental_impact_factor", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "corresponding category", "sql_snippet": "CASE WHEN e.carbontons * ( 1 - e.renewenergypct / 100.0 ) + ( 100 - e.recyclepct ) * 0.5 < 50 THEN 'Sustainable' WHEN e.carbontons * ( 1 - e.renewenergypct / 100.0 ) + ( 100 - e.recyclepct ) * 0.5 < 100 THEN 'Moderate Impact' ELSE 'High Impact' END AS sustainability_assessment", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY environmental_impact_factor IS NULL, environmental_impact_factor", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(e.carbontons * (1 - e.renewenergypct / 100.0) + (100 - e.recyclepct) * 0.5, 2)", "is_mask": true, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Environmental Impact Factor (EIF)", "sql_snippet": "ROUND(e.carbontons * (1 - e.renewenergypct / 100.0) + (100 - e.recyclepct) * 0.5, 2) AS environmental_impact_factor", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 16}]}
{"instance_id": "disaster_4", "selected_database": "disaster", "amb_user_query": "Can you identify all operations experiencing a critical resource scarcity right now? I need to see each operation's registry ID, storage details, and current supply flow state. Sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "resource scarcity", "sql_snippet": "WHERE ( h.storeavailm3 / h.storecapm3 ) < 0.1 AND o.supplyflowstate IN ('Strained', 'Disrupted')", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "storage details", "sql_snippet": "SELECT o.opsregistry, h.storecapm3, h.storeavailm3, ROUND(( h.storeavailm3 / h.storecapm3 ) * 100, 2) AS available_storage_percent", "is_mask": true, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY available_storage_percent", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND((h.storeavailm3 / h.storecapm3) * 100, 2)", "is_mask": true, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Critical Resource Shortage", "sql_snippet": "WHERE ( h.storeavailm3 / h.storecapm3 ) < 0.1 AND o.supplyflowstate IN ('Strained', 'Disrupted')", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 20}]}
{"instance_id": "disaster_5", "selected_database": "disaster", "amb_user_query": "Could you calculate the Health Resilience Score for all disaster areas and identify which ones are facing a Health Crisis? List the registry ID, the actual Health Resilience Score value, and label each area that meets Health Crisis standard as 'Health Crisis', otherwise 'Normal Health Status'. Please sort the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Health Resilience Score", "sql_snippet": "ROUND(e.waterqualityindex * 0.4 + e.sanitationcoverage * 0.3 + e.vaccinationcoverage * 0.3, 2) AS public_health_resilience_score", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "Health Crisis", "sql_snippet": "CASE WHEN e.diseaserisk = 'High' AND e.waterqualityindex < 50 AND (e.waterqualityindex * 0.4 + e.sanitationcoverage * 0.3 + e.vaccinationcoverage * 0.3) < 40 THEN 'Public Health Emergency' ELSE 'Standard Health Status' END AS health_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "registry ID", "sql_snippet": "SELECT e.envhealthregistry, d.distregistry", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY public_health_resilience_score IS NULL, public_health_resilience_score", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(e.waterqualityindex * 0.4 + e.sanitationcoverage * 0.3 + e.vaccinationcoverage * 0.3, 2)", "is_mask": true, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Public Health Resilience Score (PHRS)", "sql_snippet": "ROUND(e.waterqualityindex * 0.4 + e.sanitationcoverage * 0.3 + e.vaccinationcoverage * 0.3, 2) AS public_health_resilience_score", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 17}]}
{"instance_id": "disaster_6", "selected_database": "disaster", "amb_user_query": "Compute the Logistics Performance Metric for all transportation operations. For each transport registry ID, display the corresponding LPM score and determine its status: label as 'Logistics Breakdown' if a Logistics Failure is detected, otherwise label as 'Normal Operation'. Present the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Logistics Failure", "sql_snippet": "CASE WHEN (t.totaldeliverytons / h.hubcaptons) * t.deliverysuccessrate * (1 - t.vehiclebreakrate / 100.0) * 100 < 30 AND t.lastmilestatus = 'Suspended' AND t.vehiclebreakrate > 15 THEN 'Logistics Breakdown' ELSE 'Normal Operation' END AS logistics_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY logistics_performance_metric IS NULL, logistics_performance_metric", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND((t.totaldeliverytons / h.hubcaptons) * t.deliverysuccessrate * (1 - t.vehiclebreakrate / 100.0) * 100, 2)", "is_mask": true, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Logistics Breakdown", "sql_snippet": "CASE WHEN (t.totaldeliverytons / h.hubcaptons) * t.deliverysuccessrate * (1 - t.vehiclebreakrate / 100.0) * 100 < 30 AND t.lastmilestatus = 'Suspended' AND t.vehiclebreakrate > 15 THEN 'Logistics Breakdown' ELSE 'Normal Operation' END AS logistics_status", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 29}]}
{"instance_id": "disaster_7", "selected_database": "disaster", "amb_user_query": "Generate a report to categorize disaster areas according to the classification framework and rank disaster areas by their category and their Community Engagement Effectiveness scores. Show each area's beneficiary registry ID, disaster reference, CEE score, and classification. Within each community status category, rank them.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "classification", "sql_snippet": "CASE WHEN b.localcapacitygrowth = 'Active' AND b.commengagelvl = 'High' AND e.bsi > 70 THEN 'Community Resilience Builder' WHEN (e.bsi / 100) * e.commengage_numeric * ((e.stakeholdersatisf + 1) / 5) > 2.5 AND e.vulnerabilityreview = 'Complete' AND NOT (b.localcapacitygrowth = 'Active' AND b.commengagelvl = 'High' AND e.bsi > 70) THEN 'Community Resilience Opportunity' ELSE 'Standard Operation' END AS community_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY c.community_status, c.cee DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND((e.bsi / 100.0) * e.commengage_numeric * ((e.stakeholdersatisf + 1) / 5.0), 2)", "is_mask": true, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Community Resilience Classification", "sql_snippet": "CASE WHEN b.localcapacitygrowth = 'Active' AND b.commengagelvl = 'High' AND e.bsi > 70 THEN 'Community Resilience Builder' WHEN (e.bsi / 100) * e.commengage_numeric * ((e.stakeholdersatisf + 1) / 5) > 2.5 AND e.vulnerabilityreview = 'Complete' AND NOT (b.localcapacitygrowth = 'Active' AND b.commengagelvl = 'High' AND e.bsi > 70) THEN 'Community Resilience Opportunity' ELSE 'Standard Operation' END AS community_status", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 52}, {"term": "Community Engagement Effectiveness (CEE)", "sql_snippet": "ROUND((e.bsi / 100.0) * e.commengage_numeric * ((e.stakeholdersatisf + 1) / 5.0), 2) AS cee", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 38}]}
{"instance_id": "disaster_8", "selected_database": "disaster", "amb_user_query": "Let me see the related registry ID next to each Financial Health Index , and determine its status: label as 'Financial Crisis Risk' if a Financial Crisis Risk is detected, otherwise label as 'Financially Stable'. Rank everything from lowest to highest.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Financial Health Index", "sql_snippet": "ROUND((f.donorcommitmentsusd / f.budgetallotusd) * (1 - f.fundsutilpct / 100) - (f.resourcegapsusd / f.budgetallotusd), 2) AS financial_sustainability_ratio", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "related registry ID", "sql_snippet": "SELECT f.financeregistry, o.opsregistry, d.distregistry", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY financial_sustainability_ratio NULLS LAST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND((f.donorcommitmentsusd / f.budgetallotusd) * (1 - f.fundsutilpct / 100) - (f.resourcegapsusd / f.budgetallotusd), 2)", "is_mask": true, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Financial Sustainability Ratio (FSR)", "sql_snippet": "ROUND((f.donorcommitmentsusd / f.budgetallotusd) * (1 - f.fundsutilpct / 100) - (f.resourcegapsusd / f.budgetallotusd), 2) AS financial_sustainability_ratio", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 18}]}
{"instance_id": "disaster_9", "selected_database": "disaster", "amb_user_query": "Please provide a report containing the beneficiary registry ID, calculated the equity value, distribution status: label as 'Resource Distribution Inequity' if Resource Distribution Inequity' if inequity is detected, otherwise label as 'Normal Distribution', and disaster-affected population. I need this sorted in ascending order.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "the most urgent", "sql_snippet": "WHERE o.emerglevel IN ('Red', 'Black')", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "SELECT o.opsregistry, o.emerglevel, ROUND( ( CAST(json_extract(hr.staffingprofile, '$.personnel.total') AS REAL) / ( f.personnelcostsusd / 10000.0 ) ) * ( CAST(json_extract(hr.staffingprofile, '$.readiness.availability_percent') AS REAL) / 100.0 ), 2 ) AS per FROM operations AS o JOIN humanresources AS hr ON o.opsregistry = hr.hropsref JOIN financials AS f ON o.opsregistry = f.finopsref WHERE o.emerglevel IN ('Red', 'Black')", "is_mask": true, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Personnel Effectiveness Ratio (PER)", "sql_snippet": "ROUND( ( CAST(json_extract(hr.staffingprofile, '$.personnel.total') AS REAL) / ( f.personnelcostsusd / 10000.0 ) ) * ( CAST(json_extract(hr.staffingprofile, '$.readiness.availability_percent') AS REAL) / 100.0 ), 2 ) AS per", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "disaster_10", "selected_database": "disaster", "amb_user_query": "Please provide a report containing the beneficiary registry ID, calculated the equity value, distribution status: label as 'Resource Distribution Inequity' if Resource Distribution Inequity' if inequity is detected, otherwise label as 'Normal Distribution', and disaster-affected population. I need this sorted in ascending order.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "equity value", "sql_snippet": "ROUND(cf.distequityidx * (1 + (t.distributionpoints / 20.0)) * (1 - ((100 - t.deliverysuccessrate) / 100.0)) * cf.coordeffect_factor, 2) AS rde", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "disaster-affected population", "sql_snippet": "json_extract(d.impactmetrics, '$.population.affected') AS affected_population", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY r.rde IS NULL, r.rde", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Resource Distribution Equity (RDE)", "sql_snippet": "ROUND(cf.distequityidx * (1 + (t.distributionpoints / 20.0)) * (1 - ((100 - t.deliverysuccessrate) / 100.0)) * cf.coordeffect_factor, 2) AS rde", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 31}]}
{"instance_id": "fake_1", "selected_database": "fake", "amb_user_query": "Find all Bot Networks, and display the cluster size, average Bot Behavior Index score, and total account count for related profiles. Sort results and show the top clusters.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "the top", "sql_snippet": "LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}, {"term": "related profiles", "sql_snippet": "COUNT(m.modactkey) AS account_count", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY avg_bbi DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(AVG(COALESCE(bbi_score, 0)), 2) AS avg_bbi", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN bbi_calc AS bc ON m.macntref = bc.accindex\nUNION\nSELECT m.clustsize, ROUND(AVG(COALESCE(bbi_score, 0)), 2) AS avg_bbi, COUNT(m.modactkey) AS account_count FROM bbi_calc AS bc LEFT JOIN moderationaction AS m ON m.macntref = bc.accindex WHERE m.macntref IS NULL GROUP BY m.clustsize", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(bbi_score, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Bot Behavior Index (BBI)", "sql_snippet": "(0.4 * CAST(json_extract(sd.detection_score_profile, '$.behavior_scores.botlikscore') AS REAL) + 0.3 * CAST(json_extract(sd.detection_score_profile, '$.behavior_scores.autobehavscore') AS REAL) + 0.3 * (1 - ma.convnatval)) AS bbi_score", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "fake_2", "selected_database": "fake", "amb_user_query": "Find all accounts showing weird engagement patterns in the system. Display their account IDs, engagement authenticity scores, timing patterns, and mark them with a 'Manipulator' status. Only show the top results.  Make sure to keep all relevant engagement records.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "weird engagement patterns", "sql_snippet": "WHERE ed.engauth < 0.3 AND ed.tempinteractpat = 'Automated'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "the top results", "sql_snippet": "LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}, {"term": "timing patterns", "sql_snippet": "SELECT ed.tempinteractpat", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "join", "sql_snippet": "LEFT JOIN sessionbehavior AS sb ON ed.netsessref = sb.sessref LEFT JOIN profile AS p ON sb.sessprofref = p.profkey LEFT JOIN account AS a ON p.profaccref = a.accindex", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "fake_3", "selected_database": "fake", "amb_user_query": "Find all inactive automated bots. Show account IDs, Bot Behavior Index scores, and classify them into associated risk tier. Only include accounts whose BBI clears a basic cutoff, limit the top highest-risk accounts. Make sure to include all dormant accounts.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "inactive automated bots", "sql_snippet": "WHERE a.acctstatus = 'Dormant'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "a basic cutoff", "sql_snippet": "WHERE bc.bbi_score > 0.2", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "risk tier", "sql_snippet": "CASE WHEN bc.bbi_score > 0.9 THEN 'High Risk' WHEN bc.bbi_score > 0.3 THEN 'Moderate Risk' ELSE 'Low Risk' END AS risk_category", "is_mask": false, "type": "intent_ambiguity"}, {"term": "the top", "sql_snippet": "LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY bc.bbi_score DESC NULLS FIRST LIMIT 100", "is_mask": false, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN moderationaction AS m ON a.accindex = m.macntref", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(CAST(json_extract(sd.detection_score_profile, '$.behavior_scores.botlikscore') AS REAL) / 100, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Bot Behavior Index (BBI)", "sql_snippet": "(0.4 * COALESCE(CAST(json_extract(sd.detection_score_profile, '$.behavior_scores.botlikscore') AS REAL) / 100, 0) + 0.3 * COALESCE(CAST(json_extract(sd.detection_score_profile, '$.behavior_scores.autobehavscore') AS REAL), 0) + 0.3 * (1 - COALESCE(ma.convnatval, 0))) AS bbi_score", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "fake_4", "selected_database": "fake", "amb_user_query": "Find accounts acting as content farms. List the content reference ID, Content Manipulation Score, frequency-related details, and manipulation rank for the top content farms. Sort by manipulation rank.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "frequency-related details", "sql_snippet": "cb.postfreq, CASE WHEN cb.postfreq > 50 THEN 'High' WHEN cb.postfreq > 20 THEN 'Medium' ELSE 'Low' END AS freq_category", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "the top content farms", "sql_snippet": "LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY manipulation_rank", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Content Manipulation Score (CMS)", "sql_snippet": "(0.4 * (1 - cb.cntuniqscore) + 0.3 * cb.mediareratio + 0.3 * (1 - m.txtuniq)) AS cms", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 8}]}
{"instance_id": "fake_5", "selected_database": "fake", "amb_user_query": "Find the biggest VPN Abusers. For each abuser, show their account IDs, TEI value, number of different countries they've logged in from, and their ranking.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "the biggest", "sql_snippet": "WHERE tei_quartile = 4 ORDER BY tei DESC LIMIT 10", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "ranking", "sql_snippet": "CAST((SELECT COUNT(*) FROM evasion_scores e2 WHERE e2.tei < e.tei OR (e2.tei = e.tei AND e2.techkey < e.techkey)) * 4.0 / (SELECT COUNT(*) FROM evasion_scores) AS INTEGER) + 1", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY tei DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "different", "sql_snippet": "SELECT t.techkey, a.accindex, ROUND((0.4 * t.vpnratio + 0.3 * (t.proxycount / 10.0) + 0.3 * (t.ipcountrynum / 20.0)), 2) AS tei, t.ipcountrynum FROM technicalinfo t JOIN networkmetrics n ON n.netkey = t.technetref JOIN sessionbehavior sb ON sb.sessref = n.netsessref JOIN profile p ON p.profkey = sb.sessprofref JOIN account a ON a.accindex = p.profaccref WHERE t.vpnratio > 0 GROUP BY t.techkey, a.accindex, t.vpnratio, t.proxycount, t.ipcountrynum", "is_mask": false, "type": "distinct_ambiguity"}]}, "knowledge_ambiguity": [{"term": "TEI quartile", "sql_snippet": "NTILE(4) OVER (ORDER BY e.tei) AS tei_quartile", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 70}]}
{"instance_id": "fake_6", "selected_database": "fake", "amb_user_query": "Find the accounts that could be part of some odd-behaviour group. For each account, show their account ID, their overall weirdness score, and the recent bot rating. Only include accounts with a strong bot signal and just show the top few.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "odd-behaviour group", "sql_snippet": "WHERE bas > 0.8", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "weirdness score", "sql_snippet": "ROUND((0.4 * bbi.bbi + 0.4 * aa.aaf + 0.2 * ng.ngv), 2) AS bas", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "recent bot rating", "sql_snippet": "FIRST_VALUE(json_extract(s.detection_score_profile, '$.behavior_scores.botlikscore')) OVER (PARTITION BY a.accindex ORDER BY s.detecttime DESC) AS latest_botlikscore", "is_mask": true, "type": "schema_linking_ambiguity"}, {"term": "strong bot signal", "sql_snippet": "json_extract(s.detection_score_profile, '$.behavior_scores.botlikscore') > 70", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "the top few", "sql_snippet": "LIMIT 10", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY bas DESC NULLS FIRST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND((0.4 * bbi.bbi + 0.4 * aa.aaf + 0.2 * ng.ngv), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Behavioral Anomaly Score (BAS)", "sql_snippet": "ROUND((0.4 * bbi.bbi + 0.4 * aa.aaf + 0.2 * ng.ngv), 2) AS bas", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 39}, {"term": "Account Activity Frequency (AAF)", "sql_snippet": "(CAST(sb.sesscount AS REAL) / a.acctagespan) AS aaf", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}, {"term": "Network Growth Velocity (NGV)", "sql_snippet": "SQRT(POWER(CAST((n.network_engagement_metrics -> '$.connection_metrics' ->> '$.followgrowrate') AS REAL), 2) + POWER(CAST((n.network_engagement_metrics -> '$.connection_metrics' ->> '$.followinggrowrate') AS REAL), 2)) AS ngv", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "fake_7", "selected_database": "fake", "amb_user_query": "Find the most concerning sleeping profiles with the highest reputational risk, considering their status and past moderation actions. List each accounts ID, reputation score, complaint count, and the date of their last review.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "sleeping profiles", "sql_snippet": "WHERE a.acctstatus = 'Dormant'", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "complaint count", "sql_snippet": "SELECT abuserepnum", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "most concerning", "sql_snippet": "WHERE risk_quartile = 1 ORDER BY abuserepnum IS NULL DESC, abuserepnum DESC LIMIT 10", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY abuserepnum IS NULL, abuserepnum DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "fake_8", "selected_database": "fake", "amb_user_query": "Find the top High-Impact Amplifier accounts in an Amplification Network, ranked by their reach score. List each account's ID, overall reach score, posting frequency, cluster member count, and influence rank. Ensure the accounts have significant influence and frequent posting activity, and limit the results to the top ones.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "reach score", "sql_snippet": "SELECT m.netinflscore", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "the top ones", "sql_snippet": "WHERE influence_rank <= 10", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "High-Impact Amplifier", "sql_snippet": "WHERE netinflscore > 80 AND postfreq > 30", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 73}]}
{"instance_id": "fake_9", "selected_database": "fake", "amb_user_query": "I want to identify the top hyper-active user group, showing each account's ID, the session tally, their overall posting speed, a fixed platform count of 1, and the cross-risk score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "hyper-active user group", "sql_snippet": "WHERE aa.session_count > 1000 OR aa.total_post_frequency > 50", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "cross-risk score", "sql_snippet": "(sc.srs * (1 + 0.2 * sc.ipcountrynum)) AS cpri", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "session tally", "sql_snippet": "COUNT(sb.sessref) AS session_count", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "posting speed", "sql_snippet": "SUM(cb.postfreq) AS total_post_frequency", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY cpri DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(MAX(0.4 * CAST(json_extract(s.detection_score_profile, '$.overall.riskval') AS REAL) + 0.3 * (1 - m.trustval) + 0.3 * m.impactval), 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN securitydetection AS s ON s.secdetkey = m.masedetref", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Cross-Platform Risk Index (CPRI)", "sql_snippet": "(sc.srs * (1 + 0.2 * sc.ipcountrynum)) AS cpri", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 30}, {"term": "Security Risk Score (SRS)", "sql_snippet": "COALESCE(MAX(0.4 * CAST(json_extract(s.detection_score_profile, '$.overall.riskval') AS REAL) + 0.3 * (1 - m.trustval) + 0.3 * m.impactval), 0) AS srs", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "fake_10", "selected_database": "fake", "amb_user_query": "Find the leading central players in the network. For each account, show their account ID, the overall prominence score, and ranking. Only include accounts with positive NIC scores.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "ranking", "sql_snippet": "RANK() OVER (ORDER BY (0.4 * CAST(json_extract(nm.network_engagement_metrics, '$.connection_metrics.connqualscore') AS REAL) + 0.3 * m.netinflscore + 0.3 * CAST(json_extract(nm.network_engagement_metrics, '$.interaction_metrics.interactdiv') AS REAL) / 100) DESC) AS influence_rank", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "prominence score", "sql_snippet": "ROUND( ( 0.4 * CAST(json_extract(nm.network_engagement_metrics, '$.connection_metrics.connqualscore') AS REAL) + 0.3 * m.netinflscore + 0.3 * CAST(json_extract(nm.network_engagement_metrics, '$.interaction_metrics.interactdiv') AS REAL) / 100 ), 2 ) AS nic", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "leading", "sql_snippet": "LIMIT 10", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY CASE WHEN influence_rank IS NULL THEN 1 ELSE 0 END, influence_rank", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND((0.4 * CAST((nm.network_engagement_metrics ->> '$.connection_metrics.connqualscore') AS REAL) + 0.3 * m.netinflscore + 0.3 * CAST((nm.network_engagement_metrics ->> '$.interaction_metrics.interactdiv') AS REAL) / 100),2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Network Influence Centrality (NIC)", "sql_snippet": "ROUND( ( 0.4 * CAST(json_extract(nm.network_engagement_metrics, '$.connection_metrics.connqualscore') AS REAL) + 0.3 * m.netinflscore + 0.3 * CAST(json_extract(nm.network_engagement_metrics, '$.interaction_metrics.interactdiv') AS REAL) / 100 ), 2 ) AS nic", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 51}]}
{"instance_id": "virtual_1", "selected_database": "virtual", "amb_user_query": "I want to identify all supporters who are gift-heavy among lower-tier members. Please list their user IDs, nicknames, gift score, and membership type.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "supporters", "sql_snippet": "WHERE gift_impact_quotient > 50 AND spendusd < 100", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "gift-heavy", "sql_snippet": "gift_impact_quotient > 50", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "lower-tier members", "sql_snippet": "membkind IN ('Free', 'Basic')", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(gift_impact_quotient, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY gift_impact_quotient DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Gift Impact Quotient (GIQ)", "sql_snippet": "(i.giftvalusd * i.gifttot / 100.0) AS gift_impact_quotient", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 34}]}
{"instance_id": "virtual_2", "selected_database": "virtual", "amb_user_query": "Can you recognize all big spenders in our system? I need a list showing their user ID, nickname, and total support. Sort from highest to lowest.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "big spenders", "sql_snippet": "FROM fans f JOIN membershipandspending ms ON ms.memberfanpivot = f.userregistry LEFT JOIN interactions i ON i.interactfanpivot = f.userregistry WHERE (COALESCE(i.giftvalusd, 0) > 500 OR ms.spendusd > 1000) AND (i.timemark IS NULL OR i.timemark > date('now', '-90 days'))", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "total support", "sql_snippet": "(COALESCE(ms.spendusd, 0) + COALESCE(i.giftvalusd, 0)) AS total_support_usd", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY total_support_usd DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(i.giftvalusd, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN interactions i ON i.interactfanpivot = f.userregistry", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "virtual_3", "selected_database": "virtual", "amb_user_query": "Show me a breakdown of our fan tiers. I need to see each tier category, the count of fans in each category, their average points, and average spending amounts. Include active fans and those who may not have spending records in our system yet.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "fan tiers", "sql_snippet": "CASE WHEN f.tierstep BETWEEN 1 AND 3 THEN 'Entry-level' WHEN f.tierstep BETWEEN 4 AND 7 THEN 'Mid-level' WHEN f.tierstep BETWEEN 8 AND 10 THEN 'High-level' WHEN f.tierstep > 10 THEN 'Core' ELSE 'Undefined' END", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "active fans", "sql_snippet": "WHERE f.statustag IN ('Active', 'VIP')", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(ptsval), 2), ROUND(AVG(spendusd), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(ms.spendusd, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN membershipandspending AS ms ON ms.memberfanpivot = f.userregistry", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "fans.tierstep", "sql_snippet": "CASE WHEN f.tierstep BETWEEN 1 AND 3 THEN 'Entry-level' WHEN f.tierstep BETWEEN 4 AND 7 THEN 'Mid-level' WHEN f.tierstep BETWEEN 8 AND 10 THEN 'High-level' WHEN f.tierstep > 10 THEN 'Core' ELSE 'Undefined' END", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "virtual_4", "selected_database": "virtual", "amb_user_query": "Please identify users who are content creators by showing their user ID, nickname, content quality score, content volume, follower count, and creator type. Sort by quality and followers.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "content creators", "sql_snippet": "CASE WHEN CAST(json_extract(sc.community_engagement, '$.content_creation.contqualrate') AS REAL) > 8.5 AND CAST(json_extract(sc.community_engagement, '$.network.follcount') AS INTEGER) > 1000 AND CAST(json_extract(sc.community_engagement, '$.content_creation.ugcval') AS INTEGER) > 20 THEN 'High-Value Content Creator' WHEN CAST(json_extract(sc.community_engagement, '$.content_creation.contqualrate') AS REAL) > 7.0 AND CAST(json_extract(sc.community_engagement, '$.content_creation.ugcval') AS INTEGER) > 20 THEN 'Content Creator' ELSE 'Regular Fan' END AS creator_classification", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "by quality and followers", "sql_snippet": "ORDER BY content_quality DESC NULLS LAST, follower_count DESC NULLS LAST", "is_mask": false, "type": "syntactic_ambiguity"}, {"term": "creator type", "sql_snippet": "CASE WHEN CAST(json_extract(sc.community_engagement, '$.content_creation.contqualrate') AS REAL) > 8.5 AND CAST(json_extract(sc.community_engagement, '$.network.follcount') AS INTEGER) > 1000 AND CAST(json_extract(sc.community_engagement, '$.content_creation.ugcval') AS INTEGER) > 20 THEN 'High-Value Content Creator' WHEN CAST(json_extract(sc.community_engagement, '$.content_creation.contqualrate') AS REAL) > 7.0 AND CAST(json_extract(sc.community_engagement, '$.content_creation.ugcval') AS INTEGER) > 20 THEN 'Content Creator' ELSE 'Regular Fan' END AS creator_classification", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY content_quality DESC NULLS FIRST, follower_count DESC NULLS FIRST", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE NOT CAST(( sc.community_engagement -> '$.content_creation' ->> '$.contqualrate' ) AS REAL) IS NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Content Creator Classification", "sql_snippet": "CASE WHEN CAST(json_extract(sc.community_engagement, '$.content_creation.contqualrate') AS REAL) > 8.5 AND CAST(json_extract(sc.community_engagement, '$.network.follcount') AS INTEGER) > 1000 AND CAST(json_extract(sc.community_engagement, '$.content_creation.ugcval') AS INTEGER) > 20 THEN 'High-Value Content Creator' WHEN CAST(json_extract(sc.community_engagement, '$.content_creation.contqualrate') AS REAL) > 7.0 AND CAST(json_extract(sc.community_engagement, '$.content_creation.ugcval') AS INTEGER) > 20 THEN 'Content Creator' ELSE 'Regular Fan' END AS creator_classification", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 50}]}
{"instance_id": "virtual_5", "selected_database": "virtual", "amb_user_query": "I'm trying to analyze the economic value of Silent Supporters on our platform. Show me these valuable users with their nicknames, economic impact, engagement rates, and activity ratios. Also include their membership tier, revenue per view, and their Content Preference Classification. Make sure to include all users who meet the Silent Supporter criteria, even if they're missing some interaction. Present the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "valuable supporters", "sql_snippet": "WHERE fm.spendusd * (1 + fm.membdays/365.0 * 0.5) * (1 + COALESCE(fi.gifttot, 0)/10.0 * 0.2) > 100 AND e.engrate < 0.3 AND CAST(COALESCE(fi.chatmsg, 0) AS REAL) / NULLIF(p.sesscount, 0) < 0.5", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "economic impact", "sql_snippet": "fm.spendusd * ( 1 + fm.membdays / 365.0 * 0.5 ) * ( 1 + COALESCE(fi.gifttot, 0) / 10.0 * 0.2 ) AS mv", "is_mask": true, "type": "schema_linking_ambiguity"}, {"term": "activity ratios", "sql_snippet": "CAST(COALESCE(fi.chatmsg, 0) AS REAL) / NULLIF(p.sesscount, 0) AS chat_message_ratio", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "revenue per view", "sql_snippet": "spendusd / NULLIF(watch_hours, 0) AS revenue_per_hour", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY mv DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN fan_interactions AS fi ON fi.userregistry = fm.userregistry", "is_mask": false, "type": "join_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(fi.chatmsg, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Silent Supporter", "sql_snippet": "WHERE fm.spendusd * (1 + fm.membdays/365.0 * 0.5) * (1 + COALESCE(fi.gifttot, 0)/10.0 * 0.2) > 100 AND e.engrate < 0.3 AND CAST(COALESCE(fi.chatmsg, 0) AS REAL) / NULLIF(p.sesscount, 0) < 0.5", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 24}]}
{"instance_id": "virtual_6", "selected_database": "virtual", "amb_user_query": "Give me a breakdown of users by their churn risk level, showing the count of fans in each category, the average time since their last activity, their average engagement, average interaction consistency, and an average risk score for each group. This will help me prioritize our retention strategies for different risk segments.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "users", "sql_snippet": "FROM fans AS f", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "average time", "sql_snippet": "ROUND(CAST(AVG(CURRENT_DATE - p.lastlogdt) AS REAL), 2) AS avg_days_since_login", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "risk score", "sql_snippet": "ROUND(CAST(AVG((1 - p.intconsist) * 2 + (CURRENT_DATE - p.lastlogdt)/30.0 * 0.5 + CASE WHEN r.churnflag = 'None' THEN 0 WHEN r.churnflag = 'Low' THEN 1 WHEN r.churnflag = 'Medium' THEN 2 WHEN r.churnflag = 'High' THEN 3 END) AS REAL), 2) AS avg_retention_risk_factor", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(AVG(CURRENT_DATE - p.lastlogdt) AS REAL), 2) AS avg_days_since_login", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Retention Risk Factor (RRF)", "sql_snippet": "ROUND(CAST(AVG((1 - p.intconsist) * 2 + (CURRENT_DATE - p.lastlogdt)/30.0 * 0.5 + CASE WHEN r.churnflag = 'None' THEN 0 WHEN r.churnflag = 'Low' THEN 1 WHEN r.churnflag = 'Medium' THEN 2 WHEN r.churnflag = 'High' THEN 3 END) AS REAL), 2) AS avg_retention_risk_factor", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "virtual_7", "selected_database": "virtual", "amb_user_query": "Provide me with each fan's info, their fan value, and group them to fan value categories. Please sort the results by the value.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "info", "sql_snippet": "SELECT f.userregistry, f.nicklabel", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "fan value", "sql_snippet": "mv * (1 - rrf_approx / 10.0) * (1 + fei) * 24 AS flv", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "fan value categories", "sql_snippet": "CASE WHEN f.flv > p.p90 THEN 'Top Tier' WHEN f.flv > p.p75 THEN 'High Value' WHEN f.flv > p.median THEN 'Medium Value' ELSE 'Low Value' END AS value_segment", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(f.flv, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY f.flv DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(i.gifttot, 0)", "is_mask": false, "type": "null_ambiguity"}, {"term": "join", "sql_snippet": "LEFT JOIN interactions i ON i.interactfanpivot = f.userregistry", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Retention Risk Factor (RRF)", "sql_snippet": "CASE WHEN r.churnflag = 'None' THEN 0 WHEN r.churnflag = 'Low' THEN 1 WHEN r.churnflag = 'Medium' THEN 2 WHEN r.churnflag = 'High' THEN 3 END AS rrf_approx", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}, {"term": "Fan Engagement Index (FEI)", "sql_snippet": "e.engrate * 0.4 + e.socintscore / 100.0 * 0.3 + e.actdayswk / 7.0 * 0.2 + e.avgsesscount / 10.0 * 0.1 AS fei", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 10}, {"term": "Monetization Value (MV)", "sql_snippet": "fm.spendusd * (1 + fm.membdays / 365.0 * 0.5) * (1 + fm.gifttot / 10.0 * 0.2) AS mv", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 11}]}
{"instance_id": "virtual_8", "selected_database": "virtual", "amb_user_query": "I need to identify our key community members for upcoming platform development discussions. Show me a list of key community members with their nicknames, their contribution scores, group roles, activity frequency, and how long they've been members. Sort by scores.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "contribution scores", "sql_snippet": "ROUND(CAST((ccis_approx * 0.4 + sim_approx * 0.3 + collabcount * 0.1 + fei_approx * 0.2) AS REAL), 2) AS cci", "is_mask": true, "type": "schema_linking_ambiguity"}, {"term": "key community members", "sql_snippet": "WHERE (ccis_approx * 0.4 + sim_approx * 0.3 + collabcount * 0.1 + fei_approx * 0.2) > 7 AND actfreq = 'Daily' AND membdays > 180 AND (group_role = 'Moderator' OR group_role = 'Leader')", "is_mask": false, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST((ccis_approx * 0.4 + sim_approx * 0.3 + collabcount * 0.1 + fei_approx * 0.2) AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY cci DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "COALESCE(cd.viralcont, 0)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Community Pillar", "sql_snippet": "FROM cci_components WHERE (ccis_approx * 0.4 + sim_approx * 0.3 + collabcount * 0.1 + fei_approx * 0.2) > 7 AND actfreq = 'Daily' AND membdays > 180 AND (group_role = 'Moderator' OR group_role = 'Leader')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 25}]}
{"instance_id": "virtual_9", "selected_database": "virtual", "amb_user_query": "Show me a list of fans with their user ID, nicknames, how many idols they support, the names of these idols, and their average engagement. Only include fans who are active across multiple idols. Sort the results by the number of idols and engagement.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "active across multiple idols", "sql_snippet": "HAVING COUNT(DISTINCT i.interactidolpivot) >= 2 AND e.engrate > 0.4", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "names", "sql_snippet": "GROUP_CONCAT(DISTINCT vi.nametag) AS idol_names,", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "different", "sql_snippet": "COUNT(DISTINCT i.interactidolpivot)", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY idols_supported DESC, avg_engagement_rate DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "virtual_10", "selected_database": "virtual", "amb_user_query": "Find all Superfans in our database and display their nicknames, tier levels, engagement score, and financial contribution. Indicate which ones qualify as true Superfans based on the Superfan criteria and label them as 'Superfan', otherwise label them as 'Regular Fan'. Please sort the results by engagement score and monetary value. Only consider fans with active status.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "engagement score", "sql_snippet": "ROUND(CAST((e.engrate * 0.4 + e.socintscore/100 * 0.3 + e.actdayswk/7.0 * 0.2 + e.avgsesscount/10.0 * 0.1) AS REAL), 2) AS fei", "is_mask": true, "type": "schema_linking_ambiguity"}, {"term": "active status", "sql_snippet": "CASE WHEN f.tierstep >= 8 AND (e.engrate * 0.4 + e.socintscore / 100 * 0.3 + e.actdayswk / 7.0 * 0.2 + e.avgsesscount / 10.0 * 0.1) > 0.7 AND ms.spendusd * (1 + ms.membdays / 365.0 * 0.5) > 200 THEN 'Superfan' ELSE 'Regular Fan' END AS fan_classification", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST((e.engrate * 0.4 + e.socintscore/100 * 0.3 + e.actdayswk/7.0 * 0.2 + e.avgsesscount/10.0 * 0.1) AS REAL), 2) AS fei", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY fei DESC NULLS FIRST, mv DESC NULLS FIRST", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Monetization Value (MV)", "sql_snippet": "ROUND(CAST((ms.spendusd * (1 + ms.membdays/365.0 * 0.5)) AS REAL), 2) AS mv", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 11}]}
{"instance_id": "cold_chain_pharma_compliance_1", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "Find the average excursion time for high-risk shipments. Round the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "excursion time", "sql_snippet": "CAST(JSON_EXTRACT(e.env_metrics, '$.temperature.excursion_duration_min') AS REAL) AS excursion_min", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "round", "sql_snippet": "ROUND(AVG(excursion_min), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Temperature Excursion Duration (TED)", "sql_snippet": "CAST(JSON_EXTRACT(e.env_metrics, '$.temperature.excursion_duration_min') AS REAL) AS excursion_min", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "cold_chain_pharma_compliance_10", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "I need to calculate the resilience score for our operations. Please include all relevant metrics to provide an overall score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "resilience score", "sql_snippet": "ROUND(0.4 * ART + 0.3 * RRD + 0.2 * SBP + 0.1 * SMC, 2)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "all relevant metrics", "sql_snippet": "Proxy mappings based on risk_note, carrier certification, vehicle qualification, and GDP compliance.", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal places", "sql_snippet": "ROUND(..., 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Supply Chain Resilience Score (SCRS)", "sql_snippet": "0.4 * ART + 0.3 * RRD + 0.2 * SBP + 0.1 * SMC", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 30}]}
{"instance_id": "cold_chain_pharma_compliance_15", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "What proportion of bio products are stored at very low temperature? Show the answer as a percent.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "bio products", "sql_snippet": "WHERE p.prodcat = 'Biologics'", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "very low temperature", "sql_snippet": "pb.store_cond = '-70C'", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "percent rounding", "sql_snippet": "ROUND(..., 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Product Storage Classifications", "sql_snippet": "pb.store_cond = '-70C'", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "cold_chain_pharma_compliance_16", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "What is the average CO2 impact for shipments that are very late? Give the result.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "CO2 impact", "sql_snippet": "r.carbonkg", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "very late", "sql_snippet": "WHEN CAST(json_extract(s.shipment_overview, '$.timing_performance.actual_duration_hrs') AS REAL) - CAST(json_extract(s.shipment_overview, '$.timing_performance.planned_eta_hrs') AS REAL) > 24 THEN 'Severely Delayed'", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal rounding", "sql_snippet": "ROUND(AVG(carbonkg), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Delivery Performance Classification", "sql_snippet": "CASE WHEN CAST(json_extract(s.shipment_overview, '$.timing_performance.actual_duration_hrs') AS REAL) - CAST(json_extract(s.shipment_overview, '$.timing_performance.planned_eta_hrs') AS REAL) > 24 THEN 'Severely Delayed' ELSE 'Not Severely Delayed' END AS performance_category", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "cold_chain_pharma_compliance_17", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "How reliable are the loggers in our system? Count a failure if the interval is not set or the calibration is old. Just give the score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "loggers", "sql_snippet": "FROM monitoringdevices", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "interval is not set", "sql_snippet": "SUM(CASE WHEN recintmin IS NULL THEN 1 ELSE 0 END) AS reading_failures", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "calibration is old", "sql_snippet": "SUM(CASE WHEN calibts < '2024-06-26' THEN 1 ELSE 0 END) AS calibration_failures", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "score", "sql_snippet": "100 - (10 * (reading_failures * 100.0 / total_devices) + 3 * (calibration_failures * 100.0 / total_devices)) AS estimated_dlrs", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Data Logger Reliability Score (DLRS)", "sql_snippet": "100 - (10 * (reading_failures * 100.0 / total_devices) + 3 * (calibration_failures * 100.0 / total_devices))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 48}]}
{"instance_id": "cold_chain_pharma_compliance_2", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "Calculate our cold chain compliance for monitoring data.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "cold chain compliance", "sql_snippet": "SUM(CASE WHEN CAST(JSON_EXTRACT(env_metrics, '$.temperature.excursion_count') AS INTEGER) = 0 THEN 1 ELSE 0 END) * 100", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "round", "sql_snippet": "CAST(SUM(CASE WHEN CAST(JSON_EXTRACT(env_metrics, '$.temperature.excursion_count') AS INTEGER) = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Cold Chain Compliance Rate (CCCR)", "sql_snippet": "SUM(CASE WHEN CAST(JSON_EXTRACT(env_metrics, '$.temperature.excursion_count') AS INTEGER) = 0 THEN 1 ELSE 0 END) * 100 / COUNT(*)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "cold_chain_pharma_compliance_3", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "Show me how our shipments are performing and the counts.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "performing", "sql_snippet": "CASE WHEN delay_hours < -2 THEN 'Early' WHEN delay_hours >= -2 AND delay_hours <= 2 THEN 'On-Time' WHEN delay_hours > 2 AND delay_hours <= 24 THEN 'Delayed' ELSE 'Severely Delayed' END AS performance_category", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sorted", "sql_snippet": "ORDER BY number_of_shipments DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null values", "sql_snippet": "WHERE JSON_EXTRACT(shipment_overview, '$.timing_performance.actual_duration_hrs') IS NOT NULL AND JSON_EXTRACT(shipment_overview, '$.timing_performance.planned_eta_hrs') IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Delivery Performance Classification", "sql_snippet": "CASE WHEN delay_hours < -2 THEN 'Early' WHEN delay_hours >= -2 AND delay_hours <= 2 THEN 'On-Time' WHEN delay_hours > 2 AND delay_hours <= 24 THEN 'Delayed' ELSE 'Severely Delayed' END", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "cold_chain_pharma_compliance_4", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "Compare tracking states and performance. Show me the average for 'Active' and 'Intermittent'.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "tracking states", "sql_snippet": "json_extract(e.env_metrics, '$.tracking.location_tracking_state')", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "performance", "sql_snippet": "ROUND(AVG((CAST(actual_hrs AS REAL) / CAST(planned_hrs AS REAL)) * 100), 2) AS average_otdp", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal places", "sql_snippet": "ROUND(AVG((CAST(actual_hrs AS REAL) / CAST(planned_hrs AS REAL)) * 100), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "null values", "sql_snippet": "AND json_extract(s.shipment_overview, '$.timing_performance.actual_duration_hrs') IS NOT NULL AND CAST(json_extract(s.shipment_overview, '$.timing_performance.actual_duration_hrs') AS REAL) > 0", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "exchange_traded_funds_1", "selected_database": "exchange_traded_funds", "amb_user_query": "I need to find the top-performing income funds for a client. Could you please identify all the premium funds available? For each one, calculate its secure income efficiency score. Please show me the fund's ticker symbol, its name, and its score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "name", "sql_snippet": "f.shortlabel", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "premium funds", "sql_snippet": "WHERE fr.yter > 15 AND bq.high_quality_alloc > 0.6", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "ranked list", "sql_snippet": "RANK() OVER (ORDER BY (fr.yter * bq.high_quality_alloc) DESC) AS premier_rank", "is_mask": true, "type": "rank_ambiguity"}, {"term": "ordered", "sql_snippet": "ORDER BY premier_rank", "is_mask": false, "type": "sort_ambiguity"}, {"term": "net expense is 0", "sql_snippet": "NULLIF(CAST(REPLACE(JSON_EXTRACT(fundmetrics, '$.Expense_Net'), ',', '') AS REAL), 0)", "is_mask": false, "type": "divide_zero_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Efficient Income Generator", "sql_snippet": "WHERE fr.yter > 15", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 14}, {"term": "High-Quality Credit Portfolio", "sql_snippet": "WHERE bq.high_quality_alloc > 0.6", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 19}]}
{"instance_id": "exchange_traded_funds_3", "selected_database": "exchange_traded_funds", "amb_user_query": "I want to see the bond funds that are best positioned for rising interest rates. Show me the ones that are significantly less sensitive to rate changes than their peers. I need to see some details for these funds.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "best positioned for rising interest rates", "sql_snippet": "WHERE fd.fund_duration < (cd.avg_category_duration - 1.5)", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "significantly less sensitive", "sql_snippet": "WHERE fd.fund_duration < (cd.avg_category_duration - 1.5)", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "peers", "sql_snippet": "AVG(CAST(json_extract(allocweights, '$.bond_characteristics.Duration_Yrs') AS REAL)) AS avg_category_duration", "is_mask": true, "type": "lexical_ambiguity"}, {"term": "some details", "sql_snippet": "SELECT fd.tickersym, f.shortlabel, fd.productclass, ROUND(fd.fund_duration, 2) AS fund_duration, ROUND(cd.avg_category_duration, 2) AS category_avg_duration, ROUND(cd.avg_category_duration - fd.fund_duration, 2) AS duration_advantage", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY duration_advantage DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal precision", "sql_snippet": "ROUND(fd.fund_duration, 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Duration Advantage", "sql_snippet": "ROUND(cd.avg_category_duration - fd.fund_duration, 2) AS duration_advantage", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 72}]}
{"instance_id": "exchange_traded_funds_13", "selected_database": "exchange_traded_funds", "amb_user_query": "How many skilled, focused managers are there?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "skilled, focused managers", "sql_snippet": "WHERE \n        CAST(JSON_EXTRACT(r.risk5y, '$.risk_measures_5y.Alpha_5Y') AS REAL) > 0 \n        AND h.positionrank = 1 \n        AND h.holdingpct > 0.08", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "High-Conviction Portfolio", "sql_snippet": "h.positionrank = 1 \n        AND h.holdingpct > 0.08", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "exchange_traded_funds_14", "selected_database": "exchange_traded_funds", "amb_user_query": "What is the average consistency-adjusted score?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "consistency-adjusted score", "sql_snippet": "info_ratio * (positive_return_consistency/100) AS cair", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "handle division by zero", "sql_snippet": "NULLIF(CAST(JSON_EXTRACT(r.risk3y, '$.risk_measures_3y.Volatility_3Y') AS REAL), 0)", "is_mask": false, "type": "divide_zero_ambiguity"}, {"term": "handle null data", "sql_snippet": "WHERE info_ratio IS NOT NULL\n      AND positive_return_consistency IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Information Ratio (Simplified)", "sql_snippet": "(CAST(JSON_EXTRACT(r.risk3y, '$.risk_measures_3y.Avg_Return_3Y') AS REAL) - CAST(JSON_EXTRACT(p.returnmetrics, '$.benchmark_returns.Bench_Return_3Y') AS REAL)) / NULLIF(CAST(JSON_EXTRACT(r.risk3y, '$.risk_measures_3y.Volatility_3Y') AS REAL), 0) AS info_ratio", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 6}]}
{"instance_id": "exchange_traded_funds_17", "selected_database": "exchange_traded_funds", "amb_user_query": "How many truly different funds are there?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "truly different funds", "sql_snippet": "WHERE is_high_conviction AND amf > 0.5 AND appraisal_ratio > 0.2", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "handle missing data", "sql_snippet": "WHERE JSON_EXTRACT(f.fundmetrics, '$.Turnover_Ratio') IS NOT NULL\n      AND JSON_EXTRACT(r.risk3y, '$.risk_measures_3y.Alpha_3Y') IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Appraisal Ratio", "sql_snippet": "CAST(JSON_EXTRACT(r.risk3y, '$.risk_measures_3y.Alpha_3Y') AS REAL) / NULLIF(CAST(JSON_EXTRACT(r.risk3y, '$.risk_measures_3y.Volatility_3Y') AS REAL) * POWER(1 - (CAST(JSON_EXTRACT(r.risk3y, '$.risk_measures_3y.R_Squared_3Y') AS REAL)/100), 0.5), 0) AS appraisal_ratio", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 50}]}
{"instance_id": "exchange_traded_funds_19", "selected_database": "exchange_traded_funds", "amb_user_query": "Which venue is the most liquid?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "most liquid", "sql_snippet": "SUM(fv.advt) AS total_advt", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "venue", "sql_snippet": "e.tradingvenue", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "handle nulls", "sql_snippet": "WHERE \n        JSON_EXTRACT(f.tradingdata, '$.volume_metrics.Vol_3M') IS NOT NULL AND \n        JSON_EXTRACT(f.tradingdata, '$.moving_averages.MA_200') IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "exchange_traded_funds_2", "selected_database": "exchange_traded_funds", "amb_user_query": "Show me the performance trend for AADR. For each year, calculate its outperformance, the prior year's number, and the change.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "outperformance", "sql_snippet": "fundperf - categoryperf AS outperformance", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "change", "sql_snippet": "outperformance - LAG(outperformance, 1, NULL) OVER (ORDER BY calendaryear) AS yoy_outperformance_change", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "performance trend", "sql_snippet": "SELECT\n    calendaryear,\n    outperformance,\n    LAG(outperformance, 1, NULL) OVER (ORDER BY calendaryear) AS previous_year_outperformance,\n    outperformance - LAG(outperformance, 1, NULL) OVER (ORDER BY calendaryear) AS yoy_outperformance_change", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY\n    calendaryear", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null", "sql_snippet": "WHERE\n        portfolioref = 'AADR'\n        AND fundperf IS NOT NULL\n        AND categoryperf IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "households_1", "selected_database": "households", "amb_user_query": "Find the typical bathroom ratio for each area. Show the area code and the average ratio.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "typical bathroom ratio", "sql_snippet": "AVG(CAST(REPLACE(JSON_EXTRACT(p.dwelling_specs, '$.Bath_Count'), '\"', '') AS REAL) / NULLIF(h.residentcount, 0))", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "area", "sql_snippet": "h.locregion", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "area code", "sql_snippet": "h.locregion", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Bathroom Ratio", "sql_snippet": "CAST(REPLACE(JSON_EXTRACT(p.dwelling_specs, '$.Bath_Count'), '\"', '') AS REAL) / NULLIF(h.residentcount, 0)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 15}]}
{"instance_id": "households_10", "selected_database": "households", "amb_user_query": "List the home IDs for all highly mobile homes that are also updated residences, with many vehicles.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "home IDs", "sql_snippet": "h.housenum", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "highly mobile homes", "sql_snippet": "(CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Auto_Count') AS INTEGER) + CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Bike_Count') AS INTEGER) + CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Motor_Count') AS INTEGER)) > 2 AND LOWER(JSON_EXTRACT(t.vehicleinventory, '$.Newest_Year')) IN ('2005 to 2009', '2010 to 2013', '2012 to 2013', '2014 or newer')", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "updated residences", "sql_snippet": "LOWER(JSON_EXTRACT(p.dwelling_specs, '$.Dwelling_Class')) IN ('brickwork house', 'apartment') AND LOWER(a.cablestatus) IN ('avail', 'available', 'yes')", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "many vehicles", "sql_snippet": "(CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Auto_Count') AS INTEGER) + CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Bike_Count') AS INTEGER) + CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Motor_Count') AS INTEGER)) > 2", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Mobile Household", "sql_snippet": "(CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Auto_Count') AS INTEGER) + CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Bike_Count') AS INTEGER) + CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Motor_Count') AS INTEGER)) > 2 AND LOWER(JSON_EXTRACT(t.vehicleinventory, '$.Newest_Year')) IN ('2005 to 2009', '2010 to 2013', '2012 to 2013', '2014 or newer')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 23}]}
{"instance_id": "households_11", "selected_database": "households", "amb_user_query": "Can you calculate and show me the top 10 households by their overall financial health? I need their ID, area, and the score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "overall financial health", "sql_snippet": "(0.4 * income_score + 0.4 * (1 - expend_coeff) + 0.2 * tenure_score) AS sei", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "top 10", "sql_snippet": "LIMIT 10", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "ID", "sql_snippet": "h.housenum", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "area", "sql_snippet": "h.locregion", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Socioeconomic Index", "sql_snippet": "(0.4 * income_score + 0.4 * (1 - expend_coeff) + 0.2 * tenure_score)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 19}]}
{"instance_id": "households_12", "selected_database": "households", "amb_user_query": "Which dwelling type has the highest average prosperity score among independent households, and how many vehicles do those households own?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "independent households", "sql_snippet": "(s.serviceref IS NULL OR (LOWER(s.domestichelp) = 'no domestic workers' AND s.socsupport = 'No')) AND ... > 1", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "prosperity score", "sql_snippet": "AVG(residentcount * income_score)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "dwelling type", "sql_snippet": "LOWER(JSON_EXTRACT(p.dwelling_specs, '$.Dwelling_Class'))", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Household Prosperity Score", "sql_snippet": "residentcount * income_score", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 14}]}
{"instance_id": "households_14", "selected_database": "households", "amb_user_query": "Can you list the homes with a good quality of life and show their bathroom-to-person metric? Sort them by that metric.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "homes with a good quality of life", "sql_snippet": "WHERE lcs > 2 AND CAST(REPLACE(p.dwelling_specs ->> 'Bath_Count', ',', '') AS REAL) / NULLIF(h.residentcount, 0) > 0.5", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "bathroom-to-person metric", "sql_snippet": "CAST(REPLACE(p.dwelling_specs ->> 'Bath_Count', ',', '') AS REAL) / NULLIF(h.residentcount, 0) AS bathroom_ratio", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Comfortable Living Household", "sql_snippet": "WHERE lcs > 2 AND CAST(REPLACE(p.dwelling_specs ->> 'Bath_Count', ',', '') AS REAL) / NULLIF(h.residentcount, 0) > 0.5", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 29}]}
{"instance_id": "households_15", "selected_database": "households", "amb_user_query": "Find all highly supported homes that are also financially secure, listing their unique house codes.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "highly supported homes", "sql_snippet": "((CASE WHEN domestichelp = 'none' THEN 0 ELSE 3 END) + (CASE WHEN socsupport = 'No' THEN 0 ELSE 4 END)) > 2", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "financially secure", "sql_snippet": "((0.4 * income_score + 0.4 * ((socioeconomic ->> 'Expend_Coeff')::numeric / NULLIF(income_score, 0)) + 0.2 * tenure_score)) > 0.7 AND ((socioeconomic ->> 'Expend_Coeff')::numeric / NULLIF(income_score, 0)) < 1.5", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "unique house codes", "sql_snippet": "SELECT DISTINCT housenum", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Well-Equipped Household", "sql_snippet": "((CASE WHEN domestichelp = 'none' THEN 0 ELSE 3 END) + (CASE WHEN socsupport = 'No' THEN 0 ELSE 4 END)) > 2", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 27}]}
{"instance_id": "households_16", "selected_database": "households", "amb_user_query": "What is the economic status of the house with ID 3?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "economic status", "sql_snippet": "json_extract(socioeconomic, '$.Income_Bracket')", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "house", "sql_snippet": "FROM households", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "ID 3", "sql_snippet": "WHERE housenum = 3", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Income Classification", "sql_snippet": "json_extract(socioeconomic, '$.Income_Bracket')", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "households_17", "selected_database": "households", "amb_user_query": "How many residences are considered wealthy in the Taguatinga area?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "residences", "sql_snippet": "FROM households", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "wealthy", "sql_snippet": "LOWER(json_extract(socioeconomic, '$.Tenure_Type')) = 'owned' AND LOWER(json_extract(socioeconomic, '$.Income_Bracket')) IN ('high income', 'very high income')", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "Taguatinga area", "sql_snippet": "TRIM(LOWER(locregion)) = 'taguatinga'", "is_mask": false, "type": "lexical_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Affluent Household", "sql_snippet": "LOWER(json_extract(socioeconomic, '$.Tenure_Type')) = 'owned' AND LOWER(json_extract(socioeconomic, '$.Income_Bracket')) IN ('high income', 'very high income')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 21}]}
{"instance_id": "households_19", "selected_database": "households", "amb_user_query": "Show the home ID with the highest car count for urban homes.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "home ID", "sql_snippet": "SELECT t.housetag", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "highest car count", "sql_snippet": "ORDER BY CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Auto_Count') AS INTEGER) DESC LIMIT 1", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "urban homes", "sql_snippet": "i.wateraccess = 'Municipal Piped' AND i.roadsurface IN ('Paved Asphalt', 'Concrete')", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY CAST(JSON_EXTRACT(t.vehicleinventory, '$.vehicle_counts.Auto_Count') AS INTEGER) DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Urban Household", "sql_snippet": "i.wateraccess = 'Municipal Piped' AND i.roadsurface IN ('Paved Asphalt', 'Concrete')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 22}]}
{"instance_id": "households_2", "selected_database": "households", "amb_user_query": "Where is the highest concentration of high-risk families?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "highest concentration", "sql_snippet": "ORDER BY (CAST(rc.high_risk_count AS REAL) / tc.total_count) DESC LIMIT 1", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "high-risk families", "sql_snippet": "WHERE s.socsupport = 'Yes' AND (vehicle count) > 2 AND (year) IN ('2010 to 2013', '2012 To 2013', '2014 or newer')", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "Where", "sql_snippet": "SELECT rc.locregion", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": []}
{"instance_id": "hulushows_1", "selected_database": "hulushows", "amb_user_query": "Find the titles with a lot of content and without extra notes. I just want their id, name, and how much content they have.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "a lot of content", "sql_snippet": "a.total_content_volume > 500", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "extra notes", "sql_snippet": "TRIM(COALESCE(annotations, '')) = ''", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "how much content", "sql_snippet": "SUM(p.std_content_sum) AS total_content_volume", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sorted", "sql_snippet": "ORDER BY a.total_content_volume DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Incomplete High-Engagement Title", "sql_snippet": "a.total_content_volume > 500 AND TRIM(COALESCE(annotations, '')) = ''", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 63}]}
{"instance_id": "hulushows_10", "selected_database": "hulushows", "amb_user_query": "Can you show how each access level contributes to the overall media collection? Include each tier's ID, name, how much media it holds, and its share in the full catalog.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "access level", "sql_snippet": "JOIN rollups r ON t.tier_key = r.tierkey", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "share", "sql_snippet": "ROUND(CAST(t.media_total AS REAL) / ts.grand_total, 4) AS tier_distribution_ratio", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY tier_distribution_ratio DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal places", "sql_snippet": "ROUND(..., 4)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Tier Distribution Ratio", "sql_snippet": "ROUND(CAST(t.media_total AS REAL) / ts.grand_total, 4) AS tier_distribution_ratio", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 29}]}
{"instance_id": "hulushows_11", "selected_database": "hulushows", "amb_user_query": "Which content groups show good presence across different distribution setups? List those with sufficient coverage.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "content groups", "sql_snippet": "c.series_id", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "sufficient coverage", "sql_snippet": "WHERE fs.show_count >= 3 AND ft.tier_count >= 3", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "distribution setups", "sql_snippet": "COUNT(DISTINCT sr.srlinks) AS tier_count", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "sorted", "sql_snippet": "ORDER BY fs.show_count DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Syndicated Franchise Engagement", "sql_snippet": "WHERE fs.show_count >= 3 AND ft.tier_count >= 3", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 73}]}
{"instance_id": "hulushows_12", "selected_database": "hulushows", "amb_user_query": "List the shows with one of the main types like drama, comedy or animated stuff. Give me their ID, the name, and show what they fall under. Alphabetize them.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "animated stuff", "sql_snippet": "json_extract(c.genreclass, '$.Primary_Genre') = 'Animation and Cartoons'", "is_mask": true, "type": "lexical_ambiguity"}, {"term": "main types", "sql_snippet": "json_extract(c.genreclass, '$.Primary_Genre') IN ('Drama', 'Comedy', 'Animation and Cartoons')", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "what they fall under", "sql_snippet": "json_extract(c.genreclass, '$.Primary_Genre') AS primary_genre", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "alphabetize", "sql_snippet": "ORDER BY content_title", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Primary Genre Classification", "sql_snippet": "json_extract(c.genreclass, '$.Primary_Genre') IN ('Drama', 'Comedy', 'Animation and Cartoons')", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 74}]}
{"instance_id": "hulushows_13", "selected_database": "hulushows", "amb_user_query": "Group the shows into three content size categories based on how packed their library is. Return each show's ID, total video count, and its level.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "content size categories", "sql_snippet": "CASE WHEN CAST(json_extract(ci.mediacounts, '$.content_volumes.Videos_Total') AS INTEGER) > 500 THEN 'High' WHEN CAST(json_extract(ci.mediacounts, '$.content_volumes.Videos_Total') AS INTEGER) BETWEEN 200 AND 500 THEN 'Medium' ELSE 'Low' END AS volume_level", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "how packed", "sql_snippet": "CAST(json_extract(ci.mediacounts, '$.content_volumes.Videos_Total') AS INTEGER) AS total_video_volume", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "level", "sql_snippet": "CASE WHEN CAST(json_extract(ci.mediacounts, '$.content_volumes.Videos_Total') AS INTEGER) > 500 THEN 'High' WHEN CAST(json_extract(ci.mediacounts, '$.content_volumes.Videos_Total') AS INTEGER) BETWEEN 200 AND 500 THEN 'Medium' ELSE 'Low' END AS volume_level", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY total_video_volume DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Content Volume Level Classification", "sql_snippet": "CASE WHEN CAST(json_extract(ci.mediacounts, '$.content_volumes.Videos_Total') AS INTEGER) > 500 THEN 'High' WHEN CAST(json_extract(ci.mediacounts, '$.content_volumes.Videos_Total') AS INTEGER) BETWEEN 200 AND 500 THEN 'Medium' ELSE 'Low' END AS volume_level", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 75}]}
{"instance_id": "hulushows_14", "selected_database": "hulushows", "amb_user_query": "Which entry is most promo-saturated? Return the maximum promo saturation ratio.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "promotion-related messages", "sql_snippet": "JSON_EXTRACT(tiernotices, '$.free_tier.Alert_Note'), ..., JSON_EXTRACT(tiernotices, '$.member_tier.Expire_Note')", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "plans", "sql_snippet": "JSON_EXTRACT(tiernotices, '$.free_tier'), JSON_EXTRACT(tiernotices, '$.member_tier')", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "fill-up ratio", "sql_snippet": "((...sum of filled fields...) / 8.0)", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Promotional Intensity Summary", "sql_snippet": "((IIF(LENGTH(JSON_EXTRACT(tiernotices, '$.free_tier.Alert_Note')) > 0, 1, 0) + ... + IIF(LENGTH(JSON_EXTRACT(tiernotices, '$.member_tier.Expire_Note')) > 0, 1, 0)) / 8.0", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 80}]}
{"instance_id": "hulushows_15", "selected_database": "hulushows", "amb_user_query": "Just count how many shows fall into these typical levels. Match their score into categories like low or high or stuff like that.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "typical levels", "sql_snippet": "SELECT 'Low' AS tier, 0.0 AS min_score, 2.0 AS max_score UNION ALL SELECT 'Medium', 2.0, 4.0 UNION ALL SELECT 'High', 4.0, 5.0", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "match their score", "sql_snippet": "(c.genreclass ->> 'userscore')::float BETWEEN s.min_score AND s.max_score", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "how many shows", "sql_snippet": "SELECT COUNT(*) AS shows_with_matched_score_range", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "User Score Formats", "sql_snippet": "(c.genreclass ->> 'userscore') ~ '^[0-9.]+'", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}, {"term": "Content Volume Level Classification", "sql_snippet": "WITH standard_score_ranges AS (SELECT 'Low' AS tier, 0.0 AS min_score, 2.0 AS max_score UNION ALL SELECT 'Medium', 2.0, 4.0 UNION ALL SELECT 'High', 4.0, 5.0)", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 75}]}
{"instance_id": "hulushows_16", "selected_database": "hulushows", "amb_user_query": "List all shows that are widely syndicated across access plans. For each, show its ID and how many categories it spans. Put the most distributed shows at the top.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "widely syndicated", "sql_snippet": "WHERE t.tier_count >= 3", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "access plans", "sql_snippet": "COUNT(DISTINCT srlinks) AS tier_count", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "categories", "sql_snippet": "COUNT(DISTINCT srlinks) AS tier_count", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "show its ID", "sql_snippet": "SELECT c.content_key", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY tier_count DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Multi-Tier Syndication", "sql_snippet": "WHERE t.tier_count >= 3", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 76}]}
{"instance_id": "hulushows_19", "selected_database": "hulushows", "amb_user_query": "I want to know which shows might come with movie snippets. Just show their titles and some volume for the snippet thing, plus something that indicates clip presence.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "movie snippets", "sql_snippet": "CAST(REPLACE(TRIM(sr.contentvols, '$standard_content.FilmClip_Vol'), '', '0') AS INTEGER) AS film_clip_vol", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "clip presence", "sql_snippet": "CASE WHEN COALESCE(cps.film_clip_vol, 0) > 0 THEN 'Has Clips' ELSE 'No Clips' END AS clip_flag", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "volume for the snippet thing", "sql_snippet": "CAST(REPLACE(TRIM(sr.contentvols, '$standard_content.FilmClip_Vol'), '', '0') AS INTEGER) AS film_clip_vol", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "titles", "sql_snippet": "c.content_title", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY film_clip_vol DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Clip Availability Flag", "sql_snippet": "CASE WHEN COALESCE(cps.film_clip_vol, 0) > 0 THEN 'Has Clips' ELSE 'No Clips' END AS clip_flag", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 79}]}
{"instance_id": "hulushows_2", "selected_database": "hulushows", "amb_user_query": "Find syndicated shows that are in several tier groups. For each show, return ID and how many different tiers it's in. Focus on shows with many tier entries.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "tier groups", "sql_snippet": "COUNT(DISTINCT srlinks) AS tier_count", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "many", "sql_snippet": "WHERE tier_count >= 3", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "syndicated shows", "sql_snippet": "SELECT content_key FROM tier_distribution WHERE tier_count >= 3", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY tier_count DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Multitier Syndicated Show", "sql_snippet": "WHERE tier_count >= 3", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 41}]}
{"instance_id": "labor_certification_applications_13", "selected_database": "labor_certification_applications", "amb_user_query": "Find concentrated areas of visa activity in the country and report how many there are.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "concentrated areas", "sql_snippet": "state_app_count > (national_avg * 1.5)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "visa activity", "sql_snippet": "COUNT(cw.dockkey) AS state_app_count", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Geographic Application Hotspot", "sql_snippet": "state_app_count > (national_avg * 1.5)", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 44}]}
{"instance_id": "labor_certification_applications_15", "selected_database": "labor_certification_applications", "amb_user_query": "Group attorneys into categories by visa focus. Show each category with attorney count, average specialization, and dominant visa coverage. Don't include attorneys handling few cases.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "categories by visa focus", "sql_snippet": "CASE WHEN dominant_visa_percentage > 80 THEN 'Specialists' WHEN unique_visa_types_per_attorney BETWEEN 2 AND 3 THEN 'Hybrid Practitioners' ELSE 'Generalists' END AS specialization_category", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "few cases", "sql_snippet": "WHERE total_cases_per_attorney >= 5", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY attorney_count DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "rounding", "sql_snippet": "ROUND(AVG(specialization_index), 3)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Attorney Specialization Index (ASI)", "sql_snippet": "1.0 - (CAST(at.unique_visa_types_per_attorney AS REAL) / 4.0) AS specialization_index", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 34}]}
{"instance_id": "labor_certification_applications_17", "selected_database": "labor_certification_applications", "amb_user_query": "I need an overview of the wage level distribution for specialty occupation visas. Please show the breakdown.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "specialty occupation visas", "sql_snippet": "c.visacls = 'H-1B'", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "breakdown", "sql_snippet": "SELECT JSON_EXTRACT(pw.wage_details, '$.prevailing_wage.level') AS wage_level, COUNT(*) AS application_count, ROUND((CAST(COUNT(*) AS REAL) / SUM(COUNT(*)) OVER ()) * 100,2) AS percentage", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "valid wage level", "sql_snippet": "AND JSON_EXTRACT(pw.wage_details, '$.prevailing_wage.level') IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}, {"term": "percentage precision", "sql_snippet": "ROUND(..., 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "order", "sql_snippet": "ORDER BY application_count DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Prevailing Wage Levels", "sql_snippet": "JSON_EXTRACT(pw.wage_details, '$.prevailing_wage.level')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "labor_certification_applications_19", "selected_database": "labor_certification_applications", "amb_user_query": "Show me the effectiveness of legal representation. I want to compare outcomes for cases with an attorney versus those without. Give me the total cases, approved cases, and the approval status for each group.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "compare outcomes", "sql_snippet": "SELECT representation_status, COUNT(*) AS total_applications, SUM(CASE WHEN statustag LIKE 'Certified%' THEN 1 ELSE 0 END) AS certified_applications, ROUND((CAST(SUM(CASE WHEN statustag LIKE 'Certified%' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100, 2) AS approval_rate", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "approval status", "sql_snippet": "ROUND((CAST(SUM(CASE WHEN statustag LIKE 'Certified%' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100, 2) AS approval_rate", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "all cases", "sql_snippet": "FROM cases c LEFT JOIN case_attorney ca ON c.filekey = ca.docketkey", "is_mask": false, "type": "join_ambiguity"}, {"term": "rounding", "sql_snippet": "ROUND( ... , 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "division by zero", "sql_snippet": "COUNT(*)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Approval Rate (AR)", "sql_snippet": "ROUND((CAST(SUM(CASE WHEN statustag LIKE 'Certified%' THEN 1 ELSE 0 END) AS REAL) / COUNT(*)) * 100, 2)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "labor_certification_applications_2", "selected_database": "labor_certification_applications", "amb_user_query": "What's the success rate for H-1B visas that are approved?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "success rate", "sql_snippet": "CAST(SUM(CASE WHEN LOWER(TRIM(c.statustag)) LIKE 'certified%' AND LOWER(TRIM(c.visacls)) = 'h-1b' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN LOWER(TRIM(c.visacls)) = 'h-1b' THEN 1 ELSE 0 END)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "approved", "sql_snippet": "LOWER(TRIM(c.statustag)) LIKE 'certified%'", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "safe division", "sql_snippet": "SUM(CASE WHEN LOWER(TRIM(c.visacls)) = 'h-1b' THEN 1 ELSE 0 END)", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Approval Rate (AR)", "sql_snippet": "CAST(SUM(CASE WHEN LOWER(TRIM(c.statustag)) LIKE 'certified%' AND LOWER(TRIM(c.visacls)) = 'h-1b' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN LOWER(TRIM(c.visacls)) = 'h-1b' THEN 1 ELSE 0 END)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "labor_certification_applications_20", "selected_database": "labor_certification_applications", "amb_user_query": "Show me a report with the details of the most popular occupations based on their demand score. I'm interested in the relative demand for different occupations.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "demand score", "sql_snippet": "CAST(sc.application_count AS REAL) / ss.avg_applications_per_soc", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "most popular", "sql_snippet": "ORDER BY occupational_demand_index DESC LIMIT 5;", "is_mask": true, "type": "intent_ambiguity"}, {"term": "details", "sql_snippet": "SELECT sc.soctitle, sc.application_count, ROUND(CAST(sc.application_count AS REAL) / ss.avg_applications_per_soc, 2) AS occupational_demand_index", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "rounded", "sql_snippet": "ROUND(..., 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Occupational Demand Index (ODI)", "sql_snippet": "ROUND(CAST(sc.application_count AS REAL) / ss.avg_applications_per_soc, 2) AS occupational_demand_index", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 21}]}
{"instance_id": "organ_transplant_1", "selected_database": "organ_transplant", "amb_user_query": "Let's dig into the files of patients who are getting positive crossmatch results. I need a list of these folks. Show me their ID, PRA score, and DSA status. Then, tell me if they're considered 'High Risk'. Also include their previous match attempt. Sort the whole thing.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "High Risk", "sql_snippet": "CASE \n        WHEN pcr.pra_score >= 80 AND pcr.dsa_state = 'Positive' THEN 'High Risk'\n        ELSE 'Standard Risk' \n    END", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "previous match attempt", "sql_snippet": "ROW_NUMBER() OVER(PARTITION BY tm.\"recip_ref_reg\" ORDER BY tm.\"match_ts\" DESC) as rn", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "Sort the whole thing", "sql_snippet": "ORDER BY pcr.pra_score DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "include their previous match attempt", "sql_snippet": "LEFT JOIN PreviousMatch pm ON pcr.recip_id = pm.recip_id", "is_mask": false, "type": "join_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Antibody-Mediated Rejection (AMR) Risk Stratification", "sql_snippet": "CASE \n        WHEN pcr.pra_score >= 80 AND pcr.dsa_state = 'Positive' THEN 'High Risk'\n        ELSE 'Standard Risk' \n    END", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 51}]}
{"instance_id": "organ_transplant_10", "selected_database": "organ_transplant", "amb_user_query": "I need to see who's been stuck on our waiting list the longest. Can you pull a special report for me? For each organ, find the patients who have been waiting longer than everyone else. For this group, I want to see everything that might be making them hard to match: their patient ID, the organ they need, how many days they've been waiting, their PRA score, and a tally of their other health problems. Please group the list by organ and put the longest-waiting patients at the top of each group.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "waiting longer than everyone else", "sql_snippet": "WHERE wait_rank <= 0.02", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "health problems", "sql_snippet": "CASE WHEN c.comorbid_detail IS NULL THEN 0 ELSE LENGTH(c.comorbid_detail) - LENGTH(REPLACE(c.comorbid_detail, ',', '')) + 1 END AS comorbidity_count", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "patients who have been waiting longer", "sql_snippet": "PERCENT_RANK() OVER (PARTITION BY tm.org_spec ORDER BY ... DESC)", "is_mask": false, "type": "rank_ambiguity"}, {"term": "list", "sql_snippet": "ORDER BY org_spec, wait_time_days DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Immunological Sensitization", "sql_snippet": "ri.pra_score", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 29}]}
{"instance_id": "organ_transplant_13", "selected_database": "organ_transplant", "amb_user_query": "I want to know if our Decision Support System is actually helping us pick better matches. Can you check if its score lines up with the EGS score? Please take all our completed transplants and divide them into 5 groups based on their DSS score. For each of these 5 buckets, tell me how many transplants are in it and what their average Expected Graft Survival Score is. I want to see if the average EGS score goes up as the DSS score bucket goes up.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "divide them into 5 groups", "sql_snippet": "CASE\n            WHEN dss_val < (SELECT MIN(dss_val) FROM ScoreData) THEN 1\n            ELSE CAST((dss_val - (SELECT MIN(dss_val) FROM ScoreData)) * 5.0 / ((SELECT MAX(dss_val) FROM ScoreData) - (SELECT MIN(dss_val) FROM ScoreData)) + 1 AS INTEGER)\n        END", "is_mask": false, "type": "intent_ambiguity"}, {"term": "Decision Support System", "sql_snippet": "tm.dss_val", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "average Expected Graft Survival Score", "sql_snippet": "ROUND(AVG(egs_val), 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "goes up as the DSS score bucket goes up", "sql_snippet": "ORDER BY dss_bucket", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Expected Graft Survival (EGS) Score", "sql_snippet": "re.egs_val", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "organ_transplant_16", "selected_database": "organ_transplant", "amb_user_query": "I need to see the trade-offs we're making with our less-than-perfect donor organs. Can you pull a list of all matches that fall under our marginal donor criteria? For each of those matches, show me the donor and patient IDs, tell me exactly why we're calling the donor 'marginal', and then calculate the patient's urgency score so I can see just how desperate they are. Sort it so the most urgent patients are at the top.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "marginal donor criteria", "sql_snippet": "WHERE age_difference > 25 OR renal_function_score < 40", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "urgency score", "sql_snippet": "(0.7 * \n        CASE ... END) + (0.3 * (CAST(REPLACE(REPLACE(md.wait_time, '[', ''), ']', '') AS REAL) / 365.0)))", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "urgency score", "sql_snippet": "ROUND(CAST(...) AS REAL), 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "Sort it", "sql_snippet": "ORDER BY patient_urgency_score DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Marginal Donor Acceptance Criteria", "sql_snippet": "WHERE age_difference > 25 OR renal_function_score < 40", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 53}]}
{"instance_id": "organ_transplant_19", "selected_database": "organ_transplant", "amb_user_query": "I'm curious about where our single HLA mismatches are happening. Can you look at all our completed transplants that had exactly one mismatch? For that group, I want you to figure out which specific HLA type was the one that didn't match. Then, just give me a count of where the mismatches were.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "single HLA mismatches", "sql_snippet": "WHERE tm.match_status = 'Completed' AND cm.hla_mis_count = 1", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "which specific HLA type", "sql_snippet": "SELECT 'A-Locus Mismatch' AS mismatch_type, COUNT(*) AS count FROM MismatchData WHERE donor_a != recip_a\nUNION ALL\nSELECT 'B-Locus Mismatch' ...\nUNION ALL\nSELECT 'DR-Locus Mismatch' ...", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "HLA Mismatch Score", "sql_snippet": "cm.hla_mis_count = 1", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "organ_transplant_2", "selected_database": "organ_transplant", "amb_user_query": "I need the pancreas waiting list, sorted correctly for all the pending matches. Show me the patient's ID, region, urgency status, the HLA mismatch number, and their rank.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "sorted correctly", "sql_snippet": "ORDER BY pm.urgency_level ASC, pm.hla_mis_count ASC", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "their rank", "sql_snippet": "RANK() OVER (PARTITION BY pm.allc_region ORDER BY pm.urgency_level ASC, pm.hla_mis_count ASC)", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "rank", "sql_snippet": "RANK() OVER ...", "is_mask": false, "type": "rank_ambiguity"}, {"term": "sorted", "sql_snippet": "ORDER BY pm.allc_region, allocation_rank", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Allocation Policy", "sql_snippet": "ORDER BY pm.urgency_level ASC, pm.hla_mis_count ASC", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 34}]}
{"instance_id": "organ_transplant_20", "selected_database": "organ_transplant", "amb_user_query": "I want to create a map of where we're struggling the most to find organs. Can you calculate a 'demand versus supply ratio' for each region and for each blood type? For 'demand', count the number of patients waiting in a region for a certain blood type. For 'supply', count all the donors we've had from that region with that blood type. Show me a table with the region, the blood type, the number of patients, the number of donors, and the final ratio. Put the biggest problem spots at the top.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "patients waiting", "sql_snippet": "WHERE tm.match_status = 'Pending'", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "donors we've had", "sql_snippet": "COUNT(DISTINCT d.contrib_registry) AS supply_count", "is_mask": false, "type": "syntactic_ambiguity"}], "non_critical_ambiguity": [{"term": "final ratio", "sql_snippet": "ROUND(CAST(...) / NULLIF(COALESCE(rs.supply_count, 0), 0), 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "biggest problem spots at the top", "sql_snippet": "ORDER BY demand_supply_ratio DESC NULLS LAST, pending_recipients DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Regional Allocation Priority", "sql_snippet": "ad.allc_region AS region", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 36}]}
{"instance_id": "organ_transplant_22", "selected_database": "organ_transplant", "amb_user_query": "I'm worried some of our hospitals might be having a rough patch. I want to look for streaks of failed matches. Can you go through the data for each transplant center and find every time they had consecutive failed matches? I want a list that shows the hospital ID, the ID of the second failed match, and the time it happened.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "consecutive", "sql_snippet": "LAG(tm.match_status, 1, NULL) OVER (PARTITION BY ar.tx_cen_code ORDER BY tm.created_ts) AS previous_match_status", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "failed matches", "sql_snippet": "WHERE \n    match_status = 'Failed' \n    AND previous_match_status = 'Failed'", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "list", "sql_snippet": "ORDER BY center_id, failure_timestamp", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "planets_data_1", "selected_database": "planets_data", "amb_user_query": "What's the average surface pull for all those Super-Earths they found by watching stars dim?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Super-Earths", "sql_snippet": "pp.\"densvalue\" > 3 \n      AND (pp.\"massjup\" * 317.83) BETWEEN 1 AND 10", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "watching stars dim", "sql_snippet": "p.\"discmethod\" IN ('Transit', 'TR', 'Transit Method', 'Photometry', 'Photometric')", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "average", "sql_snippet": "ROUND(AVG(mass_earth / POWER(radius_earth, 2)), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "those Super-Earths", "sql_snippet": "AND pp.\"radjup\" IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Planet Surface Gravity", "sql_snippet": "AVG(mass_earth / POWER(radius_earth, 2))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 4}]}
{"instance_id": "planets_data_10", "selected_database": "planets_data", "amb_user_query": "On average, how far away are the stars that have those big, puffy gas planets? I only want to include stars where we have a solid distance number, not a bad measurement.\nShow the result in light-years.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "big, puffy gas planets", "sql_snippet": "pp.\"massjup\" > 0.1 \n  AND pp.\"densvalue\" < 0.5", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "bad measurement", "sql_snippet": "CAST(json_extract(dqt.limitflags, '$.stellar_limits.Dist_Lim') AS INTEGER) != 1\n  AND CAST(json_extract(s.stellarprops, '$.photometry.Mag_Blend') AS INTEGER) = 0", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "how far away", "sql_snippet": "ROUND(AVG(s.\"stellardist\" * 3.26156), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Distance in Light-Years", "sql_snippet": "s.\"stellardist\" * 3.26156", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 0}]}
{"instance_id": "planets_data_11", "selected_database": "planets_data", "amb_user_query": "Find me the planetary systems that are really tightly packed, but only if their closest-in planet is also super fast.\nFor these systems, I want to see the star's name and the average orbital period ratio.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "tightly packed", "sql_snippet": "WHERE pr.ratio < 3", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "super fast", "sql_snippet": "WHERE rn = 1 AND \"period\" < 10", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "average orbital period ratio", "sql_snippet": "ROUND(EXP(AVG(LN(pr.ratio))), 3)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "find me", "sql_snippet": "ORDER BY geometric_mean_ratio DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Compact System", "sql_snippet": "HAVING COUNT(*) = (\n    SELECT s.\"compcount\" - 1 FROM stars s WHERE s.\"hostplname\" = pr.\"hostplname\"\n)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 33}]}
{"instance_id": "planets_data_12", "selected_database": "planets_data", "amb_user_query": "How many different stars have planets that were found by looking at timing variations?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "timing variations", "sql_snippet": "ins.\"facilityname\" = 'ttv'", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "stars", "sql_snippet": "p.\"hostlink\"", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "different", "sql_snippet": "COUNT(DISTINCT p.\"hostlink\")", "is_mask": false, "type": "distinct_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Discovery via TTV method", "sql_snippet": "WHERE ins.\"facilityname\" = 'ttv'", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 50}]}
{"instance_id": "planets_data_13", "selected_database": "planets_data", "amb_user_query": "Find the planet with the biggest mass-to-size ratio and tell me its escape velocity.\nJust give me a whole number.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "biggest", "sql_snippet": "ORDER BY pm.mrr DESC\nLIMIT 1", "is_mask": false, "type": "intent_ambiguity"}, {"term": "mass-to-size ratio", "sql_snippet": "(pp.\"massjup\" * 317.83) / (pp.\"radjup\" * 11.209)", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "escape velocity", "sql_snippet": "CAST(SQRT(2 * 6.67430E-11 * pm.\"massjup\" * 1.898E27 / (pm.\"radjup\" * 7.1492E7)) / 1000 AS INTEGER)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "planet", "sql_snippet": "WHERE pp.\"massjup\" IS NOT NULL \n      AND pp.\"radjup\" IS NOT NULL \n      AND pp.\"radjup\" > 0", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Planet Escape Velocity", "sql_snippet": "SQRT(2 * 6.67430E-11 * pm.\"massjup\" * 1.898E27 / (pm.\"radjup\" * 7.1492E7)) / 1000", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 10}]}
{"instance_id": "planets_data_14", "selected_database": "planets_data", "amb_user_query": "Can you count up how many stars were observed with each type of light filter?\nMake sure to group the filters together properly. Then show me the filter name and how many stars for each.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "light filter", "sql_snippet": "JSON_EXTRACT(stellarprops, '$.photometry.\"Photo_Band\"')", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "group the filters together properly", "sql_snippet": "WHEN LOWER(TRIM(JSON_EXTRACT(stellarprops, '$.photometry.\"Photo_Band\"'))) IN ('v (johnson)', 'johnson', 'v', 'johnson v', 'v-band') THEN 'V-Band'\n            WHEN LOWER(TRIM(JSON_EXTRACT(stellarprops, '$.photometry.\"Photo_Band\"'))) IN ('kepler-band', 'kepler', 'kep-b', 'kep') THEN 'Kepler-Band'", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "show me", "sql_snippet": "ORDER BY COUNT(*) DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "each type", "sql_snippet": "GROUP BY standardized_band", "is_mask": false, "type": "distinct_ambiguity"}, {"term": "type of light filter", "sql_snippet": "WHERE standardized_band IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Photoband Standardization", "sql_snippet": "CASE\n            WHEN LOWER(TRIM(JSON_EXTRACT(stellarprops, '$.photometry.\"Photo_Band\"'))) IN ('v (johnson)', 'johnson', 'v', 'johnson v', 'v-band') THEN 'V-Band'\n            WHEN LOWER(TRIM(JSON_EXTRACT(stellarprops, '$.photometry.\"Photo_Band\"'))) IN ('kepler-band', 'kepler', 'kep-b', 'kep') THEN 'Kepler-Band'\n            ELSE NULL\n        END", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 44}]}
{"instance_id": "planets_data_15", "selected_database": "planets_data", "amb_user_query": "If you look at stars that only have rocky planets, what is their average brightness?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "only have rocky planets", "sql_snippet": "WHERE has_rocky = 1 AND has_gas_giant = 0", "is_mask": false, "type": "syntactic_ambiguity"}, {"term": "rocky planets", "sql_snippet": "MAX(CASE WHEN pp.\"densvalue\" > 3 THEN 1 ELSE 0 END) as has_rocky", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "average brightness", "sql_snippet": "ROUND(AVG(CAST(REPLACE(JSON_EXTRACT(s.stellarprops, '$.physical.Radius_Value'), '\"', '') AS REAL) * REPLACE(JSON_EXTRACT(s.stellarprops, '$.physical.Radius_Value'), '\"', '') * POWER(CAST(REPLACE(JSON_EXTRACT(s.stellarprops, '$.physical.Temp_Value'), '\"', '') AS REAL) / 5778, 4)), 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "stars", "sql_snippet": "WHERE pp.\"densvalue\" IS NOT NULL OR pp.\"massjup\" IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Stellar Luminosity", "sql_snippet": "REPLACE(JSON_EXTRACT(s.stellarprops, '$.physical.Radius_Value'), '\"', '') * REPLACE(JSON_EXTRACT(s.stellarprops, '$.physical.Radius_Value'), '\"', '') * POWER(CAST(REPLACE(JSON_EXTRACT(s.stellarprops, '$.physical.Temp_Value'), '\"', '') AS REAL) / 5778, 4)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "planets_data_16", "selected_database": "planets_data", "amb_user_query": "How many planets did Kepler find where the star's temperature reading is bad?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Kepler", "sql_snippet": "ins.\"facilityname\" = 'kep'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "bad", "sql_snippet": "CAST(json_extract(s.stellarprops, '$.physical.Temp_Blend') AS INTEGER) = 1", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Blended Measurement", "sql_snippet": "CAST(json_extract(s.stellarprops, '$.physical.Temp_Blend') AS INTEGER) = 1", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 38}]}
{"instance_id": "planets_data_17", "selected_database": "planets_data", "amb_user_query": "Can you give me the coordinates for the star '55 Cnc' on an HR diagram?\nI need its temperature and its luminosity.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "coordinates for the star '55 Cnc' on an HR diagram", "sql_snippet": "SELECT \n    CAST(JSON_EXTRACT(stellarprops, '$.physical.Temp_Value') AS REAL) AS effective_temperature,\n    ROUND(CAST(POWER(CAST(JSON_EXTRACT(stellarprops, '$.physical.Radius_Value') AS REAL), 2) * POWER(CAST(JSON_EXTRACT(stellarprops, '$.physical.Temp_Value') AS REAL) / 5778, 4) AS REAL), 3) AS stellar_luminosity\nFROM stars\nWHERE hostplname = '55 Cnc'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "'55 Cnc'", "sql_snippet": "hostplname = '55 Cnc'", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "luminosity", "sql_snippet": "ROUND(CAST(POWER(CAST(JSON_EXTRACT(stellarprops, '$.physical.Radius_Value') AS REAL), 2) * POWER(CAST(JSON_EXTRACT(stellarprops, '$.physical.Temp_Value') AS REAL) / 5778, 4) AS REAL), 3)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Stellar Luminosity", "sql_snippet": "POWER(CAST(JSON_EXTRACT(stellarprops, '$.physical.Radius_Value') AS REAL), 2) * POWER(CAST(JSON_EXTRACT(stellarprops, '$.physical.Temp_Value') AS REAL) / 5778, 4)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "planets_data_18", "selected_database": "planets_data", "amb_user_query": "I want to find the hottest planet that isn't a 'Hot Jupiter'.\nCan you tell me its name, its star, and its temperature?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "hottest planet", "sql_snippet": "ORDER BY equilibrium_temp DESC\nLIMIT 1", "is_mask": false, "type": "intent_ambiguity"}, {"term": "Hot Jupiter", "sql_snippet": "NOT (pp.\"massjup\" > 0.1 AND oc.\"period\" < 10)", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "temperature", "sql_snippet": "ROUND((CAST(JSON_EXTRACT(s.stellarprops, '$.physical.Temp_Value') AS REAL)) * SQRT((CAST(JSON_EXTRACT(s.stellarprops, '$.physical.Radius_Value') AS REAL)) * 6.957E8 / (2 * oc.\"semimajor\" * 1.496E11)))", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "planet", "sql_snippet": "AND (CAST(JSON_EXTRACT(s.stellarprops, '$.physical.Temp_Value') AS REAL)) IS NOT NULL\nAND (CAST(JSON_EXTRACT(s.stellarprops, '$.physical.Radius_Value') AS REAL)) IS NOT NULL\nAND oc.\"semimajor\" IS NOT NULL AND oc.\"semimajor\" > 0", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Planetary Equilibrium Temperature", "sql_snippet": "(CAST(JSON_EXTRACT(s.stellarprops, '$.physical.Temp_Value') AS REAL)) * SQRT((CAST(JSON_EXTRACT(s.stellarprops, '$.physical.Radius_Value') AS REAL)) * 6.957E8 / (2 * oc.\"semimajor\" * 1.496E11))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "planets_data_19", "selected_database": "planets_data", "amb_user_query": "For how many planets do we have a size measurement, but we know it's just an estimate?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "size measurement", "sql_snippet": "pp.\"radjup\" IS NOT NULL", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "just an estimate", "sql_snippet": "CAST(json_extract(dqt.limitflags, '$.planetary_limits.Rad_Lim') AS INTEGER) = 1", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Upper Limit Value", "sql_snippet": "CAST(json_extract(dqt.limitflags, '$.planetary_limits.Rad_Lim') AS INTEGER) = 1", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 35}]}
{"instance_id": "planets_data_2", "selected_database": "planets_data", "amb_user_query": "I'm looking for Jupiter-like planets that are both scorching hot and spinning backwards.\nCan you list them out for me, along with their names, how long their year is, their orbital tilt, and their speed?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "scorching hot", "sql_snippet": "oc.\"period\" < 10", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "spinning backwards", "sql_snippet": "oc.\"inclination\" >= 90", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "Jupiter-like planets", "sql_snippet": "pp.\"massjup\" > 0.1", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "list them out for me", "sql_snippet": "ORDER BY orbital_velocity_kms DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "their speed", "sql_snippet": "AND CAST(JSON_EXTRACT(s.stellarprops, '$.physical.\"Mass_Value\"') AS REAL) IS NOT NULL\n  AND oc.\"semimajor\" IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Orbital Velocity", "sql_snippet": "(SQRT((6.67430E-11 * CAST(JSON_EXTRACT(s.stellarprops, '$.physical.\"Mass_Value\"') AS REAL) * 1.98847E30) / (oc.\"semimajor\" * 1.496E11)) / 1000)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 11}]}
{"instance_id": "reverse_logistics_1", "selected_database": "reverse_logistics", "amb_user_query": "Show the overall handling cost for each return, based on the major fee components.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "overall handling cost", "sql_snippet": "ROUND(CAST(JSON_EXTRACT(r.return_details, '$.shipping.fee') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.restocking_fee') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.relabeling_cost') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.disposal.disposal_cost') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.repair_costs.repair_estimate') AS REAL), 2) AS trc", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "major fee components", "sql_snippet": "CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.restocking_fee') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.relabeling_cost') AS REAL)", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(JSON_EXTRACT(r.return_details, '$.shipping.fee') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.restocking_fee') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.relabeling_cost') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.disposal.disposal_cost') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.repair_costs.repair_estimate') AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "order", "sql_snippet": "ORDER BY trc DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "reverse_logistics_10", "selected_database": "reverse_logistics", "amb_user_query": "Break down relabeling cost by product category and show the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "relabeling cost", "sql_snippet": "ROUND(AVG(CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.relabeling_cost') AS REAL)),2) AS avg_relabel_cost", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.relabeling_cost') AS REAL)),2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "order", "sql_snippet": "ORDER BY avg_relabel_cost DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "reverse_logistics_11", "selected_database": "reverse_logistics", "amb_user_query": "What's the spend per disposal method?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "spend per disposal method", "sql_snippet": "SUM(CAST(json_extract(fm.cost_breakdown, '$.disposal.disposal_cost') AS REAL)) AS total_disp_cost", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY total_disp_cost DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "disposal method", "sql_snippet": "SELECT json_extract(fm.cost_breakdown, '$.disposal.disposal_method') AS disposal_method", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 23}]}
{"instance_id": "reverse_logistics_12", "selected_database": "reverse_logistics", "amb_user_query": "Which returns look most expensive to fix? Give me the top few.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "expensive to fix", "sql_snippet": "CAST(JSON_EXTRACT(fm.cost_breakdown, '$.repair_costs.repair_estimate') AS REAL) AS repair_estimate", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "top few", "sql_snippet": "LIMIT 5", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY repair_estimate DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "reverse_logistics_13", "selected_database": "reverse_logistics", "amb_user_query": "How much do we usually recover per channel?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "recover", "sql_snippet": "ROUND(AVG(CAST(JSON_EXTRACT(fm.cost_breakdown, '$.valuation.recovery_value') AS REAL)), 2) AS avg_recovery_value", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(CAST(JSON_EXTRACT(fm.cost_breakdown, '$.valuation.recovery_value') AS REAL)),2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "channel", "sql_snippet": "SELECT r.return_channel", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 20}]}
{"instance_id": "reverse_logistics_14", "selected_database": "reverse_logistics", "amb_user_query": "What portion of returns are flagged high-risk fraud?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "portion of returns", "sql_snippet": "SELECT ROUND(\nCAST(SUM(CASE WHEN json_extract(r.return_details, '$.fraud.risk_level') = 'High' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)\n,2) AS pct_high_fraud", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "rounding", "sql_snippet": "ROUND(\nCAST(SUM(CASE WHEN json_extract(r.return_details, '$.fraud.risk_level') = 'High' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)\n,2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "high-risk fraud", "sql_snippet": "json_extract(r.return_details, '$.fraud.risk_level') = 'High'", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 17}]}
{"instance_id": "reverse_logistics_15", "selected_database": "reverse_logistics", "amb_user_query": "Which disposal route release the most amount of carbon dioxide? Show me all the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "amount of carbon dioxide", "sql_snippet": "ROUND(AVG(CAST(json_extract(cost_breakdown, '$.sustainability.carbon_footprint') AS REAL)), 2) AS avg_carbon_fp", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(CAST(json_extract(cost_breakdown, '$.sustainability.carbon_footprint') AS REAL)), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "order", "sql_snippet": "ORDER BY avg_carbon_fp DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "disposal route", "sql_snippet": "SELECT json_extract(cost_breakdown, '$.disposal.disposal_method') AS disposal_method", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 23}]}
{"instance_id": "reverse_logistics_16", "selected_database": "reverse_logistics", "amb_user_query": "Break down warranty states across channels and rank by count.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "warranty states", "sql_snippet": "json_extract(r.return_details, '$.authorization.warranty_status')", "is_mask": true, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY cnt DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "warranty states across channels", "sql_snippet": "COUNT(*) AS cnt", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 20}]}
{"instance_id": "reverse_logistics_17", "selected_database": "reverse_logistics", "amb_user_query": "By refund type, do we end up ahead or behind overall?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "ahead or behind", "sql_snippet": "SUM(CAST(REPLACE(fm.cost_breakdown ->> 'valuation' ->> 'recovery_value', ',', '') AS REAL)) -\nSUM(\nCAST(REPLACE(r.return_details ->> 'shipping' ->> 'fee', ',', '') AS REAL) +\n         CAST(REPLACE(fm.cost_breakdown ->> 'fees' ->> 'restocking_fee', ',', '') AS REAL) +\nCAST(REPLACE(fm.cost_breakdown ->> 'disposal' ->> 'disposal_cost', ',', '') AS REAL)\n) AS rpi", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "refund type", "sql_snippet": "SELECT fm.cost_breakdown ->> 'refund' ->> 'method' AS refundtype", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 24}]}
{"instance_id": "reverse_logistics_18", "selected_database": "reverse_logistics", "amb_user_query": "How pricey is it to scrap items in different states? What about the carbon emission? ", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "items in different states", "sql_snippet": "json_extract(qa.assessment_summary, '$.condition.item_condition')", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "carbon emission", "sql_snippet": "ROUND(AVG(CAST(json_extract(fm.cost_breakdown, '$.sustainability.carbon_footprint') AS REAL)), 2) AS avg_fp", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(CAST(json_extract(fm.cost_breakdown, '$.sustainability.carbon_footprint') AS REAL)), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "different states", "sql_snippet": "ROUND(AVG(CAST(json_extract(fm.cost_breakdown, '$.disposal.disposal_cost') AS REAL)), 2) AS avg_disp_cost", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 23}]}
{"instance_id": "reverse_logistics_19", "selected_database": "reverse_logistics", "amb_user_query": "For non-compliant items, how are we disposing them and at what carbon cost?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "non-compliant items", "sql_snippet": "json_extract(p.product_traceability, '$.compliance.regulatory_compliance') = 'Non-compliant'", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "carbon cost", "sql_snippet": "ROUND(AVG(CAST(json_extract(fm.cost_breakdown, '$.sustainability.carbon_footprint') AS REAL)), 2) AS avg_fp", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(CAST(json_extract(fm.cost_breakdown, '$.sustainability.carbon_footprint') AS REAL)), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "order", "sql_snippet": "ORDER BY non_compliant_cnt DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "how are we disposing", "sql_snippet": "json_extract(fm.cost_breakdown, '$.disposal.disposal_method') AS disposal_method", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 29}]}
{"instance_id": "reverse_logistics_2", "selected_database": "reverse_logistics", "amb_user_query": "Overall, are returns profitable or not? Also show the money in and the money out in different parts.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "profitable or not", "sql_snippet": "ROUND(SUM(CAST(JSON_EXTRACT(fm.cost_breakdown, '$.valuation.recovery_value') AS REAL)) - SUM(CAST(JSON_EXTRACT(r.return_details, '$.shipping.fee') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.restocking_fee') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.fees.relabeling_cost') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.disposal.disposal_cost') AS REAL) + CAST(JSON_EXTRACT(fm.cost_breakdown, '$.repair_costs.repair_estimate') AS REAL)), 2) AS total_rpi", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(SUM(CAST(JSON_EXTRACT(fm.cost_breakdown, '$.valuation.recovery_value') AS REAL)), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "money in", "sql_snippet": "SUM(CAST(JSON_EXTRACT(fm.cost_breakdown, '$.valuation.recovery_value') AS REAL)) AS total_recovery_value", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "reverse_logistics_20", "selected_database": "reverse_logistics", "amb_user_query": "When fraud risk is high and the item comes back by courier? How abnormal is the shipping cost on average?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "abnormal shipping cost", "sql_snippet": "ROUND(AVG(shipfee / NULLIF(avg_channel_fee,0)),2) AS avg_rcci_high_courier", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "fraud risk is high", "sql_snippet": "r.return_channel = 'Courier' AND json_extract(r.return_details, '$.fraud.risk_level')='High'", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "rounding", "sql_snippet": "ROUND(AVG(shipfee / NULLIF(avg_channel_fee,0)),2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "by courier", "sql_snippet": "WHERE r.return_channel = 'Courier'", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 20}]}
{"instance_id": "cold_chain_pharma_compliance_5", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "Count compliance issues for each status type.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "compliance issues", "sql_snippet": "WHERE json_extract(qc_checklist, '$.customs_and_regulatory.regulatory_compliance_status') = 'Non-compliant'", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "status type", "sql_snippet": "json_extract(qc_checklist, '$.gdp_quality.quality_agreement_status') AS agreement_status", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "null status values", "sql_snippet": "WHERE json_extract(qc_checklist, '$.gdp_quality.quality_agreement_status') IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Quality Agreement Status", "sql_snippet": "json_extract(qc_checklist, '$.gdp_quality.quality_agreement_status')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 14}]}
{"instance_id": "cold_chain_pharma_compliance_6", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "Find problematic shipments and show their key metrics", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "problematic shipments", "sql_snippet": "WHERE ((1 - (ted_min / total_duration_min)) * 100) < 95", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "key metrics", "sql_snippet": "reckey AS shipment_id, ROUND((1 - (ted_min / total_duration_min)) * 100, 2) AS tirp_percentage, ted_min AS total_excursion_duration_min", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "precision", "sql_snippet": "ROUND((1 - (ted_min / total_duration_min)) * 100, 2)", "is_mask": true, "type": "decimal_ambiguity"}, {"term": "null_values", "sql_snippet": "WHERE CAST(json_extract(s.shipment_overview, '$.timing_performance.actual_duration_hrs') AS REAL) > 0 AND CAST(json_extract(e.env_metrics, '$.temperature.excursion_duration_min') AS REAL) IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Quality Risk Zones", "sql_snippet": "ted_min > 60", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 27}]}
{"instance_id": "cold_chain_pharma_compliance_8", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "Find mismatched route risk classifications based on real data", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "mismatched route risk classifications", "sql_snippet": "HAVING documented_risk != calculated_risk", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Route Risk Classification", "sql_snippet": "CASE WHEN excursion_count <= 1 THEN 'low' WHEN excursion_count BETWEEN 2 AND 4 THEN 'medium' WHEN excursion_count >= 5 THEN 'high' END", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
{"instance_id": "cold_chain_pharma_compliance_9", "selected_database": "cold_chain_pharma_compliance", "amb_user_query": "Group our shipments by approximate risk levels using TIRP and total excursion time. Which group is the largest?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "risk levels", "sql_snippet": "CASE WHEN TIRP > 98 AND excursion_duration <= 30 THEN 'Green Zone' WHEN TIRP BETWEEN 95 AND 98 OR excursion_duration BETWEEN 30 AND 60 THEN 'Yellow Zone' WHEN TIRP < 95 OR excursion_duration > 60 THEN 'Red Zone' ELSE 'Unknown' END", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "round percentages", "sql_snippet": "ROUND(CAST(COUNT(*) AS REAL) * 100.0 / (SELECT COUNT(*) FROM risk_zones), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "all shipments", "sql_snippet": "WHERE ... IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Time In Range Percentage (TIRP)", "sql_snippet": "( (CAST(json_extract(s.shipment_overview, '$.timing_performance.actual_duration_hrs') AS REAL) * 60) - CAST(json_extract(em.env_metrics, '$.temperature.excursion_duration_min') AS REAL) ) * 100.0 / NULLIF(CAST(json_extract(s.shipment_overview, '$.timing_performance.actual_duration_hrs') AS REAL) * 60, 0)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 25}, {"term": "Approximate Risk Zoning by Total Excursion Time", "sql_snippet": "CASE WHEN TIRP > 98 AND excursion_duration <= 30 THEN 'Green Zone' WHEN TIRP BETWEEN 95 AND 98 OR excursion_duration BETWEEN 30 AND 60 THEN 'Yellow Zone' WHEN TIRP < 95 OR excursion_duration > 60 THEN 'Red Zone' ELSE 'Unknown' END", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 27}]}
{"instance_id": "exchange_traded_funds_16", "selected_database": "exchange_traded_funds", "amb_user_query": "Find the max secure income score.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "secure income score", "sql_snippet": "(fy.yter * bq.high_quality_pct) AS sies_score", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "handle division by zero", "sql_snippet": "NULLIF(CAST(json_extract(fundmetrics, '$.Expense_Net') AS REAL), 0)", "is_mask": false, "type": "divide_zero_ambiguity"}]}, "knowledge_ambiguity": [{"term": "High-Quality Credit Portfolio", "sql_snippet": "SUM(CASE WHEN r.creditmark IN ('us_government', 'aaa', 'aa') THEN b.allocationpct ELSE 0 END)", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 19}]}
{"instance_id": "exchange_traded_funds_18", "selected_database": "exchange_traded_funds", "amb_user_query": "How many value funds are there?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "value funds", "sql_snippet": "WHERE\n        (\n            (\n                ((CAST(json_extract(p.pricerange52w, '$.high_metrics.High_52W') AS REAL) +\n                 CAST(json_extract(p.pricerange52w, '$.high_metrics.High_Delta') AS REAL)) -\n                CAST(json_extract(p.pricerange52w, '$.low_metrics.Low_52W') AS REAL))\n            ) / NULLIF(CAST(json_extract(p.pricerange52w, '$.range_metrics.Range_Move') AS REAL), 0)\n        ) * 100 < 25\n        AND CAST(json_extract(f.fundmetrics, '$.Turnover_Ratio') AS REAL) < 30\n        AND (CAST(json_extract(f.fundmetrics, '$.Expense_Net') AS REAL) - CAST(json_extract(f.fundmetrics, '$.Benchmark_Exp') AS REAL)) < 0", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "handle null in price range", "sql_snippet": "NULLIF(CAST(json_extract(p.pricerange52w, '$.range_metrics.Range_Move') AS REAL), 0)", "is_mask": false, "type": "divide_zero_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Low-Turnover Strategy", "sql_snippet": "CAST(json_extract(f.fundmetrics, '$.Turnover_Ratio') AS REAL) < 30", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 12}]}
{"instance_id": "exchange_traded_funds_20", "selected_database": "exchange_traded_funds", "amb_user_query": "What are the total excess fees for all closet funds?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "closet funds", "sql_snippet": "WHERE is_market_tracker AND relative_expense > 0", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "excess fees", "sql_snippet": "(relative_expense * net_worth) AS wasted_fee_amount", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "rounding", "sql_snippet": "ROUND(SUM(wasted_fee_amount), 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Relative Expense Ratio", "sql_snippet": "CAST(json_extract(f.fundmetrics, '$.Expense_Net') AS REAL) - CAST(json_extract(f.fundmetrics, '$.Benchmark_Exp') AS REAL) AS relative_expense", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 1}]}
{"instance_id": "exchange_traded_funds_4", "selected_database": "exchange_traded_funds", "amb_user_query": "I want to find funds that are good in different markets. Show me how they do when the market is up versus down. Also show the difference. Only show funds with enough history.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "how they do", "sql_snippet": "fundperf - categoryperf AS outperformance", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "market is up versus down", "sql_snippet": "CASE WHEN categoryperf > 0 THEN 'up_year' ELSE 'down_year' END as year_type", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "difference", "sql_snippet": "(AVG(CASE WHEN year_type = 'up_year' THEN outperformance ELSE NULL END)) - (AVG(CASE WHEN year_type = 'down_year' THEN outperformance ELSE NULL END))", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "enough history", "sql_snippet": "HAVING COUNT(CASE WHEN year_type = 'up_year' THEN 1 ELSE NULL END) >= 3 AND COUNT(CASE WHEN year_type = 'down_year' THEN 1 ELSE NULL END) >= 3", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "output fields", "sql_snippet": "SELECT portfolioref, ROUND(AVG(CASE WHEN year_type = 'up_year' THEN outperformance ELSE NULL END), 6) AS avg_upside_outperformance, ROUND(AVG(CASE WHEN year_type = 'down_year' THEN outperformance ELSE NULL END), 6) AS avg_downside_outperformance, ROUND((AVG(CASE WHEN year_type = 'up_year' THEN outperformance ELSE NULL END)) - (AVG(CASE WHEN year_type = 'down_year' THEN outperformance ELSE NULL END)), 6) AS capture_differential", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort order", "sql_snippet": "ORDER BY capture_differential DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal precision", "sql_snippet": "ROUND(AVG(CASE WHEN year_type = 'up_year' THEN outperformance ELSE NULL END), 6)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Average Upside Outperformance", "sql_snippet": "AVG(CASE WHEN year_type = 'up_year' THEN outperformance ELSE NULL END)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 73}, {"term": "Average Downside Outperformance", "sql_snippet": "AVG(CASE WHEN year_type = 'down_year' THEN outperformance ELSE NULL END)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 74}]}
{"instance_id": "exchange_traded_funds_5", "selected_database": "exchange_traded_funds", "amb_user_query": "I'm worried some funds might be hard to trade. Can you find the ones with the highest liquidity pressure? I need to see some info for those funds.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "liquidity pressure", "sql_snippet": "(CAST(json_extract(f.fundmetrics, '$.Net_Worth') AS INTEGER) * CAST(json_extract(f.fundmetrics, '$.Turnover_Ratio') AS REAL)) /\n        NULLIF(\n            (CAST(json_extract(f.tradingdata, '$.volume_metrics.Vol_3M') AS REAL) *\n             252),\n            0\n        )", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "highest", "sql_snippet": "LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}, {"term": "some info", "sql_snippet": "SELECT\n    f.tickersym,\n    CAST(json_extract(f.fundmetrics, '$.Net_Worth') AS INTEGER) AS networth,\n    ROUND(CAST(json_extract(f.fundmetrics, '$.Turnover_Ratio') AS REAL), 2) AS turnoverratio,\n    -- Formula for Portfolio Liquidity Pressure (KB ID: 58) in days\n    -- (Assets to be Traded Annually) / (Average Daily Value Traded)\n    ROUND(\n        (CAST(json_extract(f.fundmetrics, '$.Net_Worth') AS INTEGER) * CAST(json_extract(f.fundmetrics, '$.Turnover_Ratio') AS REAL)) /\n        NULLIF(\n            (CAST(json_extract(f.tradingdata, '$.volume_metrics.Vol_3M') AS REAL) *\n             252),\n            0\n        ),\n        2\n    ) AS liquidity_pressure_days", "is_mask": true, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY liquidity_pressure_days DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal places", "sql_snippet": "ROUND(..., 2)", "is_mask": true, "type": "decimal_ambiguity"}, {"term": "divide by zero", "sql_snippet": "NULLIF(\n            (CAST(json_extract(f.tradingdata, '$.volume_metrics.Vol_3M') AS REAL) *\n             252),\n            0\n        )", "is_mask": false, "type": "divide_zero_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Average Daily Value Traded (3M)", "sql_snippet": "(CAST(json_extract(f.tradingdata, '$.volume_metrics.Vol_3M') AS REAL) * 252)", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 76}]}
{"instance_id": "exchange_traded_funds_9", "selected_database": "exchange_traded_funds", "amb_user_query": "I'm looking for some bargain-bin funds that might be ready for a comeback. Can you find funds that are currently beaten down and are managed with a patient, cheap strategy? Show me some info for these funds.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "beaten down", "sql_snippet": "fc.price_range_position < 25", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "patient", "sql_snippet": "CAST(json_extract(fc.fundmetrics, '$.Turnover_Ratio') AS REAL) < 30", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "cheap", "sql_snippet": "CAST(json_extract(fc.fundmetrics, '$.Expense_Net') AS REAL) < CAST(json_extract(fc.fundmetrics, '$.Benchmark_Exp') AS REAL)", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "some info", "sql_snippet": "SELECT\n    fc.productref,\n    f.shortlabel,\n    fc.price_range_position", "is_mask": false, "type": "intent_ambiguity"}, {"term": "number of results", "sql_snippet": "LIMIT 100", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort order", "sql_snippet": "ORDER BY price_range_position ASC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal places", "sql_snippet": "ROUND(..., 8)", "is_mask": true, "type": "decimal_ambiguity"}, {"term": "division by zero", "sql_snippet": "NULLIF(\n                (CAST(json_extract(p.pricerange52w, '$.high_metrics.High_52W') AS REAL) -\n                 CAST(json_extract(p.pricerange52w, '$.low_metrics.Low_52W') AS REAL)),\n                0\n            )", "is_mask": false, "type": "divide_zero_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Contrarian Value Play", "sql_snippet": "WHERE\n    fc.price_range_position < 25\n    AND json_type(json_extract(fc.fundmetrics, '$.Turnover_Ratio')) IN ('integer', 'real') AND CAST(json_extract(fc.fundmetrics, '$.Turnover_Ratio') AS REAL) < 30\n    AND CAST(json_extract(fc.fundmetrics, '$.Expense_Net') AS REAL) < CAST(json_extract(fc.fundmetrics, '$.Benchmark_Exp') AS REAL)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 47}]}
{"instance_id": "households_3", "selected_database": "households", "amb_user_query": "Give me the IDs of families that are both receiving aid and have a lot of vehicles.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "receiving aid", "sql_snippet": "s.socsupport = 'Yes'", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "have a lot of vehicles", "sql_snippet": "(COALESCE(CAST(json_extract(t.vehicleinventory, '$.vehicle_counts.Auto_Count') AS INTEGER), 0) + COALESCE(CAST(json_extract(t.vehicleinventory, '$.vehicle_counts.Bike_Count') AS INTEGER), 0) + COALESCE(CAST(json_extract(t.vehicleinventory, '$.vehicle_counts.Motor_Count') AS INTEGER), 0)) > 2 AND (json_extract(t.vehicleinventory, '$.Newest_Year') IN ('2010 to 2013', '2012 To 2013', '2014 or newer'))", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Mobile Household", "sql_snippet": "(COALESCE(CAST(json_extract(t.vehicleinventory, '$.vehicle_counts.Auto_Count') AS INTEGER), 0) + COALESCE(CAST(json_extract(t.vehicleinventory, '$.vehicle_counts.Bike_Count') AS INTEGER), 0) + COALESCE(CAST(json_extract(t.vehicleinventory, '$.vehicle_counts.Motor_Count') AS INTEGER), 0)) > 2 AND (json_extract(t.vehicleinventory, '$.Newest_Year') IN ('2010 to 2013', '2012 To 2013', '2014 or newer'))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 23}]}
{"instance_id": "households_4", "selected_database": "households", "amb_user_query": "How many apartments qualify for the Space Bonus with more than 20 square meters per resident?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Space Bonus", "sql_snippet": "((COALESCE(CAST(json_extract(p.dwelling_specs, '$.Bath_Count') AS REAL), 0) * 10 + COALESCE(CAST(json_extract(p.dwelling_specs, '$.Room_Count') AS REAL), 0) * 15) / NULLIF(h.residentcount, 0)) > 20", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "roomy apartments", "sql_snippet": "LOWER(json_extract(p.dwelling_specs, '$.Dwelling_Class')) = 'apartment'", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "square meters per resident", "sql_snippet": "(COALESCE(CAST(json_extract(p.dwelling_specs, '$.Bath_Count') AS REAL), 0) * 10 + COALESCE(CAST(json_extract(p.dwelling_specs, '$.Room_Count') AS REAL), 0) * 15) / NULLIF(h.residentcount, 0)", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Space Bonus", "sql_snippet": "((COALESCE(CAST(json_extract(p.dwelling_specs, '$.Bath_Count') AS REAL), 0) * 10 + COALESCE(CAST(json_extract(p.dwelling_specs, '$.Room_Count') AS REAL), 0) * 15) / NULLIF(h.residentcount, 0)) > 20", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 29}]}
{"instance_id": "households_5", "selected_database": "households", "amb_user_query": "Show me a list of our most well-off, largest households.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "well-off", "sql_snippet": "WHERE (json_extract(h.socioeconomic, '$.Income_Bracket') IN ('More than R$ 4,400', 'More than R$ 2,640 and less than R$ 4,400')) AND (UPPER(json_extract(h.socioeconomic, '$.Tenure_Type')) = 'OWNED')", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "largest households", "sql_snippet": "ORDER BY h.residentcount DESC", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Affluent Household", "sql_snippet": "(json_extract(h.socioeconomic, '$.Income_Bracket') IN ('More than R$ 4,400', 'More than R$ 2,640 and less than R$ 4,400')) AND (UPPER(json_extract(h.socioeconomic, '$.Tenure_Type')) = 'OWNED')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 21}]}
{"instance_id": "households_6", "selected_database": "households", "amb_user_query": "For all households in Taguatinga area, calculate their crowding metric. List the household ID and its metric, sorted from highest to lowest. Only include households with some bedrooms.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Taguatinga area", "sql_snippet": "WHERE h.locregion = 'Taguatinga'", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "crowding metric", "sql_snippet": "(h.residentcount / NULLIF(CAST(JSON_EXTRACT(p.dwelling_specs, '$.Room_Count') AS REAL), 0)) AS density", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "some bedrooms", "sql_snippet": "AND CAST(JSON_EXTRACT(p.dwelling_specs, '$.Room_Count') AS REAL) > 0", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "sorted", "sql_snippet": "ORDER BY density DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Household Density", "sql_snippet": "(h.residentcount / NULLIF(CAST(JSON_EXTRACT(p.dwelling_specs, '$.Room_Count') AS REAL), 0)) AS density", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 11}]}
{"instance_id": "households_7", "selected_database": "households", "amb_user_query": "Could you give me a count of all the packed houses in our prime locations?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "packed houses", "sql_snippet": "(h.residentcount / NULLIF(CAST(json_extract(p.dwelling_specs, '$.Room_Count') AS REAL), 0)) > 2", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "prime locations", "sql_snippet": "LOWER(i.wateraccess) IN ('yes', 'available at least in one room') AND LOWER(i.roadsurface) IN ('asphalt', 'concrete')", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Urban Household", "sql_snippet": "LOWER(i.wateraccess) IN ('yes', 'available at least in one room') AND LOWER(i.roadsurface) IN ('asphalt', 'concrete')", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 22}]}
{"instance_id": "hulushows_18", "selected_database": "hulushows", "amb_user_query": "Id like to group the shows by how people rated them, like maybe poor, okay, or good, based on their overall scores. Show me each shows ID, name, rating value, and which category it goes into.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "poor, okay, or good", "sql_snippet": "CASE WHEN userscore < 3.5 THEN 'Low' WHEN userscore BETWEEN 3.5 AND 4.2 THEN 'Medium' ELSE 'High' END AS rating_band", "is_mask": false, "type": "lexical_ambiguity"}, {"term": "overall scores", "sql_snippet": "CAST(json_extract(c.genreclass, '$.userscore') AS REAL) AS userscore", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "category it goes into", "sql_snippet": "CASE WHEN userscore < 3.5 THEN 'Low' WHEN userscore BETWEEN 3.5 AND 4.2 THEN 'Medium' ELSE 'High' END AS rating_band", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY userscore DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Episode Rating Band", "sql_snippet": "CASE WHEN userscore < 3.5 THEN 'Low' WHEN userscore BETWEEN 3.5 AND 4.2 THEN 'Medium' ELSE 'High' END AS rating_band", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 78}]}
{"instance_id": "hulushows_3", "selected_database": "hulushows", "amb_user_query": "What's the top rating among entries with barely any visuals but still have ratings?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "barely any visuals", "sql_snippet": "CAST(json_extract(mediacounts, '$.content_volumes.Film_Clips') AS INTEGER) = 0 AND CAST(json_extract(mediacounts, '$.content_volumes.Clips_Total') AS INTEGER) = 0", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "ratings", "sql_snippet": "json_extract(genreclass, '$.User_Score') IS NOT NULL", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Highly Rated but Visually Empty", "sql_snippet": "WHERE CAST(json_extract(mediacounts, '$.content_volumes.Film_Clips') AS INTEGER) = 0 AND CAST(json_extract(mediacounts, '$.content_volumes.Clips_Total') AS INTEGER) = 0 AND json_extract(genreclass, '$.User_Score') IS NOT NULL", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 70}]}
{"instance_id": "hulushows_5", "selected_database": "hulushows", "amb_user_query": "I want the count of shows that are tagged with lots of genre labels and have way more short clips (including general clips and film-related clips) than longer ones.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "lots of genre labels", "sql_snippet": "CASE WHEN COALESCE(json_extract(genreclass, '$.Hierarchical_Genres'), '') = '' THEN 0 ELSE (LENGTH(COALESCE(json_extract(genreclass, '$.Hierarchical_Genres'), '')) - LENGTH(REPLACE(REPLACE(COALESCE(json_extract(genreclass, '$.Hierarchical_Genres'), ''), '~', ''), '|', ''))) + 1 END > 6", "is_mask": true, "type": "semantic_ambiguity"}, {"term": "short clips (including general clips and film-related clips)", "sql_snippet": "COALESCE(CAST(NULLIF(json_extract(mediacounts, '$.content_volumes.Clips_Total'), '') AS INTEGER), 0) + COALESCE(CAST(NULLIF(json_extract(mediacounts, '$.content_volumes.Film_Clips'), '') AS INTEGER), 0)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "longer ones", "sql_snippet": "COALESCE(CAST(NULLIF(json_extract(mediacounts, '$.content_volumes.Feature_Films'), '') AS INTEGER), 0)", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Genre Hierarchy Format", "sql_snippet": "CASE WHEN COALESCE(json_extract(genreclass, '$.Hierarchical_Genres'), '') = '' THEN 0 ELSE (LENGTH(COALESCE(json_extract(genreclass, '$.Hierarchical_Genres'), '')) - LENGTH(REPLACE(REPLACE(COALESCE(json_extract(genreclass, '$.Hierarchical_Genres'), ''), '~', ''), '|', ''))) + 1 END", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 6}]}
{"instance_id": "hulushows_6", "selected_database": "hulushows", "amb_user_query": "Give me all content series that have more than one entry, and show how many items they have and what they're called.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "content series", "sql_snippet": "GROUP BY series_id", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "items", "sql_snippet": "COUNT(*) AS show_count", "is_mask": false, "type": "intent_ambiguity"}, {"term": "called", "sql_snippet": "GROUP_CONCAT(content_title, ', ') AS titles_in_franchise", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY show_count DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Franchise Group", "sql_snippet": "GROUP BY series_id HAVING COUNT(*) >= 2", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 13}]}
{"instance_id": "hulushows_7", "selected_database": "hulushows", "amb_user_query": "List all shows and their average episode-to-season numbers. Only include those that have both episode and season values. Skip those with missing or zero seasons.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "average episode-to-season numbers", "sql_snippet": "ROUND(CAST(json_extract(mediacounts, '$.content_volumes.Episode_Total') AS REAL) / CAST(json_extract(mediacounts, '$.content_volumes.Seasons_Total') AS REAL), 2)", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "shows", "sql_snippet": "SELECT content_key", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY season_to_episode_ratio DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "decimal", "sql_snippet": "ROUND(..., 2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Season to Episode Ratio", "sql_snippet": "ROUND(CAST(json_extract(mediacounts, '$.content_volumes.Episode_Total') AS REAL) / CAST(json_extract(mediacounts, '$.content_volumes.Seasons_Total') AS REAL), 2)", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 23}]}
{"instance_id": "hulushows_9", "selected_database": "hulushows", "amb_user_query": "Can you generate a Franchise Summary showing all groups with a decent number of episodes? For each, give the ID, the number of entries in that group, and how many episodes they collectively have.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "Franchise Summary", "sql_snippet": "c.series_id", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "decent number", "sql_snippet": "WHERE total_episodes > 100", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "entries", "sql_snippet": "COUNT(*) AS total_shows", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY total_episodes DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Franchise Engagement Summary", "sql_snippet": "SELECT c.series_id, COUNT(*) AS total_shows, SUM(CAST(json_extract(ci.mediacounts, '$.content_volumes.Episode_Total') AS INTEGER)) AS total_episodes", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 72}]}
{"instance_id": "labor_certification_applications_1", "selected_database": "labor_certification_applications", "amb_user_query": "What's the average time for approved visa applications for each visa type?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "time", "sql_snippet": "AVG(julianday(c.decisionday) - julianday(REPLACE(c.recvday, '/', '-')))", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "approved", "sql_snippet": "LOWER(c.statustag) LIKE 'certified%'", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY average_processing_time_days DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null dates", "sql_snippet": "c.decisionday IS NOT NULL AND c.recvday IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Application Processing Time (APT)", "sql_snippet": "AVG(julianday(c.decisionday) - julianday(REPLACE(c.recvday, '/', '-')))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 12}]}
{"instance_id": "labor_certification_applications_11", "selected_database": "labor_certification_applications", "amb_user_query": "I need a report about the timing of visa applications. Group applications into categories and show the count and proportion for each category. Sort the results by importance.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "categories", "sql_snippet": "CASE WHEN months_before_start < 0 THEN 'After Start Date' WHEN months_before_start = 0 THEN 'Same Month' WHEN months_before_start BETWEEN 1 AND 3 THEN '1-3 Months Before' WHEN months_before_start BETWEEN 4 AND 6 THEN 'Optimal Window (4-6 Months)' ELSE 'Early Filing (>6 Months)' END AS filing_time_category", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "proportion", "sql_snippet": "ROUND((CAST(COUNT(*) AS REAL) / SUM(COUNT(*)) OVER ()) * 100, 2) AS percentage", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Visa Filing Window", "sql_snippet": "CASE WHEN months_before_start < 0 THEN 'After Start Date' WHEN months_before_start = 0 THEN 'Same Month' WHEN months_before_start BETWEEN 1 AND 3 THEN '1-3 Months Before' WHEN months_before_start BETWEEN 4 AND 6 THEN 'Optimal Window (4-6 Months)' ELSE 'Early Filing (>6 Months)' END AS filing_time_category", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 41}]}
{"instance_id": "labor_certification_applications_14", "selected_database": "labor_certification_applications", "amb_user_query": "Find out which sectors are heavily dependent on foreign workers. Show industry code, application numbers and percentage.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "heavily dependent", "sql_snippet": "HAVING (CAST(COUNT(c.filekey) AS REAL) / (SELECT COUNT(*) FROM cases)) * 100 > 15", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "industry code", "sql_snippet": "json_extract(e.employer_contact_info, '$.naics_code') AS naics_code", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal places", "sql_snippet": "ROUND((CAST(COUNT(c.filekey) AS REAL) / (SELECT COUNT(*) FROM cases)) * 100, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort order", "sql_snippet": "ORDER BY industry_percentage DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "null values", "sql_snippet": "WHERE json_extract(e.employer_contact_info, '$.naics_code') IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Industry Application Distribution", "sql_snippet": "ROUND((CAST(COUNT(c.filekey) AS REAL) / (SELECT COUNT(*) FROM cases)) * 100, 2) AS industry_percentage", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 20}]}
{"instance_id": "labor_certification_applications_3", "selected_database": "labor_certification_applications", "amb_user_query": "Show me the relationship between an employer's size and their approval rate. Group employers by their size and show the results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "approval rate", "sql_snippet": "(CAST(certified_applications AS REAL) / total_applications) * 100", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "show the results", "sql_snippet": "SELECT employer_size_category, COUNT(DISTINCT employer_name) AS number_of_employers_in_category, AVG(...) AS average_success_rate_percentage", "is_mask": false, "type": "intent_ambiguity"}, {"term": "approved", "sql_snippet": "SUM(CASE WHEN statustag LIKE 'Certified%' THEN 1 ELSE 0 END)", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY average_success_rate_percentage DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "distinct employers", "sql_snippet": "COUNT(DISTINCT employer_name)", "is_mask": false, "type": "distinct_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Application Success Rate (ASR)", "sql_snippet": "AVG((CAST(certified_applications AS REAL) / total_applications) * 100)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 18}]}
{"instance_id": "labor_certification_applications_4", "selected_database": "labor_certification_applications", "amb_user_query": "Show me the top occupations for approved H-1B visas.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "approved", "sql_snippet": "LOWER(TRIM(c.statustag)) LIKE 'certified%'", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "top occupations", "sql_snippet": "COUNT(*) AS number_of_certified_h1b_applications", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY\n    number_of_certified_h1b_applications DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "top", "sql_snippet": "LIMIT 5", "is_mask": false, "type": "rank_ambiguity"}]}, "knowledge_ambiguity": [{"term": "occupations", "sql_snippet": "SELECT\n    c.socTitle AS job_soc_title,\n    COUNT(*) AS number_of_certified_h1b_applications", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "labor_certification_applications_6", "selected_database": "labor_certification_applications", "amb_user_query": "I need to find out compensation for tech jobs. Show me how many positions pay well compared to what's expected. Just focus on yearly payments.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "tech jobs", "sql_snippet": "CAST(JSON_EXTRACT(e.employer_contact_info, '$.naics_code') AS TEXT) = '541511'", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "pay well", "sql_snippet": "(offered_wage_from - prevailing_wage_value) / prevailing_wage_value * 100 > 20", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "null values", "sql_snippet": "AND JSON_EXTRACT(pw.wage_details, '$.prevailing_wage.value') IS NOT NULL\n        AND JSON_EXTRACT(pw.wage_details, '$.offered_wage.from') IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Premium Wage Position", "sql_snippet": "(offered_wage_from - prevailing_wage_value) / prevailing_wage_value * 100 > 20", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 40}]}
{"instance_id": "labor_certification_applications_7", "selected_database": "labor_certification_applications", "amb_user_query": "I want to find lawyers who are good with Australian visa cases. How many attorneys have mostly Australian cases and high approval rates?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "good", "sql_snippet": "success_rate > 0.95", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "mostly", "sql_snippet": "(CAST(e3_cases AS REAL) / total_cases) > 0.50", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "approval rates", "sql_snippet": "AVG(CASE WHEN cs.statustag LIKE 'Certified%' THEN 1 ELSE 0 END) AS success_rate", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Attorney Performance Rating", "sql_snippet": "ap.success_rate > 0.95", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 52}]}
{"instance_id": "organ_transplant_17", "selected_database": "organ_transplant", "amb_user_query": "I want to figure out which transport method is the most efficient. Can you come up with a logistical efficiency ratio for every completed transplant? Just divide the total time the organ was on ice by the distance it traveled. Then, for each transport type, I want to see the average, best, and worst efficiency ratio. Ignore any really short trips. Sort the list by the average efficiency.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "total time the organ was on ice", "sql_snippet": "(CAST(fr.org_isch_time AS REAL) + CAST(cm.exp_time AS REAL))", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "really short trips", "sql_snippet": "WHERE distance_km >= 10", "is_mask": false, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "average efficiency ratio", "sql_snippet": "ROUND(AVG(total_ischemia_time / distance_km), 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "Sort the list", "sql_snippet": "ORDER BY avg_efficiency_ratio ASC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Total Ischemia Time", "sql_snippet": "(CAST(fr.org_isch_time AS REAL) + CAST(cm.exp_time AS REAL))", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "organ_transplant_4", "selected_database": "organ_transplant", "amb_user_query": "Let's see how often we find a perfect match within and between different ethnic groups. First, you need to identify every ideal match we have. Once you have that list, I want a table that shows the donor's ethnicity down the side and the recipient's ethnicity across the top, with the cells showing the count of how many times each combination happened.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "ideal match", "sql_snippet": "WHERE\n        -- Criterion 1: ABO Blood Type Compatibility\n        (CASE \n            WHEN r.blood_class LIKE 'AB%' THEN 1\n            WHEN r.blood_class LIKE 'A%' AND d.blood_class IN ('A', 'O') THEN 1\n            WHEN r.blood_class LIKE 'B%' AND d.blood_class IN ('B', 'O') THEN 1\n            WHEN r.blood_class LIKE 'O%' AND d.blood_class = 'O' THEN 1\n            ELSE 0\n        END) = 1\n    AND\n        -- Criterion 2: HLA Mismatch Score of 0\n        cm.hla_mis_count = 0\n    AND\n        -- Criterion 3: Size Compatibility Score in [0.9, 1.1]\n        (1 - ABS((CAST(json_extract(d.physicalstats, '$.Bmi_Value') AS REAL) / r.bmi_val) - 1)) BETWEEN 0.9 AND 1.1", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "ethnicity", "sql_snippet": "json_extract(d.physicalstats, '$.Ethnicity') AS donor_ethnicity,\n        r.ethn_grp AS recipient_ethnicity", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "list", "sql_snippet": "ORDER BY donor_ethnicity", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Optimal Donor-Recipient Match", "sql_snippet": "WHERE\n        -- Criterion 1: ABO Blood Type Compatibility\n        (CASE \n            WHEN r.blood_class LIKE 'AB%' THEN 1\n            WHEN r.blood_class LIKE 'A%' AND d.blood_class IN ('A', 'O') THEN 1\n            WHEN r.blood_class LIKE 'B%' AND d.blood_class IN ('B', 'O') THEN 1\n            WHEN r.blood_class LIKE 'O%' AND d.blood_class = 'O' THEN 1\n            ELSE 0\n        END) = 1\n    AND\n        -- Criterion 2: HLA Mismatch Score of 0\n        cm.hla_mis_count = 0\n    AND\n        -- Criterion 3: Size Compatibility Score in [0.9, 1.1]\n        (1 - ABS((CAST(json_extract(d.physicalstats, '$.Bmi_Value') AS REAL) / r.bmi_val) - 1)) BETWEEN 0.9 AND 1.1", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 31}]}
{"instance_id": "organ_transplant_6", "selected_database": "organ_transplant", "amb_user_query": "Let's check our CMV exposure risk. I want a list of all current and completed transplants with a CMV mismatch. For each of these risky cases, show me the match ID and the transplant center. I also want to see the patient's infection risk score and, right next to it, the average infection risk for all the other transplants done at that same hospital. Please order the results by the hospital's ID.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "CMV mismatch", "sql_snippet": "WHERE td.donor_cmv_status = 'Positive' AND td.recipient_cmv_status = 'Negative'", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "other transplants", "sql_snippet": "WHERE NOT (donor_cmv_status = 'Positive' AND recipient_cmv_status = 'Negative')", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "average infection risk", "sql_snippet": "ROUND(CAST(ca.avg_risk_no_mismatch AS REAL), 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "order the results", "sql_snippet": "ORDER BY td.center_id, mismatch_infection_risk DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Viral Infection Status", "sql_snippet": "json_extract(mh.viralstatinfo, '$.Cmv_State') AS donor_cmv_status,\n        ri.cmv_state AS recipient_cmv_status", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 39}]}
{"instance_id": "organ_transplant_7", "selected_database": "organ_transplant", "amb_user_query": "I need a list of our sickest patientsthe ones on advanced life support. For each of these patients, show me their ID and what kind of life support they're on. Then, calculate their full urgency score. The crucial part is, I want to see their score next to the average score for all the other patients who are waiting for the same organ. Group the list by organ, and show the sickest patients first within each group.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "advanced life support", "sql_snippet": "WHERE ud.life_support IN ('ECMO', 'VAD')", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "other patients", "sql_snippet": "WHERE life_support IS NULL OR life_support NOT IN ('ECMO', 'VAD')", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "their score", "sql_snippet": "ROUND(ud.patient_urgency_score, 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "Group the list by organ", "sql_snippet": "ORDER BY ud.org_spec, critical_patient_urgency_score DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Patient Urgency Score", "sql_snippet": "(0.7 * CASE c.med_urgency WHEN 'Status 1A' THEN 5 WHEN 'Status 1B' THEN 4 ELSE 2 END) + \n        (0.3 * (CAST(c.wait_time AS REAL) / 365.0))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 14}]}
{"instance_id": "organ_transplant_8", "selected_database": "organ_transplant", "amb_user_query": "I'm wondering if how we ship organs really makes a difference. Can you run some numbers for me? Let's look at all our finished transplants. Group them by how the organ was transported. For each of those transport types, I want to see the average ischemia time and the average graft survival score. Sort the results so I can see which transport methods are linked with the best outcomes.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "ischemia time", "sql_snippet": "(CAST(fr.org_isch_time AS REAL) + CAST(cm.exp_time AS REAL))", "is_mask": false, "type": "knowledge_linking_ambiguity"}, {"term": "graft survival score", "sql_snippet": "re.egs_val", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "average ischemia time", "sql_snippet": "ROUND(CAST(AVG(total_ischemia_time) AS REAL), 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "Sort the results", "sql_snippet": "ORDER BY avg_egs_score DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Total Ischemia Time", "sql_snippet": "(CAST(fr.org_isch_time AS REAL) + CAST(cm.exp_time AS REAL))", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 2}]}
{"instance_id": "organ_transplant_9", "selected_database": "organ_transplant", "amb_user_query": "I want to know what the most common health problems our patients have and if those problems make surgery riskier. Can you go through all the patient files, find the top 5 most common ones? Then, for each of those top 5, figure out the average risk score for all patients who have that specific condition. I want to see the condition, how many people have it, and what the average risk score is.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "health problems", "sql_snippet": "TRIM(SUBSTR(c.comorbid_detail, 1, INSTR(c.comorbid_detail || ',', ',') - 1))", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "risk score", "sql_snippet": "re.surg_risk_val", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "average risk score", "sql_snippet": "ROUND(CAST(AVG(rc.surg_risk_val) AS REAL), 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "top 5 most common ones", "sql_snippet": "ORDER BY tc.occurrence_count DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Surgical Risk Score", "sql_snippet": "re.surg_risk_val", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 16}]}
{"instance_id": "planets_data_4", "selected_database": "planets_data", "amb_user_query": "Let's fact-check Kepler's law on systems with multiple planets.\nFor each of these systems, take a planet and use its orbit to calculate its star's mass.\nShow me the star's name, its official mass, and the mass we just calculated.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "multiple planets", "sql_snippet": "WHERE s.\"compcount\" > 1", "is_mask": false, "type": "semantic_ambiguity"}, {"term": "take a planet", "sql_snippet": "MAX(oc.\"semimajor\") as max_semimajor", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "show me", "sql_snippet": "ORDER BY ABS(CAST(json_extract(s.stellarprops, '$.physical.Mass_Value') AS REAL) - (oc.\"semimajor\" * oc.\"semimajor\" * oc.\"semimajor\" / ((oc.\"period\" / 365.25) * (oc.\"period\" / 365.25))))", "is_mask": false, "type": "sort_ambiguity"}, {"term": "use its orbit", "sql_snippet": "WHERE oc.\"period\" IS NOT NULL AND oc.\"period\" > 0", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Kepler's Third Law Verification", "sql_snippet": "(oc.\"semimajor\" * oc.\"semimajor\" * oc.\"semimajor\" / ((oc.\"period\" / 365.25) * (oc.\"period\" / 365.25)))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 15}]}
{"instance_id": "planets_data_5", "selected_database": "planets_data", "amb_user_query": "Which star is the most dense?\nGive me its name.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "most dense", "sql_snippet": "ORDER BY (CAST(json_extract(stellarprops, '$.physical.Mass_Value') AS REAL) * 1.98847E30) / (4.0/3.0 * 3.141592653589793 * ((CAST(json_extract(stellarprops, '$.physical.Radius_Value') AS REAL) * 6.957E8) * (CAST(json_extract(stellarprops, '$.physical.Radius_Value') AS REAL) * 6.957E8) * (CAST(json_extract(stellarprops, '$.physical.Radius_Value') AS REAL) * 6.957E8))) DESC\nLIMIT 1", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "star", "sql_snippet": "FROM stars", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "most", "sql_snippet": "ORDER BY ... DESC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "star", "sql_snippet": "WHERE CAST(json_extract(stellarprops, '$.physical.Mass_Value') AS REAL) IS NOT NULL AND CAST(json_extract(stellarprops, '$.physical.Radius_Value') AS REAL) IS NOT NULL AND CAST(json_extract(stellarprops, '$.physical.Radius_Value') AS REAL) > 0", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Stellar Density", "sql_snippet": "(CAST(json_extract(stellarprops, '$.physical.Mass_Value') AS REAL) * 1.98847E30) / (4.0/3.0 * 3.141592653589793 * ((CAST(json_extract(stellarprops, '$.physical.Radius_Value') AS REAL) * 6.957E8) * (CAST(json_extract(stellarprops, '$.physical.Radius_Value') AS REAL) * 6.957E8) * (CAST(json_extract(stellarprops, '$.physical.Radius_Value') AS REAL) * 6.957E8)))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 12}]}
{"instance_id": "planets_data_6", "selected_database": "planets_data", "amb_user_query": "Show me a list of all the planets with weird orbits, but only the ones where we have a mass estimate.\nI want to see the planet's name, its star's name, how weird its orbit is, and the mass ratio.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "weird orbits", "sql_snippet": "oc.\"eccentricity\" > 0.25", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "mass estimate", "sql_snippet": "LOWER(dqt.\"masssource\") = 'msini'", "is_mask": true, "type": "semantic_ambiguity"}], "non_critical_ambiguity": [{"term": "mass ratio", "sql_snippet": "ROUND(CAST((pp.\"massjup\" * 1.898E27) / (CAST(json_extract(s.stellarprops, '$.physical.Mass_Value') AS REAL) * 1.98847E30) AS REAL), 5)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "list", "sql_snippet": "ORDER BY mass_ratio ASC", "is_mask": false, "type": "sort_ambiguity"}, {"term": "planets_data", "sql_snippet": "AND pp.\"massjup\" IS NOT NULL\n  AND json_extract(s.stellarprops, '$.physical.Mass_Value') IS NOT NULL AND CAST(json_extract(s.stellarprops, '$.physical.Mass_Value') AS REAL) > 0", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Planet-Star Mass Ratio", "sql_snippet": "ROUND(CAST((pp.\"massjup\" * 1.898E27) / (CAST(json_extract(s.stellarprops, '$.physical.Mass_Value') AS REAL) * 1.98847E30) AS REAL), 5)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 18}]}
{"instance_id": "planets_data_7", "selected_database": "planets_data", "amb_user_query": "For all the big gassy planets found by the K2 telescope, what's their average temperature?\nGive me that in Kelvin.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "big gassy planets", "sql_snippet": "pp.\"massjup\" > 0.1", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "K2 telescope", "sql_snippet": "ins.\"facilityname\" = 'k2'", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "average", "sql_snippet": "ROUND(AVG(CAST(json_extract(s.stellarprops, '$.physical.Temp_Value') AS REAL) * SQRT(CAST(json_extract(s.stellarprops, '$.physical.Radius_Value') AS REAL) * 6.957E8 / (2 * oc.\"semimajor\" * 1.496E11))))", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "planets_data", "sql_snippet": "json_extract(s.stellarprops, '$.physical.Temp_Value') IS NOT NULL\n  AND json_extract(s.stellarprops, '$.physical.Radius_Value') IS NOT NULL\n  AND oc.\"semimajor\" IS NOT NULL AND oc.\"semimajor\" > 0", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Planetary Equilibrium Temperature", "sql_snippet": "CAST(json_extract(s.stellarprops, '$.physical.Temp_Value') AS REAL) * SQRT(CAST(json_extract(s.stellarprops, '$.physical.Radius_Value') AS REAL) * 6.957E8 / (2 * oc.\"semimajor\" * 1.496E11))", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "planets_data_8", "selected_database": "planets_data", "amb_user_query": "When planets found by the star wobble method pass in front of their star, what's the biggest dimming effect?\nTell me that dip in brightness, and also name the planet and star.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "star wobble method", "sql_snippet": "LOWER(p.\"discmethod\") IN ('radvel', 'rv', 'rv method', 'radial velocity', 'doppler')", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "biggest dimming effect", "sql_snippet": "ORDER BY transit_depth_percent DESC\nLIMIT 1", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "dip in brightness", "sql_snippet": "ROUND(transit_depth_percent, 4)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "planets_data", "sql_snippet": "AND CAST(json_extract(s.stellarprops, '$.physical.Radius_Value') AS REAL) IS NOT NULL AND CAST(json_extract(s.stellarprops, '$.physical.Radius_Value') AS REAL) > 0\n      AND pp.\"radjup\" IS NOT NULL", "is_mask": false, "type": "null_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Transit Depth", "sql_snippet": "POWER((pp.\"radjup\" * 11.209) / (CAST(json_extract(s.stellarprops, '$.physical.Radius_Value') AS REAL) * 109.2), 2) * 100", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 9}]}
{"instance_id": "reverse_logistics_3", "selected_database": "reverse_logistics", "amb_user_query": "On average, how much value do we recover per day? Include daily recovery value and recovery rate in the calculation.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "value recover per day", "sql_snippet": "ROUND(AVG(recovery_value / days_lapsed),2) AS avg_rrd", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "daily recover value", "sql_snippet": "SELECT\n    CAST(json_extract(fm.cost_breakdown, '$.valuation.recovery_value') AS REAL) AS recovery_value", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "rounding", "sql_snippet": "ROUND(AVG(recovery_value / days_lapsed),2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": [{"term": "recovery rate", "sql_snippet": "NULLIF(r.dayslapsed,0) AS days_lapsed", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 16}]}
{"instance_id": "reverse_logistics_4", "selected_database": "reverse_logistics", "amb_user_query": "What is the average sustainability-adjusted loss per return?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "sustainability-adjusted loss", "sql_snippet": "ROUND(AVG(\n      CAST(json_extract(r.return_details, '$.shipping.fee') AS REAL) +\n      CAST(json_extract(fm.cost_breakdown, '$.fees.restocking_fee') AS REAL) +\n      CAST(json_extract(fm.cost_breakdown, '$.fees.relabeling_cost') AS REAL) +\n      CAST(json_extract(fm.cost_breakdown, '$.disposal.disposal_cost') AS REAL) +\n      CAST(json_extract(fm.cost_breakdown, '$.repair_costs.repair_estimate') AS REAL) +\n      0.5 * CAST(json_extract(fm.cost_breakdown, '$.sustainability.carbon_footprint') AS REAL) -\n      CAST(json_extract(fm.cost_breakdown, '$.valuation.recovery_value') AS REAL)\n),2) AS avg_sal", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(\n      CAST(json_extract(r.return_details, '$.shipping.fee') AS REAL) +\n      CAST(json_extract(fm.cost_breakdown, '$.fees.restocking_fee') AS REAL) +\n      CAST(json_extract(fm.cost_breakdown, '$.fees.relabeling_cost') AS REAL) +\n      CAST(json_extract(fm.cost_breakdown, '$.disposal.disposal_cost') AS REAL) +\n      CAST(json_extract(fm.cost_breakdown, '$.repair_costs.repair_estimate') AS REAL) +\n      0.5 * CAST(json_extract(fm.cost_breakdown, '$.sustainability.carbon_footprint') AS REAL) -\n      CAST(json_extract(fm.cost_breakdown, '$.valuation.recovery_value') AS REAL)\n),2)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "reverse_logistics_5", "selected_database": "reverse_logistics", "amb_user_query": "How many days does each site take on average to finish a return? List individual processing times as well?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "individual processing times", "sql_snippet": "SELECT rp.proctime", "is_mask": false, "type": "schema_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(CAST(AVG(rp.proctime) OVER (PARTITION BY rp.loccode) AS REAL), 1)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "order", "sql_snippet": "ORDER BY apt_days DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "days on average", "sql_snippet": "ROUND(CAST(AVG(rp.proctime) OVER (PARTITION BY rp.loccode) AS REAL), 1) AS apt_days", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 5}]}
{"instance_id": "reverse_logistics_6", "selected_database": "reverse_logistics", "amb_user_query": "What percentage of returns fall under warranty coverage?", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": false, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "percentage of returns", "sql_snippet": "ROUND(\n100.0 * COUNT(CASE WHEN json_extract(r.return_details, '$.\"authorization\".\"warranty_claim\"') IS NOT NULL THEN 1 END)\n    / COUNT(*)\n  ,1) AS wcr_percent", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(\n    100.0 * COUNT(CASE WHEN json_extract(r.return_details, '$.\"authorization\".\"warranty_claim\"') IS NOT NULL THEN 1 END)\n    / COUNT(*)\n  ,1)", "is_mask": false, "type": "decimal_ambiguity"}]}, "knowledge_ambiguity": []}
{"instance_id": "news_11", "selected_database": "news", "amb_user_query": "Generate a report showing article engagement metrics grouped by topic. For each article, include how engaging each piece is and how easy it is to read, then output the article topic name with a JSON array containing each article's ID, category, and respective scores.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "how engaging each piece is", "sql_snippet": "(qualscore + freshscore + sentscore - contrscore) / 3.0 AS aqi", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "how easy it is to read", "sql_snippet": "(readsec * LOG(wordlen)) / diff_w   AS ars", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "topic", "sql_snippet": "GROUP BY catlabel", "is_mask": false, "type": "schema_linking_ambiguity"}, {"term": "respective scores", "sql_snippet": "(qualscore + freshscore + sentscore - contrscore) / 3.0 AS aqi, (qualscore + freshscore + sentscore - contrscore) / 3.0 AS aqi", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": []}
{"instance_id": "polar_11", "selected_database": "polar", "amb_user_query": "For each combination of station name and location type, I need to see station names, location type, average water quality indices, average WRMI scores, count of systems that need water-saving, water quality classification, and management situation. Group and sort results.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "water-saving", "sql_snippet": "COUNT(*) FILTER (WHERE wc.wrmi < 0.5) AS systems_needing_conservation", "is_mask": false, "type": "intent_ambiguity"}, {"term": "management situation", "sql_snippet": "CASE WHEN AVG(wc.wrmi) < 0.5 THEN 'Conservation Needed' WHEN AVG(wc.wrmi) < 0.7 THEN 'Monitoring Advised'  ELSE 'Sustainable Management'\nEND AS management_status", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "decimal", "sql_snippet": "ROUND(AVG(waw.waterqualityindex)::numeric, 2), ROUND(AVG(wc.wrmi)::numeric, 2)", "is_mask": false, "type": "decimal_ambiguity"}, {"term": "sort", "sql_snippet": "ORDER BY avg_wrmi DESC, avg_water_quality_index DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Water Resource Management Index (WRMI)", "sql_snippet": "waw.waterlevelpercent * (waw.waterqualityindex / 100) * (1 - waw.wastetanklevelpercent / 100) AS wrmi", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 7}]}
{"instance_id": "solar_11", "selected_database": "solar", "amb_user_query": "Show me how solar panel performance changes with age by calculating the performance metric for different age ranges. I want to see the panel age, the average metric, and the number of panels of each age group.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": [], "external_knowledge": [], "test_cases": [], "high_level": true, "category": "Query", "user_query_ambiguity": {"critical_ambiguity": [{"term": "performance metric", "sql_snippet": "EXTRACT(YEAR FROM AGE(CURRENT_DATE, pl.initdate)) AS panel_age_years", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "age ranges", "sql_snippet": "GROUP BY panel_age_years", "is_mask": false, "type": "intent_ambiguity"}], "non_critical_ambiguity": [{"term": "sort", "sql_snippet": "ORDER BY panel_age_years", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Energy Production Efficiency (EPE)", "sql_snippet": "AVG(pe.measpoww / p.powratew * 100) AS avg_ppr", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 3}]}
